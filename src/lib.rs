/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *mut _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *mut _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment =
            root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_string<_CharT, _Alloc> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider<_CharT,
                                                                  _Alloc>,
        }
        pub type basic_string__CharT_alloc_type = [u8; 0usize];
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type<_Alloc> = _Alloc;
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_reference = [u8; 0usize];
        pub type basic_string_const_reference = [u8; 0usize];
        pub type basic_string_pointer = [u8; 0usize];
        pub type basic_string_const_pointer = [u8; 0usize];
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        #[repr(C)]
        pub struct basic_string__Rep_base {
            pub _M_length: root::std::basic_string_size_type,
            pub _M_capacity: root::std::basic_string_size_type,
            pub _M_refcount: root::std::_Atomic_word,
        }
        #[repr(C)]
        pub struct basic_string__Rep {
            pub _base: root::std::basic_string__Rep_base,
        }
        pub type basic_string__Rep__Raw_bytes_alloc = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider<_CharT, _Alloc> {
            pub _base: _Alloc,
            pub _M_p: *mut _CharT,
        }
        #[test]
        fn __bindgen_test_layout_char_traits_instantiation_15707() {
            assert_eq!(::std::mem::size_of::<root::std::char_traits>() ,
                       1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::char_traits ) ));
            assert_eq!(::std::mem::align_of::<root::std::char_traits>() ,
                       1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::char_traits ) ));
        }
        pub type string =
            root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>;
        pub type true_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(::std::mem::size_of::<input_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( input_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<input_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( input_iterator_tag )
                        ));
        }
        impl Clone for input_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(::std::mem::size_of::<output_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( output_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<output_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( output_iterator_tag )
                        ));
        }
        impl Clone for output_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(::std::mem::size_of::<forward_iterator_tag>() , 1usize
                       , concat ! (
                       "Size of: " , stringify ! ( forward_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<forward_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! ( forward_iterator_tag )
                        ));
        }
        impl Clone for forward_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(::std::mem::size_of::<bidirectional_iterator_tag>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( bidirectional_iterator_tag
                       ) ));
            assert_eq! (::std::mem::align_of::<bidirectional_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! (
                        bidirectional_iterator_tag ) ));
        }
        impl Clone for bidirectional_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference =
            root::std::reverse_iterator___traits_type;
        #[repr(C)]
        pub struct istreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::istreambuf_iterator_streambuf_type<_CharT>,
            pub _M_c: root::std::istreambuf_iterator_int_type,
        }
        pub type istreambuf_iterator_char_type<_CharT> = _CharT;
        pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type istreambuf_iterator_int_type = [u8; 0usize];
        pub type istreambuf_iterator_streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type istreambuf_iterator_istream_type<_CharT> =
            root::std::basic_istream<_CharT>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ostreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::ostreambuf_iterator_streambuf_type<_CharT>,
            pub _M_failed: bool,
        }
        pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
        pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type ostreambuf_iterator_streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type ostreambuf_iterator_ostream_type<_CharT> =
            root::std::basic_ostream<_CharT>;
        pub type streamoff = ::std::os::raw::c_longlong;
        pub type streamsize = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
        }
        pub type streampos = root::std::fpos<::std::os::raw::c_int>;
        #[repr(C)]
        pub struct exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct exception {
            pub vtable_: *const exception__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(::std::mem::size_of::<exception>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( exception ) ));
            assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( exception ) ));
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[test]
        fn __bindgen_test_layout_allocator_instantiation_20294() {
            assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize
                       , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::allocator ) ));
            assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize
                       , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::allocator ) ));
        }
        pub type __c_locale = *mut ::std::os::raw::c_int;
        pub type _Atomic_word = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base {
            pub vtable_: *const ios_base__bindgen_vtable,
            pub _M_precision: root::std::streamsize,
            pub _M_width: root::std::streamsize,
            pub _M_flags: root::std::ios_base_fmtflags,
            pub _M_exception: root::std::ios_base_iostate,
            pub _M_streambuf_state: root::std::ios_base_iostate,
            pub _M_callbacks: *mut root::std::ios_base__Callback_list,
            pub _M_word_zero: root::std::ios_base__Words,
            pub _M_local_word: [root::std::ios_base__Words; 8usize],
            pub _M_word_size: ::std::os::raw::c_int,
            pub _M_word: *mut root::std::ios_base__Words,
            pub _M_ios_locale: root::std::locale,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base_failure {
            pub _base: root::std::exception,
            pub _M_msg: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_ios_base_failure() {
            assert_eq!(::std::mem::size_of::<ios_base_failure>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ios_base_failure ) ));
            assert_eq! (::std::mem::align_of::<ios_base_failure>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base_failure ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base_failure ) ) . _M_msg as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base_failure ) , "::" , stringify ! ( _M_msg ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7failureC1ERKSs"]
            pub fn ios_base_failure_failure(this:
                                                *mut root::std::ios_base_failure,
                                            __str: *const root::std::string);
        }
        impl ios_base_failure {
            #[inline]
            pub unsafe fn new(__str: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure(&mut __bindgen_tmp, __str);
                __bindgen_tmp
            }
        }
        pub use self::super::super::root::std::_Ios_Fmtflags as
                ios_base_fmtflags;
        pub use self::super::super::root::std::_Ios_Iostate as
                ios_base_iostate;
        pub use self::super::super::root::std::_Ios_Openmode as
                ios_base_openmode;
        pub use self::super::super::root::std::_Ios_Seekdir as
                ios_base_seekdir;
        pub type ios_base_io_state = ::std::os::raw::c_int;
        pub type ios_base_open_mode = ::std::os::raw::c_int;
        pub type ios_base_seek_dir = ::std::os::raw::c_int;
        pub type ios_base_streampos = root::std::streampos;
        pub type ios_base_streamoff = root::std::streamoff;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ios_base_event {
            erase_event = 0,
            imbue_event = 1,
            copyfmt_event = 2,
        }
        pub type ios_base_event_callback =
            ::std::option::Option<unsafe extern "C" fn(__e:
                                                           root::std::ios_base_event,
                                                       __b:
                                                           *mut root::std::ios_base,
                                                       __i:
                                                           ::std::os::raw::c_int)>;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ios_base__Callback_list {
            pub _M_next: *mut root::std::ios_base__Callback_list,
            pub _M_fn: root::std::ios_base_event_callback,
            pub _M_index: ::std::os::raw::c_int,
            pub _M_refcount: root::std::_Atomic_word,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Callback_list() {
            assert_eq!(::std::mem::size_of::<ios_base__Callback_list>() ,
                       24usize , concat ! (
                       "Size of: " , stringify ! ( ios_base__Callback_list )
                       ));
            assert_eq! (::std::mem::align_of::<ios_base__Callback_list>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ios_base__Callback_list ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_next as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_next ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_fn as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! ( _M_fn
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_index as * const _ as usize } , 16usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_index ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_refcount as * const _ as usize } , 20usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_refcount ) ));
        }
        impl Clone for ios_base__Callback_list {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ios_base__Words {
            pub _M_pword: *mut ::std::os::raw::c_void,
            pub _M_iword: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Words() {
            assert_eq!(::std::mem::size_of::<ios_base__Words>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ios_base__Words ) ));
            assert_eq! (::std::mem::align_of::<ios_base__Words>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base__Words ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Words ) ) . _M_pword as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base__Words
                        ) , "::" , stringify ! ( _M_pword ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Words ) ) . _M_iword as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base__Words
                        ) , "::" , stringify ! ( _M_iword ) ));
        }
        impl Clone for ios_base__Words {
            fn clone(&self) -> Self { *self }
        }
        pub const ios_base__S_local_word_size:
                  root::std::ios_base__bindgen_ty_1 =
            ios_base__bindgen_ty_1::_S_local_word_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ios_base__bindgen_ty_1 { _S_local_word_size = 8, }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base_Init {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4Init11_S_refcountE"]
            pub static mut ios_base_Init__S_refcount: root::std::_Atomic_word;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
            pub static mut ios_base_Init__S_synced_with_stdio: bool;
        }
        #[test]
        fn bindgen_test_layout_ios_base_Init() {
            assert_eq!(::std::mem::size_of::<ios_base_Init>() , 1usize ,
                       concat ! ( "Size of: " , stringify ! ( ios_base_Init )
                       ));
            assert_eq! (::std::mem::align_of::<ios_base_Init>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base_Init ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4InitC1Ev"]
            pub fn ios_base_Init_Init(this: *mut root::std::ios_base_Init);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4InitD1Ev"]
            pub fn ios_base_Init_Init_destructor(this:
                                                     *mut root::std::ios_base_Init);
        }
        impl ios_base_Init {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_Init_Init(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ios_base_Init_Init_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9boolalphaE"]
            pub static ios_base_boolalpha: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3decE"]
            pub static ios_base_dec: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5fixedE"]
            pub static ios_base_fixed: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3hexE"]
            pub static ios_base_hex: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base8internalE"]
            pub static ios_base_internal: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4leftE"]
            pub static ios_base_left: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3octE"]
            pub static ios_base_oct: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5rightE"]
            pub static ios_base_right: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base10scientificE"]
            pub static ios_base_scientific: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base8showbaseE"]
            pub static ios_base_showbase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9showpointE"]
            pub static ios_base_showpoint: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7showposE"]
            pub static ios_base_showpos: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6skipwsE"]
            pub static ios_base_skipws: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7unitbufE"]
            pub static ios_base_unitbuf: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9uppercaseE"]
            pub static ios_base_uppercase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base11adjustfieldE"]
            pub static ios_base_adjustfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9basefieldE"]
            pub static ios_base_basefield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base10floatfieldE"]
            pub static ios_base_floatfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6badbitE"]
            pub static ios_base_badbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6eofbitE"]
            pub static ios_base_eofbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7failbitE"]
            pub static ios_base_failbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7goodbitE"]
            pub static ios_base_goodbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3appE"]
            pub static ios_base_app: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3ateE"]
            pub static ios_base_ate: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6binaryE"]
            pub static ios_base_binary: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base2inE"]
            pub static ios_base_in: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3outE"]
            pub static ios_base_out: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5truncE"]
            pub static ios_base_trunc: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3begE"]
            pub static ios_base_beg: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3curE"]
            pub static ios_base_cur: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3endE"]
            pub static ios_base_end: root::std::ios_base_seekdir;
        }
        #[test]
        fn bindgen_test_layout_ios_base() {
            assert_eq!(::std::mem::size_of::<ios_base>() , 216usize , concat !
                       ( "Size of: " , stringify ! ( ios_base ) ));
            assert_eq! (::std::mem::align_of::<ios_base>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( ios_base ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_precision as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_precision ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_width as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_width ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_flags as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_flags ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_exception as *
                        const _ as usize } , 28usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_exception ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_streambuf_state
                        as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_streambuf_state ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_callbacks as *
                        const _ as usize } , 40usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_callbacks ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word_zero as *
                        const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word_zero ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_local_word as *
                        const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_local_word ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word_size as *
                        const _ as usize } , 192usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word_size ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word as * const
                        _ as usize } , 200usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_ios_locale as *
                        const _ as usize } , 208usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_ios_locale ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
            pub fn ios_base_register_callback(this: *mut root::std::ios_base,
                                              __fn:
                                                  root::std::ios_base_event_callback,
                                              __index: ::std::os::raw::c_int);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
            pub fn ios_base__M_call_callbacks(this: *mut root::std::ios_base,
                                              __ev:
                                                  root::std::ios_base_event);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base20_M_dispose_callbacksEv"]
            pub fn ios_base__M_dispose_callbacks(this:
                                                     *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base13_M_grow_wordsEib"]
            pub fn ios_base__M_grow_words(this: *mut root::std::ios_base,
                                          __index: ::std::os::raw::c_int,
                                          __iword: bool)
             -> *mut root::std::ios_base__Words;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7_M_initEv"]
            pub fn ios_base__M_init(this: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base15sync_with_stdioEb"]
            pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5imbueERKSt6locale"]
            pub fn ios_base_imbue(this: *mut root::std::ios_base,
                                  __loc: *const root::std::locale)
             -> root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6xallocEv"]
            pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_baseC1Ev"]
            pub fn ios_base_ios_base(this: *mut root::std::ios_base);
        }
        impl ios_base {
            #[inline]
            pub unsafe fn register_callback(&mut self,
                                            __fn:
                                                root::std::ios_base_event_callback,
                                            __index: ::std::os::raw::c_int) {
                ios_base_register_callback(self, __fn, __index)
            }
            #[inline]
            pub unsafe fn _M_call_callbacks(&mut self,
                                            __ev: root::std::ios_base_event) {
                ios_base__M_call_callbacks(self, __ev)
            }
            #[inline]
            pub unsafe fn _M_dispose_callbacks(&mut self) {
                ios_base__M_dispose_callbacks(self)
            }
            #[inline]
            pub unsafe fn _M_grow_words(&mut self,
                                        __index: ::std::os::raw::c_int,
                                        __iword: bool)
             -> *mut root::std::ios_base__Words {
                ios_base__M_grow_words(self, __index, __iword)
            }
            #[inline]
            pub unsafe fn _M_init(&mut self) { ios_base__M_init(self) }
            #[inline]
            pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
                ios_base_sync_with_stdio(__sync)
            }
            #[inline]
            pub unsafe fn imbue(&mut self, __loc: *const root::std::locale)
             -> root::std::locale {
                ios_base_imbue(self, __loc)
            }
            #[inline]
            pub unsafe fn xalloc() -> ::std::os::raw::c_int {
                ios_base_xalloc()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ios<_CharT> {
            pub _base: root::std::ios_base,
            pub _M_tie: *mut root::std::basic_ostream<_CharT>,
            pub _M_fill: root::std::basic_ios_char_type<_CharT>,
            pub _M_fill_init: bool,
            pub _M_streambuf: *mut root::std::basic_streambuf<_CharT>,
            pub _M_ctype: *const root::std::basic_ios___ctype_type,
            pub _M_num_put: *const root::std::basic_ios___num_put_type,
            pub _M_num_get: *const root::std::basic_ios___num_get_type,
        }
        pub type basic_ios_char_type<_CharT> = _CharT;
        pub type basic_ios_int_type = [u8; 0usize];
        pub type basic_ios_pos_type = [u8; 0usize];
        pub type basic_ios_off_type = [u8; 0usize];
        pub type basic_ios_traits_type<_Traits> = _Traits;
        pub type basic_ios___ctype_type = root::std::ctype;
        pub type basic_ios___num_put_type = root::std::num_put;
        pub type basic_ios___num_get_type = root::std::num_get;
        #[repr(C)]
        pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_streambuf<_CharT> {
            pub vtable_: *const basic_streambuf__bindgen_vtable,
            pub _M_in_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_buf_locale: root::std::locale,
        }
        pub type basic_streambuf_char_type<_CharT> = _CharT;
        pub type basic_streambuf_traits_type<_Traits> = _Traits;
        pub type basic_streambuf_int_type = [u8; 0usize];
        pub type basic_streambuf_pos_type = [u8; 0usize];
        pub type basic_streambuf_off_type = [u8; 0usize];
        pub type basic_streambuf___streambuf_type =
            root::std::basic_streambuf<root::std::basic_streambuf_char_type<_CharT>>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_istream<_CharT> {
            pub _M_gcount: root::std::streamsize,
        }
        pub type basic_istream_char_type<_CharT> = _CharT;
        pub type basic_istream_int_type = [u8; 0usize];
        pub type basic_istream_pos_type = [u8; 0usize];
        pub type basic_istream_off_type = [u8; 0usize];
        pub type basic_istream_traits_type<_Traits> = _Traits;
        pub type basic_istream___streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type basic_istream___ios_type<_CharT> =
            root::std::basic_ios<_CharT>;
        pub type basic_istream___istream_type<_CharT> =
            root::std::basic_istream<_CharT>;
        pub type basic_istream___num_get_type = root::std::num_get;
        pub type basic_istream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_istream_sentry {
            pub _M_ok: bool,
        }
        pub type basic_istream_sentry_traits_type = _Traits;
        pub type basic_istream_sentry___streambuf_type =
            root::std::basic_streambuf<_CharT>;
        pub type basic_istream_sentry___istream_type =
            root::std::basic_istream<_CharT>;
        pub type basic_istream_sentry___ctype_type =
            root::std::basic_istream___ctype_type;
        pub type basic_istream_sentry___int_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ostream<_CharT> {
        }
        pub type basic_ostream_char_type<_CharT> = _CharT;
        pub type basic_ostream_int_type = [u8; 0usize];
        pub type basic_ostream_pos_type = [u8; 0usize];
        pub type basic_ostream_off_type = [u8; 0usize];
        pub type basic_ostream_traits_type<_Traits> = _Traits;
        pub type basic_ostream___streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type basic_ostream___ios_type<_CharT> =
            root::std::basic_ios<_CharT>;
        pub type basic_ostream___ostream_type<_CharT> =
            root::std::basic_ostream<_CharT>;
        pub type basic_ostream___num_put_type = root::std::num_put;
        pub type basic_ostream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ostream_sentry {
            pub _M_ok: bool,
            pub _M_os: *mut root::std::basic_ostream<_CharT>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_stringbuf<_CharT, _Alloc> {
            pub _base: root::std::basic_streambuf<_CharT>,
            pub _M_mode: root::std::ios_base_openmode,
            pub _M_string: root::std::basic_stringbuf___string_type<_Alloc>,
        }
        pub type basic_stringbuf_char_type<_CharT> = _CharT;
        pub type basic_stringbuf_traits_type<_Traits> = _Traits;
        pub type basic_stringbuf_allocator_type<_Alloc> = _Alloc;
        pub type basic_stringbuf_int_type = [u8; 0usize];
        pub type basic_stringbuf_pos_type = [u8; 0usize];
        pub type basic_stringbuf_off_type = [u8; 0usize];
        pub type basic_stringbuf___streambuf_type =
            root::std::basic_streambuf<root::std::basic_stringbuf_char_type<_CharT>>;
        pub type basic_stringbuf___string_type<_Alloc> =
            root::std::basic_string<root::std::basic_stringbuf_char_type<_CharT>,
                                    _Alloc>;
        pub type basic_stringbuf___size_type<_Alloc> =
            root::std::basic_stringbuf___string_type<_Alloc>;
        pub type istream = root::std::basic_istream<::std::os::raw::c_char>;
        pub type ostream = root::std::basic_ostream<::std::os::raw::c_char>;
        pub type stringbuf =
            root::std::basic_stringbuf<::std::os::raw::c_char,
                                       root::std::allocator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale {
            pub _M_impl: *mut root::std::locale__Impl,
        }
        pub type locale_category = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale_facet {
            pub vtable_: *const locale_facet__bindgen_vtable,
            pub _M_refcount: root::std::_Atomic_word,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet11_S_c_localeE"]
            pub static mut locale_facet__S_c_locale: root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet9_S_c_nameE"]
            pub static mut locale_facet__S_c_name:
                       [::std::os::raw::c_char; 2usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet7_S_onceE"]
            pub static mut locale_facet__S_once: root::std::__gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale_facet() {
            assert_eq!(::std::mem::size_of::<locale_facet>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( locale_facet )
                       ));
            assert_eq! (::std::mem::align_of::<locale_facet>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( locale_facet ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale_facet ) ) . _M_refcount as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale_facet )
                        , "::" , stringify ! ( _M_refcount ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet18_S_create_c_localeERPiPKcS1_"]
            pub fn locale_facet__S_create_c_locale(__cloc:
                                                       *mut root::std::__c_locale,
                                                   __s:
                                                       *const ::std::os::raw::c_char,
                                                   __old:
                                                       root::std::__c_locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet17_S_clone_c_localeERPi"]
            pub fn locale_facet__S_clone_c_locale(__cloc:
                                                      *mut root::std::__c_locale)
             -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet19_S_destroy_c_localeERPi"]
            pub fn locale_facet__S_destroy_c_locale(__cloc:
                                                        *mut root::std::__c_locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet20_S_lc_ctype_c_localeEPiPKc"]
            pub fn locale_facet__S_lc_ctype_c_locale(__cloc:
                                                         root::std::__c_locale,
                                                     __s:
                                                         *const ::std::os::raw::c_char)
             -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet15_S_get_c_localeEv"]
            pub fn locale_facet__S_get_c_locale() -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet13_S_get_c_nameEv"]
            pub fn locale_facet__S_get_c_name()
             -> *const ::std::os::raw::c_char;
        }
        impl locale_facet {
            #[inline]
            pub unsafe fn _S_create_c_locale(__cloc:
                                                 *mut root::std::__c_locale,
                                             __s:
                                                 *const ::std::os::raw::c_char,
                                             __old: root::std::__c_locale) {
                locale_facet__S_create_c_locale(__cloc, __s, __old)
            }
            #[inline]
            pub unsafe fn _S_clone_c_locale(__cloc:
                                                *mut root::std::__c_locale)
             -> root::std::__c_locale {
                locale_facet__S_clone_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_destroy_c_locale(__cloc:
                                                  *mut root::std::__c_locale) {
                locale_facet__S_destroy_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_lc_ctype_c_locale(__cloc: root::std::__c_locale,
                                               __s:
                                                   *const ::std::os::raw::c_char)
             -> root::std::__c_locale {
                locale_facet__S_lc_ctype_c_locale(__cloc, __s)
            }
            #[inline]
            pub unsafe fn _S_get_c_locale() -> root::std::__c_locale {
                locale_facet__S_get_c_locale()
            }
            #[inline]
            pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
                locale_facet__S_get_c_name()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct locale_id {
            pub _M_index: usize,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale2id11_S_refcountE"]
            pub static mut locale_id__S_refcount: root::std::_Atomic_word;
        }
        #[test]
        fn bindgen_test_layout_locale_id() {
            assert_eq!(::std::mem::size_of::<locale_id>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( locale_id ) ));
            assert_eq! (::std::mem::align_of::<locale_id>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( locale_id ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale_id ) ) . _M_index as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale_id ) ,
                        "::" , stringify ! ( _M_index ) ));
        }
        extern "C" {
            #[link_name = "_ZNKSt6locale2id5_M_idEv"]
            pub fn locale_id__M_id(this: *const root::std::locale_id)
             -> usize;
        }
        impl Clone for locale_id {
            fn clone(&self) -> Self { *self }
        }
        impl locale_id {
            #[inline]
            pub unsafe fn _M_id(&self) -> usize { locale_id__M_id(self) }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale__Impl {
            pub _M_refcount: root::std::_Atomic_word,
            pub _M_facets: *mut *const root::std::locale_facet,
            pub _M_facets_size: usize,
            pub _M_caches: *mut *const root::std::locale_facet,
            pub _M_names: *mut *mut ::std::os::raw::c_char,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl11_S_id_ctypeE"]
            pub static mut locale__Impl__S_id_ctype:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl13_S_id_numericE"]
            pub static mut locale__Impl__S_id_numeric:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl13_S_id_collateE"]
            pub static mut locale__Impl__S_id_collate:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl10_S_id_timeE"]
            pub static mut locale__Impl__S_id_time:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl14_S_id_monetaryE"]
            pub static mut locale__Impl__S_id_monetary:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl14_S_id_messagesE"]
            pub static mut locale__Impl__S_id_messages:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl19_S_facet_categoriesE"]
            pub static mut locale__Impl__S_facet_categories:
                       [*const *const root::std::locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale__Impl() {
            assert_eq!(::std::mem::size_of::<locale__Impl>() , 40usize ,
                       concat ! ( "Size of: " , stringify ! ( locale__Impl )
                       ));
            assert_eq! (::std::mem::align_of::<locale__Impl>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( locale__Impl ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_refcount as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_refcount ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_facets as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_facets ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_facets_size
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_facets_size ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_caches as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_caches ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_names as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_names ) ));
        }
        pub const locale__S_categories_size: root::std::locale__bindgen_ty_1 =
            locale__bindgen_ty_1::_S_categories_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum locale__bindgen_ty_1 { _S_categories_size = 6, }
        pub const locale_none: root::std::locale_category = 0;
        pub const locale_ctype: root::std::locale_category = 1;
        pub const locale_numeric: root::std::locale_category = 2;
        pub const locale_collate: root::std::locale_category = 4;
        pub const locale_time: root::std::locale_category = 8;
        pub const locale_monetary: root::std::locale_category = 16;
        pub const locale_messages: root::std::locale_category = 32;
        pub const locale_all: root::std::locale_category = 63;
        extern "C" {
            #[link_name = "_ZNSt6locale10_S_classicE"]
            pub static mut locale__S_classic: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale9_S_globalE"]
            pub static mut locale__S_global: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale13_S_categoriesE"]
            pub static locale__S_categories:
                       *const *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale7_S_onceE"]
            pub static mut locale__S_once: root::std::__gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale() {
            assert_eq!(::std::mem::size_of::<locale>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( locale ) ));
            assert_eq! (::std::mem::align_of::<locale>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( locale ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale ) ) . _M_impl as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale ) , "::"
                        , stringify ! ( _M_impl ) ));
        }
        extern "C" {
            #[link_name = "_ZNKSt6locale4nameEv"]
            pub fn locale_name(this: *const root::std::locale)
             -> root::std::string;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale6globalERKS_"]
            pub fn locale_global(__loc: *const root::std::locale)
             -> root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale7classicEv"]
            pub fn locale_classic() -> *const root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1Ev"]
            pub fn locale_locale(this: *mut root::std::locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_"]
            pub fn locale_locale1(this: *mut root::std::locale,
                                  __other: *const root::std::locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1EPKc"]
            pub fn locale_locale2(this: *mut root::std::locale,
                                  __s: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_PKci"]
            pub fn locale_locale3(this: *mut root::std::locale,
                                  __base: *const root::std::locale,
                                  __s: *const ::std::os::raw::c_char,
                                  __cat: root::std::locale_category);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_S1_i"]
            pub fn locale_locale4(this: *mut root::std::locale,
                                  __base: *const root::std::locale,
                                  __add: *const root::std::locale,
                                  __cat: root::std::locale_category);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeD1Ev"]
            pub fn locale_locale_destructor(this: *mut root::std::locale);
        }
        impl locale {
            #[inline]
            pub unsafe fn name(&self) -> root::std::string {
                locale_name(self)
            }
            #[inline]
            pub unsafe fn global(__loc: *const root::std::locale)
             -> root::std::locale {
                locale_global(__loc)
            }
            #[inline]
            pub unsafe fn classic() -> *const root::std::locale {
                locale_classic()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__other: *const root::std::locale) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale1(&mut __bindgen_tmp, __other);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale2(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(__base: *const root::std::locale,
                               __s: *const ::std::os::raw::c_char,
                               __cat: root::std::locale_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__base: *const root::std::locale,
                               __add: *const root::std::locale,
                               __cat: root::std::locale_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale4(&mut __bindgen_tmp, __base, __add, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                locale_locale_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ctype_base {
            pub _address: u8,
        }
        pub type ctype_base___to_type = *const ::std::os::raw::c_int;
        pub type ctype_base_mask = ::std::os::raw::c_ushort;
        pub const ctype_base_upper: root::std::ctype_base_mask = 1;
        pub const ctype_base_lower: root::std::ctype_base_mask = 2;
        pub const ctype_base_alpha: root::std::ctype_base_mask = 4;
        pub const ctype_base_digit: root::std::ctype_base_mask = 8;
        pub const ctype_base_xdigit: root::std::ctype_base_mask = 16;
        pub const ctype_base_space: root::std::ctype_base_mask = 32;
        pub const ctype_base_print: root::std::ctype_base_mask = 64;
        pub const ctype_base_graph: root::std::ctype_base_mask = 524;
        pub const ctype_base_cntrl: root::std::ctype_base_mask = 256;
        pub const ctype_base_punct: root::std::ctype_base_mask = 512;
        pub const ctype_base_alnum: root::std::ctype_base_mask = 12;
        #[test]
        fn bindgen_test_layout_ctype_base() {
            assert_eq!(::std::mem::size_of::<ctype_base>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( ctype_base ) ));
            assert_eq! (::std::mem::align_of::<ctype_base>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( ctype_base ) ));
        }
        impl Clone for ctype_base {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ctype {
            pub _base: root::std::__ctype_abstract_base,
        }
        pub type ctype_char_type<_CharT> = _CharT;
        pub type ctype_mask = root::std::__ctype_abstract_base;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_get {
            pub _base: root::std::locale_facet,
        }
        pub type num_get_char_type<_CharT> = _CharT;
        pub type num_get_iter_type<_InIter> = _InIter;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_put {
            pub _base: root::std::locale_facet,
        }
        pub type num_put_char_type<_CharT> = _CharT;
        pub type num_put_iter_type<_OutIter> = _OutIter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Select1st {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_basic_string_instantiation_24961() {
            assert_eq!(::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char,
                                              root::std::allocator>>()
                       , 8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_string<::std::os::raw::c_char, root::std::allocator>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char,
                                               root::std::allocator>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::std::basic_string<::std::os::raw::c_char, root::std::allocator>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits___pointer<_Alloc> = _Alloc;
        pub type allocator_traits_pointer<_Alloc> =
            root::std::allocator_traits___pointer<_Alloc>;
        pub type allocator_traits___const_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_pointer<_Alloc> =
            root::std::allocator_traits___const_pointer<_Alloc>;
        pub type allocator_traits___void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_void_pointer<_Alloc> =
            root::std::allocator_traits___void_pointer<_Alloc>;
        pub type allocator_traits___const_void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_void_pointer<_Alloc> =
            root::std::allocator_traits___const_void_pointer<_Alloc>;
        pub type allocator_traits___difference_type<_Alloc> = _Alloc;
        pub type allocator_traits_difference_type<_Alloc> =
            root::std::allocator_traits___difference_type<_Alloc>;
        pub type allocator_traits___size_type<_Alloc> = _Alloc;
        pub type allocator_traits_size_type<_Alloc> =
            root::std::allocator_traits___size_type<_Alloc>;
        pub type allocator_traits___propagate_on_container_copy_assignment<_Alloc>
            = _Alloc;
        pub type allocator_traits_propagate_on_container_copy_assignment<_Alloc>
            =
            root::std::allocator_traits___propagate_on_container_copy_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_move_assignment<_Alloc>
            = _Alloc;
        pub type allocator_traits_propagate_on_container_move_assignment<_Alloc>
            =
            root::std::allocator_traits___propagate_on_container_move_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_swap<_Alloc> =
            _Alloc;
        pub type allocator_traits_propagate_on_container_swap<_Alloc> =
            root::std::allocator_traits___propagate_on_container_swap<_Alloc>;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___allocate_helper {
            pub _address: u8,
        }
        pub type allocator_traits___allocate_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_allocate =
            root::std::allocator_traits___allocate_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct =
            root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___destroy_helper {
            pub _address: u8,
        }
        pub type allocator_traits___destroy_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_destroy =
            root::std::allocator_traits___destroy_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___maxsize_helper {
            pub _address: u8,
        }
        pub type allocator_traits___maxsize_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_max_size =
            root::std::allocator_traits___maxsize_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___select_helper {
            pub _address: u8,
        }
        pub type allocator_traits___select_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_soccc =
            root::std::allocator_traits___select_helper;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type =
            root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Alloc_value_type = [u8; 0usize];
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct _List_node_base {
                pub _M_next: *mut root::std::__detail::_List_node_base,
                pub _M_prev: *mut root::std::__detail::_List_node_base,
            }
            #[test]
            fn bindgen_test_layout__List_node_base() {
                assert_eq!(::std::mem::size_of::<_List_node_base>() , 16usize
                           , concat ! (
                           "Size of: " , stringify ! ( _List_node_base ) ));
                assert_eq! (::std::mem::align_of::<_List_node_base>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( _List_node_base )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const _List_node_base ) ) . _M_next
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            _List_node_base ) , "::" , stringify ! ( _M_next )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const _List_node_base ) ) . _M_prev
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            _List_node_base ) , "::" , stringify ! ( _M_prev )
                            ));
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
                pub fn _List_node_base_swap(__x:
                                                *mut root::std::__detail::_List_node_base,
                                            __y:
                                                *mut root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name =
                      "_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
                pub fn _List_node_base__M_transfer(this:
                                                       *mut root::std::__detail::_List_node_base,
                                                   __first:
                                                       *const root::std::__detail::_List_node_base,
                                                   __last:
                                                       *const root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base10_M_reverseEv"]
                pub fn _List_node_base__M_reverse(this:
                                                      *mut root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
                pub fn _List_node_base__M_hook(this:
                                                   *mut root::std::__detail::_List_node_base,
                                               __position:
                                                   *const root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base9_M_unhookEv"]
                pub fn _List_node_base__M_unhook(this:
                                                     *mut root::std::__detail::_List_node_base);
            }
            impl Clone for _List_node_base {
                fn clone(&self) -> Self { *self }
            }
            impl _List_node_base {
                #[inline]
                pub unsafe fn swap(__x:
                                       *mut root::std::__detail::_List_node_base,
                                   __y:
                                       *mut root::std::__detail::_List_node_base) {
                    _List_node_base_swap(__x, __y)
                }
                #[inline]
                pub unsafe fn _M_transfer(&mut self,
                                          __first:
                                              *const root::std::__detail::_List_node_base,
                                          __last:
                                              *const root::std::__detail::_List_node_base) {
                    _List_node_base__M_transfer(self, __first, __last)
                }
                #[inline]
                pub unsafe fn _M_reverse(&mut self) {
                    _List_node_base__M_reverse(self)
                }
                #[inline]
                pub unsafe fn _M_hook(&mut self,
                                      __position:
                                          *const root::std::__detail::_List_node_base) {
                    _List_node_base__M_hook(self, __position)
                }
                #[inline]
                pub unsafe fn _M_unhook(&mut self) {
                    _List_node_base__M_unhook(self)
                }
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Fmtflags {
            _S_boolalpha = 1,
            _S_dec = 2,
            _S_fixed = 4,
            _S_hex = 8,
            _S_internal = 16,
            _S_left = 32,
            _S_oct = 64,
            _S_right = 128,
            _S_scientific = 256,
            _S_showbase = 512,
            _S_showpoint = 1024,
            _S_showpos = 2048,
            _S_skipws = 4096,
            _S_unitbuf = 8192,
            _S_uppercase = 16384,
            _S_adjustfield = 176,
            _S_basefield = 74,
            _S_floatfield = 260,
            _S_ios_fmtflags_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Openmode {
            _S_app = 1,
            _S_ate = 2,
            _S_bin = 4,
            _S_in = 8,
            _S_out = 16,
            _S_trunc = 32,
            _S_ios_openmode_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Iostate {
            _S_goodbit = 0,
            _S_badbit = 1,
            _S_eofbit = 2,
            _S_failbit = 4,
            _S_ios_iostate_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Seekdir {
            _S_beg = 0,
            _S_cur = 1,
            _S_end = 2,
            _S_ios_seekdir_end = 65536,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __ctype_abstract_base {
            pub _base: root::std::locale_facet,
        }
        pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
        #[test]
        fn __bindgen_test_layout_basic_ostream_instantiation_34197() {
            assert_eq!(::std::mem::size_of::<root::std::basic_ostream<::std::os::raw::c_char>>()
                       , 272usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_ostream<::std::os::raw::c_char> ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_ostream<::std::os::raw::c_char>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::basic_ostream<::std::os::raw::c_char> )
                       ));
        }
        #[test]
        fn __bindgen_test_layout_basic_istream_instantiation_34348() {
            assert_eq!(::std::mem::size_of::<root::std::basic_istream<::std::os::raw::c_char>>()
                       , 280usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_istream<::std::os::raw::c_char> ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_istream<::std::os::raw::c_char>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::basic_istream<::std::os::raw::c_char> )
                       ));
        }
        #[test]
        fn __bindgen_test_layout_basic_stringbuf_instantiation_34475() {
            assert_eq!(::std::mem::size_of::<root::std::basic_stringbuf<::std::os::raw::c_char,
                                                 root::std::allocator>>()
                       , 80usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_stringbuf<::std::os::raw::c_char, root::std::allocator>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_stringbuf<::std::os::raw::c_char,
                                                  root::std::allocator>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::std::basic_stringbuf<::std::os::raw::c_char, root::std::allocator>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct complex<_Tp> {
            pub _M_real: _Tp,
            pub _M_imag: _Tp,
        }
        pub type complex_value_type<_Tp> = _Tp;
        #[test]
        fn __bindgen_test_layout_complex_instantiation_34529() {
            assert_eq!(::std::mem::size_of::<root::std::complex<f32>>() ,
                       8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::complex<f32> ) ));
            assert_eq!(::std::mem::align_of::<root::std::complex<f32>>() ,
                       4usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::complex<f32> ) ));
        }
        #[test]
        fn __bindgen_test_layout_complex_instantiation_34533() {
            assert_eq!(::std::mem::size_of::<root::std::complex<f64>>() ,
                       16usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::complex<f64> ) ));
            assert_eq!(::std::mem::align_of::<root::std::complex<f64>>() ,
                       8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::complex<f64> ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_node<_Tp> {
            pub _base: root::std::__detail::_List_node_base,
            pub _M_data: _Tp,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_iterator {
            pub _M_node: *mut root::std::__detail::_List_node_base,
        }
        pub type _List_iterator__Self = root::std::_List_iterator;
        pub type _List_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_iterator_difference_type = isize;
        pub type _List_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _List_iterator_value_type<_Tp> = _Tp;
        pub type _List_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_const_iterator {
            pub _M_node: *const root::std::__detail::_List_node_base,
        }
        pub type _List_const_iterator__Self = root::std::_List_const_iterator;
        pub type _List_const_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_const_iterator_iterator = root::std::_List_iterator;
        pub type _List_const_iterator_difference_type = isize;
        pub type _List_const_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _List_const_iterator_value_type<_Tp> = _Tp;
        pub type _List_const_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_const_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        pub struct _List_base {
            pub _M_impl: root::std::_List_base__List_impl,
        }
        pub type _List_base__Node_alloc_type = [u8; 0usize];
        pub type _List_base__Tp_alloc_type = [u8; 0usize];
        #[repr(C)]
        pub struct _List_base__List_impl {
            pub _M_node: root::std::__detail::_List_node_base,
        }
        pub type _List_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct list {
            pub _base: root::std::_List_base,
        }
        pub type list__Alloc_value_type = [u8; 0usize];
        pub type list__Base = root::std::_List_base;
        pub type list__Tp_alloc_type = root::std::list__Base;
        pub type list__Node_alloc_type = root::std::list__Base;
        pub type list_value_type<_Tp> = _Tp;
        pub type list_pointer = root::std::list__Tp_alloc_type;
        pub type list_const_pointer = root::std::list__Tp_alloc_type;
        pub type list_reference = root::std::list__Tp_alloc_type;
        pub type list_const_reference = root::std::list__Tp_alloc_type;
        pub type list_iterator = root::std::_List_iterator;
        pub type list_const_iterator = root::std::_List_const_iterator;
        pub type list_const_reverse_iterator =
            root::std::reverse_iterator<root::std::list_const_iterator>;
        pub type list_reverse_iterator =
            root::std::reverse_iterator<root::std::list_iterator>;
        pub type list_size_type = usize;
        pub type list_difference_type = isize;
        pub type list_allocator_type<_Alloc> = _Alloc;
        pub type list__Node<_Tp> = root::std::_List_node<_Tp>;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Rb_tree_color { _S_red = 0, _S_black = 1, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct _Rb_tree_node_base {
            pub _M_color: root::std::_Rb_tree_color,
            pub _M_parent: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_left: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_right: root::std::_Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr =
            *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr =
            *const root::std::_Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(::std::mem::size_of::<_Rb_tree_node_base>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( _Rb_tree_node_base ) ));
            assert_eq! (::std::mem::align_of::<_Rb_tree_node_base>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( _Rb_tree_node_base )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_color
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_color )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) .
                        _M_parent as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_parent
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_left
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_left )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_right
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_right )
                        ));
        }
        impl Clone for _Rb_tree_node_base {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        pub struct _Rb_tree_node {
            pub _base: root::std::_Rb_tree_node_base,
            pub _M_storage: root::__gnu_cxx::__aligned_buffer,
        }
        pub type _Rb_tree_node__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_iterator {
            pub _M_node: root::std::_Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr =
            root::std::_Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: root::std::_Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_const_iterator_iterator =
            root::std::_Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self =
            root::std::_Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr =
            root::std::_Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type =
            *const root::std::_Rb_tree_node;
        #[repr(C)]
        pub struct _Rb_tree<_Compare> {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr =
            *const root::std::_Rb_tree_node_base;
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> =
            *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> =
            *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> =
            *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> =
            *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree__Link_type = *mut root::std::_Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const root::std::_Rb_tree_node;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_const_iterator>;
        #[repr(C)]
        pub struct map {
            pub _M_t: root::std::map__Rep_type,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = root::std::pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        pub type map__Alloc_value_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
        }
        pub type map__Pair_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type map__Rep_type =
            root::std::_Rb_tree<root::std::map_key_compare<_Compare>>;
        pub type map__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type map_pointer = root::std::map__Alloc_traits;
        pub type map_const_pointer = root::std::map__Alloc_traits;
        pub type map_reference = root::std::map__Alloc_traits;
        pub type map_const_reference = root::std::map__Alloc_traits;
        pub type map_iterator = root::std::map__Rep_type;
        pub type map_const_iterator = root::std::map__Rep_type;
        pub type map_size_type = root::std::map__Rep_type;
        pub type map_difference_type = root::std::map__Rep_type;
        pub type map_reverse_iterator = root::std::map__Rep_type;
        pub type map_const_reverse_iterator = root::std::map__Rep_type;
    }
    pub type __time64_t = ::std::os::raw::c_longlong;
    pub type time_t = root::__time64_t;
    pub type octave_idx_type = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct _SETJMP_FLOAT128 {
        pub Part: [::std::os::raw::c_ulonglong; 2usize],
    }
    #[test]
    fn bindgen_test_layout__SETJMP_FLOAT128() {
        assert_eq!(::std::mem::size_of::<_SETJMP_FLOAT128>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( _SETJMP_FLOAT128 )
                   ));
        assert_eq! (::std::mem::align_of::<_SETJMP_FLOAT128>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( _SETJMP_FLOAT128 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const _SETJMP_FLOAT128 ) ) . Part as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( _SETJMP_FLOAT128 )
                    , "::" , stringify ! ( Part ) ));
    }
    impl Clone for _SETJMP_FLOAT128 {
        fn clone(&self) -> Self { *self }
    }
    pub type SETJMP_FLOAT128 = root::_SETJMP_FLOAT128;
    pub type _JBTYPE = root::SETJMP_FLOAT128;
    pub type jmp_buf = [root::_JBTYPE; 16usize];
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer =
            root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *mut _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment =
            root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference =
            *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference =
            *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other =
            root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        pub struct __aligned_buffer {
            pub _M_storage: u8,
        }
    }
    pub type mbstate_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct __gthread_once_t {
        pub done: ::std::os::raw::c_int,
        pub started: ::std::os::raw::c_long,
    }
    #[test]
    fn bindgen_test_layout___gthread_once_t() {
        assert_eq!(::std::mem::size_of::<__gthread_once_t>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( __gthread_once_t ) ));
        assert_eq! (::std::mem::align_of::<__gthread_once_t>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( __gthread_once_t ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __gthread_once_t ) ) . done as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( __gthread_once_t )
                    , "::" , stringify ! ( done ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __gthread_once_t ) ) . started as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( __gthread_once_t )
                    , "::" , stringify ! ( started ) ));
    }
    impl Clone for __gthread_once_t {
        fn clone(&self) -> Self { *self }
    }
    pub type octave_jmp_buf = root::jmp_buf;
    pub mod octave {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct exit_exception {
            pub m_exit_status: ::std::os::raw::c_int,
            pub m_safe_to_return: bool,
        }
        #[test]
        fn bindgen_test_layout_exit_exception() {
            assert_eq!(::std::mem::size_of::<exit_exception>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( exit_exception )
                       ));
            assert_eq! (::std::mem::align_of::<exit_exception>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( exit_exception ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const exit_exception ) ) .
                        m_exit_status as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( exit_exception
                        ) , "::" , stringify ! ( m_exit_status ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const exit_exception ) ) .
                        m_safe_to_return as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( exit_exception
                        ) , "::" , stringify ! ( m_safe_to_return ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct interrupt_exception {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_interrupt_exception() {
            assert_eq!(::std::mem::size_of::<interrupt_exception>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( interrupt_exception ) ));
            assert_eq! (::std::mem::align_of::<interrupt_exception>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( interrupt_exception )
                        ));
        }
        impl Clone for interrupt_exception {
            fn clone(&self) -> Self { *self }
        }
        pub mod sys {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct base_tm__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct base_tm {
                pub vtable_: *const base_tm__bindgen_vtable,
                pub m_usec: ::std::os::raw::c_int,
                pub m_sec: ::std::os::raw::c_int,
                pub m_min: ::std::os::raw::c_int,
                pub m_hour: ::std::os::raw::c_int,
                pub m_mday: ::std::os::raw::c_int,
                pub m_mon: ::std::os::raw::c_int,
                pub m_year: ::std::os::raw::c_int,
                pub m_wday: ::std::os::raw::c_int,
                pub m_yday: ::std::os::raw::c_int,
                pub m_isdst: ::std::os::raw::c_int,
                pub m_gmtoff: ::std::os::raw::c_long,
                pub m_zone: root::std::string,
            }
            #[test]
            fn bindgen_test_layout_base_tm() {
                assert_eq!(::std::mem::size_of::<base_tm>() , 64usize , concat
                           ! ( "Size of: " , stringify ! ( base_tm ) ));
                assert_eq! (::std::mem::align_of::<base_tm>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( base_tm ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_usec as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_usec ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_sec as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_sec ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_min as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_min ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_hour as *
                            const _ as usize } , 20usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_hour ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_mday as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_mday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_mon as *
                            const _ as usize } , 28usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_mon ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_year as *
                            const _ as usize } , 32usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_year ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_wday as *
                            const _ as usize } , 36usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_wday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_yday as *
                            const _ as usize } , 40usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_yday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_isdst as *
                            const _ as usize } , 44usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_isdst ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_gmtoff as *
                            const _ as usize } , 48usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_gmtoff ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_zone as *
                            const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_zone ) ));
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4usecEi"]
                pub fn base_tm_usec(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3secEi"]
                pub fn base_tm_sec(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3minEi"]
                pub fn base_tm_min(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4hourEi"]
                pub fn base_tm_hour(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4mdayEi"]
                pub fn base_tm_mday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3monEi"]
                pub fn base_tm_mon(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4yearEi"]
                pub fn base_tm_year(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4wdayEi"]
                pub fn base_tm_wday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4ydayEi"]
                pub fn base_tm_yday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm5isdstEi"]
                pub fn base_tm_isdst(this: *mut root::octave::sys::base_tm,
                                     v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm6gmtoffEl"]
                pub fn base_tm_gmtoff(this: *mut root::octave::sys::base_tm,
                                      v: ::std::os::raw::c_long)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4zoneERKSs"]
                pub fn base_tm_zone(this: *mut root::octave::sys::base_tm,
                                    s: *const root::std::string)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZNK6octave3sys7base_tm8strftimeERKSs"]
                pub fn base_tm_strftime(this:
                                            *const root::octave::sys::base_tm,
                                        fmt: *const root::std::string)
                 -> root::std::string;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4initEPv"]
                pub fn base_tm_init(this: *mut root::octave::sys::base_tm,
                                    p: *mut ::std::os::raw::c_void);
            }
            impl base_tm {
                #[inline]
                pub unsafe fn usec(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_usec(self, v)
                }
                #[inline]
                pub unsafe fn sec(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_sec(self, v)
                }
                #[inline]
                pub unsafe fn min(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_min(self, v)
                }
                #[inline]
                pub unsafe fn hour(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_hour(self, v)
                }
                #[inline]
                pub unsafe fn mday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_mday(self, v)
                }
                #[inline]
                pub unsafe fn mon(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_mon(self, v)
                }
                #[inline]
                pub unsafe fn year(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_year(self, v)
                }
                #[inline]
                pub unsafe fn wday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_wday(self, v)
                }
                #[inline]
                pub unsafe fn yday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_yday(self, v)
                }
                #[inline]
                pub unsafe fn isdst(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_isdst(self, v)
                }
                #[inline]
                pub unsafe fn gmtoff(&mut self, v: ::std::os::raw::c_long)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_gmtoff(self, v)
                }
                #[inline]
                pub unsafe fn zone(&mut self, s: *const root::std::string)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_zone(self, s)
                }
                #[inline]
                pub unsafe fn strftime(&self, fmt: *const root::std::string)
                 -> root::std::string {
                    base_tm_strftime(self, fmt)
                }
                #[inline]
                pub unsafe fn init(&mut self,
                                   p: *mut ::std::os::raw::c_void) {
                    base_tm_init(self, p)
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct time {
                pub ot_unix_time: root::time_t,
                pub ot_usec: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_time() {
                assert_eq!(::std::mem::size_of::<time>() , 16usize , concat !
                           ( "Size of: " , stringify ! ( time ) ));
                assert_eq! (::std::mem::align_of::<time>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( time ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const time ) ) . ot_unix_time as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( time ) ,
                            "::" , stringify ! ( ot_unix_time ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const time ) ) . ot_usec as * const
                            _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( time ) ,
                            "::" , stringify ! ( ot_usec ) ));
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4time5stampEv"]
                pub fn time_stamp(this: *mut root::octave::sys::time);
            }
            extern "C" {
                #[link_name = "_ZNK6octave3sys4time5ctimeEv"]
                pub fn time_ctime(this: *const root::octave::sys::time)
                 -> root::std::string;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4timeC1Ed"]
                pub fn time_time(this: *mut root::octave::sys::time, d: f64);
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4timeC1ERKNS0_7base_tmE"]
                pub fn time_time1(this: *mut root::octave::sys::time,
                                  tm: *const root::octave::sys::base_tm);
            }
            impl time {
                #[inline]
                pub unsafe fn stamp(&mut self) { time_stamp(self) }
                #[inline]
                pub unsafe fn ctime(&self) -> root::std::string {
                    time_ctime(self)
                }
                #[inline]
                pub unsafe fn new(d: f64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    time_time(&mut __bindgen_tmp, d);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(tm: *const root::octave::sys::base_tm)
                 -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    time_time1(&mut __bindgen_tmp, tm);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct localtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_localtime() {
                assert_eq!(::std::mem::size_of::<localtime>() , 64usize ,
                           concat ! ( "Size of: " , stringify ! ( localtime )
                           ));
                assert_eq! (::std::mem::align_of::<localtime>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( localtime ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct gmtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_gmtime() {
                assert_eq!(::std::mem::size_of::<gmtime>() , 64usize , concat
                           ! ( "Size of: " , stringify ! ( gmtime ) ));
                assert_eq! (::std::mem::align_of::<gmtime>() , 8usize , concat
                            ! ( "Alignment of " , stringify ! ( gmtime ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct strptime {
                pub _base: root::octave::sys::base_tm,
                pub nchars: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_strptime() {
                assert_eq!(::std::mem::size_of::<strptime>() , 72usize ,
                           concat ! ( "Size of: " , stringify ! ( strptime )
                           ));
                assert_eq! (::std::mem::align_of::<strptime>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( strptime ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const strptime ) ) . nchars as *
                            const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( strptime )
                            , "::" , stringify ! ( nchars ) ));
            }
        }
        #[test]
        fn __bindgen_test_layout_map_instantiation_83990() {
            assert_eq!(::std::mem::size_of::<root::std::map>() , 48usize ,
                       concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::map ) ));
            assert_eq!(::std::mem::align_of::<root::std::map>() , 8usize ,
                       concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::map ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct dynamic_library {
            pub rep: *mut root::octave::dynamic_library_dynlib_rep,
        }
        pub type dynamic_library_name_mangler =
            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                           *const root::std::string)
                                      -> root::std::string>;
        pub type dynamic_library_close_hook =
            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                           *const root::std::string)>;
        #[repr(C)]
        pub struct dynamic_library_dynlib_rep__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct dynamic_library_dynlib_rep {
            pub vtable_: *const dynamic_library_dynlib_rep__bindgen_vtable,
            pub count: root::octave_refcount<::std::os::raw::c_int>,
            pub file: root::std::string,
            pub tm_loaded: root::octave::sys::time,
            pub fcn_names: root::std::map,
        }
        pub type dynamic_library_dynlib_rep_fcn_names_iterator = u8;
        pub type dynamic_library_dynlib_rep_fcn_names_const_iterator = u8;
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep9instancesE"]
            pub static mut dynamic_library_dynlib_rep_instances:
                       root::std::map;
        }
        #[test]
        fn bindgen_test_layout_dynamic_library_dynlib_rep() {
            assert_eq!(::std::mem::size_of::<dynamic_library_dynlib_rep>() ,
                       88usize , concat ! (
                       "Size of: " , stringify ! ( dynamic_library_dynlib_rep
                       ) ));
            assert_eq! (::std::mem::align_of::<dynamic_library_dynlib_rep>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        dynamic_library_dynlib_rep ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        count as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        count ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        file as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        file ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        tm_loaded as * const _ as usize } , 24usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        tm_loaded ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        fcn_names as * const _ as usize } , 40usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        fcn_names ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZNK6octave15dynamic_library10dynlib_rep14is_out_of_dateEv"]
            pub fn dynamic_library_dynlib_rep_is_out_of_date(this:
                                                                 *const root::octave::dynamic_library_dynlib_rep)
             -> bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12new_instanceERKSs"]
            pub fn dynamic_library_dynlib_rep_new_instance(f:
                                                               *const root::std::string)
             -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12get_instanceERKSsb"]
            pub fn dynamic_library_dynlib_rep_get_instance(f:
                                                               *const root::std::string,
                                                           fake: bool)
             -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12add_fcn_nameERKSs"]
            pub fn dynamic_library_dynlib_rep_add_fcn_name(this:
                                                               *mut root::octave::dynamic_library_dynlib_rep,
                                                           arg1:
                                                               *const root::std::string);
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep15remove_fcn_nameERKSs"]
            pub fn dynamic_library_dynlib_rep_remove_fcn_name(this:
                                                                  *mut root::octave::dynamic_library_dynlib_rep,
                                                              arg1:
                                                                  *const root::std::string)
             -> bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep13do_close_hookEPFvRKSsE"]
            pub fn dynamic_library_dynlib_rep_do_close_hook(this:
                                                                *mut root::octave::dynamic_library_dynlib_rep,
                                                            cl_hook:
                                                                root::octave::dynamic_library_close_hook);
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep11fake_reloadEv"]
            pub fn dynamic_library_dynlib_rep_fake_reload(this:
                                                              *mut root::octave::dynamic_library_dynlib_rep);
        }
        extern "C" {
            #[link_name = "_ZN6octave15dynamic_library10dynlib_repC1ERKSs"]
            pub fn dynamic_library_dynlib_rep_dynlib_rep(this:
                                                             *mut root::octave::dynamic_library_dynlib_rep,
                                                         f:
                                                             *const root::std::string);
        }
        impl dynamic_library_dynlib_rep {
            #[inline]
            pub unsafe fn is_out_of_date(&self) -> bool {
                dynamic_library_dynlib_rep_is_out_of_date(self)
            }
            #[inline]
            pub unsafe fn new_instance(f: *const root::std::string)
             -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_new_instance(f)
            }
            #[inline]
            pub unsafe fn get_instance(f: *const root::std::string,
                                       fake: bool)
             -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_get_instance(f, fake)
            }
            #[inline]
            pub unsafe fn add_fcn_name(&mut self,
                                       arg1: *const root::std::string) {
                dynamic_library_dynlib_rep_add_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn remove_fcn_name(&mut self,
                                          arg1: *const root::std::string)
             -> bool {
                dynamic_library_dynlib_rep_remove_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn do_close_hook(&mut self,
                                        cl_hook:
                                            root::octave::dynamic_library_close_hook) {
                dynamic_library_dynlib_rep_do_close_hook(self, cl_hook)
            }
            #[inline]
            pub unsafe fn fake_reload(&mut self) {
                dynamic_library_dynlib_rep_fake_reload(self)
            }
            #[inline]
            pub unsafe fn new(f: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                dynamic_library_dynlib_rep_dynlib_rep(&mut __bindgen_tmp, f);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "_ZN6octave15dynamic_library7nil_repE"]
            pub static mut dynamic_library_nil_rep:
                       root::octave::dynamic_library_dynlib_rep;
        }
        #[test]
        fn bindgen_test_layout_dynamic_library() {
            assert_eq!(::std::mem::size_of::<dynamic_library>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( dynamic_library ) ));
            assert_eq! (::std::mem::align_of::<dynamic_library>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( dynamic_library ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library ) ) . rep as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( dynamic_library
                        ) , "::" , stringify ! ( rep ) ));
        }
    }
    pub type octave_execution_exception = root::octave::exit_exception;
    pub type octave_exit_exception = root::octave::exit_exception;
    pub type octave_interrupt_exception = root::octave::interrupt_exception;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_exception {
        octave_no_exception = 0,
        octave_exec_exception = 1,
        octave_alloc_exception = 3,
        octave_quit_exception = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_refcount<T> {
        pub count: root::octave_refcount_count_type<T>,
    }
    pub type octave_refcount_count_type<T> = T;
    //! Vector representing the dimensions (size) of an Array.
/*!
  A dim_vector is used to represent dimensions of an Array.  It is used
  on its constructor to specify its size, or when reshaping it.

  @code{.cc}
  // Matrix with 10 rows and 20 columns.
  Matrix m Matrix (dim_vector (10, 20));

  // Change its size to 5 rows and 40 columns.
  Matrix m2 = m.reshape (dim_vector (5, 40));

  // Five dimensional Array of length 10, 20, 3, 8, 7 on each dimension.
  NDArray a (dim_vector (10, 20, 3, 8, 7));

  // Uninitialized array of same size as other.
  NDArray b (a.dims ());
  @endcode

  The main thing to understand about this class, is that methods such as
  ndims() and numel(), return the value for an Array of these dimensions,
  not the actual number of elements in the dim_vector.

  @code{.cc}
  dim_vector d (10, 5, 3);
  octave_idx_type n = d.numel (); // returns 150
  octave_idx_type nd = d.ndims (); // returns 3
  @endcode

  ## Implementation details ##

  This implementation is more tricky than Array, but the big plus is that
  dim_vector requires only one allocation instead of two.  It is (slightly)
  patterned after GCC's basic_string implementation.  rep is a pointer to an
  array of memory, comprising count, length, and the data:

  @verbatim
          <count>
          <ndims>
  rep --> <dims[0]>
          <dims[1]>
          ...
  @endverbatim

  The inlines count(), ndims() recover this data from the rep.  Note
  that rep points to the beginning of dims to grant faster access
  (reinterpret_cast is assumed to be an inexpensive operation).
*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct dim_vector {
        pub rep: *mut root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_dim_vector() {
        assert_eq!(::std::mem::size_of::<dim_vector>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( dim_vector ) ));
        assert_eq! (::std::mem::align_of::<dim_vector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( dim_vector ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const dim_vector ) ) . rep as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( dim_vector ) , "::"
                    , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector19chop_all_singletonsEv"]
        pub fn dim_vector_chop_all_singletons(this: *mut root::dim_vector);
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector7dim_maxEv"]
        pub fn dim_vector_dim_max() -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector3strEc"]
        pub fn dim_vector_str(this: *const root::dim_vector,
                              sep: ::std::os::raw::c_char)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector8num_onesEv"]
        pub fn dim_vector_num_ones(this: *const root::dim_vector)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        /*!
     The following function will throw a std::bad_alloc ()
     exception if the requested size is larger than can be indexed by
     octave_idx_type.  This may be smaller than the actual amount of
     memory that can be safely allocated on a system.  However, if we
     don't fail here, we can end up with a mysterious crash inside a
     function that is iterating over an array using octave_idx_type
     indices.
  */
        #[link_name = "_ZNK10dim_vector10safe_numelEv"]
        pub fn dim_vector_safe_numel(this: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector7squeezeEv"]
        pub fn dim_vector_squeeze(this: *const root::dim_vector)
         -> root::dim_vector;
    }
    extern "C" {
        //! This corresponds to cat().
        #[link_name = "_ZN10dim_vector6concatERKS_i"]
        pub fn dim_vector_concat(this: *mut root::dim_vector,
                                 dvb: *const root::dim_vector,
                                 dim: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        //! This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1).
        #[link_name = "_ZN10dim_vector5hvcatERKS_i"]
        pub fn dim_vector_hvcat(this: *mut root::dim_vector,
                                dvb: *const root::dim_vector,
                                dim: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        /*!
      Force certain dimensionality, preserving numel ().  Missing
      dimensions are set to 1, redundant are folded into the trailing
      one.  If n = 1, the result is 2d and the second dim is 1
      (dim_vectors are always at least 2D).
  */
        #[link_name = "_ZNK10dim_vector5redimEi"]
        pub fn dim_vector_redim(this: *const root::dim_vector,
                                n: ::std::os::raw::c_int) -> root::dim_vector;
    }
    impl dim_vector {
        #[inline]
        pub unsafe fn chop_all_singletons(&mut self) {
            dim_vector_chop_all_singletons(self)
        }
        #[inline]
        pub unsafe fn dim_max() -> root::octave_idx_type {
            dim_vector_dim_max()
        }
        #[inline]
        pub unsafe fn str(&self, sep: ::std::os::raw::c_char)
         -> root::std::string {
            dim_vector_str(self, sep)
        }
        #[inline]
        pub unsafe fn num_ones(&self) -> ::std::os::raw::c_int {
            dim_vector_num_ones(self)
        }
        #[inline]
        pub unsafe fn safe_numel(&self) -> root::octave_idx_type {
            dim_vector_safe_numel(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::dim_vector {
            dim_vector_squeeze(self)
        }
        #[inline]
        pub unsafe fn concat(&mut self, dvb: *const root::dim_vector,
                             dim: ::std::os::raw::c_int) -> bool {
            dim_vector_concat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn hvcat(&mut self, dvb: *const root::dim_vector,
                            dim: ::std::os::raw::c_int) -> bool {
            dim_vector_hvcat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn redim(&self, n: ::std::os::raw::c_int)
         -> root::dim_vector {
            dim_vector_redim(self, n)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int<T> {
        pub ival: T,
    }
    pub type octave_int_val_type<T> = T;
    pub type octave_int8 = root::octave_int<::std::os::raw::c_schar>;
    pub type octave_int16 = root::octave_int<::std::os::raw::c_short>;
    pub type octave_int32 = root::octave_int<::std::os::raw::c_int>;
    pub type octave_int64 = root::octave_int<::std::os::raw::c_longlong>;
    pub type octave_uint8 = root::octave_int<::std::os::raw::c_uchar>;
    pub type octave_uint16 = root::octave_int<::std::os::raw::c_ushort>;
    pub type octave_uint32 = root::octave_int<::std::os::raw::c_uint>;
    pub type octave_uint64 = root::octave_int<::std::os::raw::c_ulonglong>;
    #[repr(C)]
    pub struct Array__bindgen_vtable(::std::os::raw::c_void);
    //! N Dimensional Array with copy-on-write semantics.
/*!
    The Array class is at the root of Octave.  It provides a container
    with an arbitrary number of dimensions.  The operator () provides
    access to individual elements via subscript and linear indexing.
    Indexing starts at 0.  Arrays are column-major order as in Fortran.

    @code{.cc}
    // 3 D Array with 10 rows, 20 columns, and 5 pages, filled with 7.0
    Array<double> A Array<double (dim_vector (10, 20, 5), 7.0);

    // set value for row 0, column 10, and page 3
    A(0, 10, 3) = 2.5;

    // get value for row 1, column 2, and page 0
    double v = A(1, 2, 0);

    // get value for 25th element (row 4, column 3, page 1)
    double v = A(24);
    @endcode

    ## Notes on STL compatibility

    ### size() and length()

    To access the total number of elements in an Array, use numel()
    which is short for number of elements and is equivalent to the
    Octave function with same name.

    @code{.cc}
    Array<int> A (dim_vector (10, 20, 4), 1);

    octave_idx_type n = A.numel (); // returns 800 (10x20x4)

    octave_idx_type nr = A.size (0); // returns 10 (number of rows/dimension 0)
    octave_idx_type nc = A.size (1); // returns 20 (number of columns)
    octave_idx_type nc = A.size (2); // returns 4 (size of dimension 3)
    octave_idx_type l6 = A.size (6); // returns 1 (implicit singleton dimension)

    // Alternatively, get a dim_vector which represents the dimensions.
    dim_vector dims = A.dims ();
    @endcode

    The methods size() and length() as they exist in the STL cause
    confusion in the context of a N dimensional array.

    The size() of an array is the length of all dimensions.  In Octave,
    the size() function returns a row vector with the length of each
    dimension, or the size of a specific dimension.  Only the latter is
    present in liboctave.

    Since there is more than 1 dimension, length() would not make sense
    without expliciting which dimension.  If the function existed, which
    length should it return?  Octave length() function returns the length
    of the longest dimension which is an odd definition, only useful for
    vectors and square matrices.  The alternatives numel(), rows(),
    columns(), and size(d) are more explict and recommended.

    ### size_type

    Array::size_type is `octave_idx_type` which is a typedef for `int`
    or `long int`, depending whether Octave was configured for 64-bit
    indexing.

    This is a signed integer which may cause problems when mixed with
    STL containers.  The reason is that Octave interacts with Fortran
    routines, providing an interface many Fortran numeric libraries.

    ## Subclasses

    The following subclasses specializations, will be of most use:
      - Matrix: Array<double> with only 2 dimensions
      - ComplexMatrix: Array<std::complex<double>> with only 2 dimensions
      - boolNDArray: N dimensional Array<bool>
      - ColumnVector: Array<double> with 1 column
      - string_vector: Array<std::string> with 1 column
      - Cell: Array<octave_value>, equivalent to an Octave cell.

*/
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array<T> {
        pub vtable_: *const Array__bindgen_vtable,
        pub dimensions: root::dim_vector,
        pub rep: *mut root::Array_ArrayRep<T>,
        pub slice_data: *mut T,
        pub slice_len: root::octave_idx_type,
    }
    //! The real representation of all arrays.
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array_ArrayRep<T> {
        pub data: *mut T,
        pub len: root::octave_idx_type,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    pub type Array_element_type<T> = T;
    pub type Array_value_type<T> = T;
    //! Used for operator(), and returned by numel() and size()
  //! (beware: signed integer)
    pub type Array_size_type = root::octave_idx_type;
    pub type Array_crefT = root::ref_param;
    pub type Array_compare_fcn_type =
        ::std::option::Option<unsafe extern "C" fn(arg1: root::ref_param,
                                                   arg2: root::ref_param)
                                  -> bool>;
    #[repr(C)]
    pub struct Sparse__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse<T> {
        pub vtable_: *const Sparse__bindgen_vtable,
        pub rep: *mut root::Sparse_SparseRep<T>,
        pub dimensions: root::dim_vector,
    }
    pub type Sparse_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse_SparseRep<T> {
        pub d: *mut T,
        pub r: *mut root::octave_idx_type,
        pub c: *mut root::octave_idx_type,
        pub nzmx: root::octave_idx_type,
        pub nrows: root::octave_idx_type,
        pub ncols: root::octave_idx_type,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Range {
        pub rng_base: f64,
        pub rng_limit: f64,
        pub rng_inc: f64,
        pub rng_numel: root::octave_idx_type,
        pub cache: root::Matrix,
    }
    #[test]
    fn bindgen_test_layout_Range() {
        assert_eq!(::std::mem::size_of::<Range>() , 72usize , concat ! (
                   "Size of: " , stringify ! ( Range ) ));
        assert_eq! (::std::mem::align_of::<Range>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Range ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_base as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_limit as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_limit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_inc as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_inc ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_numel as * const _ as
                    usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_numel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . cache as * const _ as
                    usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( cache ) ));
    }
    extern "C" {
        #[link_name = "_ZNK5Range21all_elements_are_intsEv"]
        pub fn Range_all_elements_are_ints(this: *const root::Range) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK5Range12matrix_valueEv"]
        pub fn Range_matrix_value(this: *const root::Range) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK5Range3minEv"]
        pub fn Range_min(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range3maxEv"]
        pub fn Range_max(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "_ZN5Range13sort_internalEb"]
        pub fn Range_sort_internal(this: *mut root::Range, ascending: bool);
    }
    extern "C" {
        #[link_name = "_ZN5Range13sort_internalER5ArrayIiEb"]
        pub fn Range_sort_internal1(this: *mut root::Range,
                                    sidx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    ascending: bool);
    }
    extern "C" {
        #[link_name = "_ZNK5Range4diagEi"]
        pub fn Range_diag(this: *const root::Range, k: root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4sortEi8sortmode"]
        pub fn Range_sort(this: *const root::Range,
                          dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4sortER5ArrayIiEi8sortmode"]
        pub fn Range_sort1(this: *const root::Range,
                           sidx: *mut root::Array<::std::os::raw::c_int>,
                           dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK5Range9is_sortedE8sortmode"]
        pub fn Range_is_sorted(this: *const root::Range, mode: root::sortmode)
         -> root::sortmode;
    }
    extern "C" {
        #[link_name = "_ZNK5Range9checkelemEi"]
        pub fn Range_checkelem(this: *const root::Range,
                               i: root::octave_idx_type) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4elemEi"]
        pub fn Range_elem(this: *const root::Range, i: root::octave_idx_type)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range5indexERK10idx_vector"]
        pub fn Range_index(this: *const root::Range,
                           i: *const root::idx_vector) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZN5Range8set_baseEd"]
        pub fn Range_set_base(this: *mut root::Range, b: f64);
    }
    extern "C" {
        #[link_name = "_ZN5Range9set_limitEd"]
        pub fn Range_set_limit(this: *mut root::Range, l: f64);
    }
    extern "C" {
        #[link_name = "_ZN5Range7set_incEd"]
        pub fn Range_set_inc(this: *mut root::Range, i: f64);
    }
    impl Range {
        #[inline]
        pub unsafe fn all_elements_are_ints(&self) -> bool {
            Range_all_elements_are_ints(self)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            Range_matrix_value(self)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { Range_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { Range_max(self) }
        #[inline]
        pub unsafe fn sort_internal(&mut self, ascending: bool) {
            Range_sort_internal(self, ascending)
        }
        #[inline]
        pub unsafe fn sort_internal1(&mut self,
                                     sidx:
                                         *mut root::Array<::std::os::raw::c_int>,
                                     ascending: bool) {
            Range_sort_internal1(self, sidx, ascending)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Range_diag(self, k)
        }
        #[inline]
        pub unsafe fn sort(&self, dim: root::octave_idx_type,
                           mode: root::sortmode) -> root::Range {
            Range_sort(self, dim, mode)
        }
        #[inline]
        pub unsafe fn sort1(&self,
                            sidx: *mut root::Array<::std::os::raw::c_int>,
                            dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range {
            Range_sort1(self, sidx, dim, mode)
        }
        #[inline]
        pub unsafe fn is_sorted(&self, mode: root::sortmode)
         -> root::sortmode {
            Range_is_sorted(self, mode)
        }
        #[inline]
        pub unsafe fn checkelem(&self, i: root::octave_idx_type) -> f64 {
            Range_checkelem(self, i)
        }
        #[inline]
        pub unsafe fn elem(&self, i: root::octave_idx_type) -> f64 {
            Range_elem(self, i)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector)
         -> root::Array<f64> {
            Range_index(self, i)
        }
        #[inline]
        pub unsafe fn set_base(&mut self, b: f64) { Range_set_base(self, b) }
        #[inline]
        pub unsafe fn set_limit(&mut self, l: f64) {
            Range_set_limit(self, l)
        }
        #[inline]
        pub unsafe fn set_inc(&mut self, i: f64) { Range_set_inc(self, i) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector {
        pub rep: *mut root::idx_vector_idx_base_rep,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum idx_vector_idx_class_type {
        class_invalid = -1,
        class_colon = 0,
        class_range = 1,
        class_scalar = 2,
        class_vector = 3,
        class_mask = 4,
    }
    #[repr(C)]
    pub struct idx_vector_idx_base_rep__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_base_rep {
        pub vtable_: *const idx_vector_idx_base_rep__bindgen_vtable,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
        pub err: bool,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_base_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_base_rep>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_base_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_base_rep>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_base_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . count
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_base_rep ) , "::" , stringify ! ( count )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . err as
                    * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_base_rep ) , "::" , stringify ! ( err ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_colon_rep {
        pub _base: root::idx_vector_idx_base_rep,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_colon_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_colon_rep>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_colon_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_colon_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_colon_rep )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_colon_repC1Ec"]
        pub fn idx_vector_idx_colon_rep_idx_colon_rep(this:
                                                          *mut root::idx_vector_idx_colon_rep,
                                                      c:
                                                          ::std::os::raw::c_char);
    }
    impl idx_vector_idx_colon_rep {
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_colon_rep_idx_colon_rep(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum idx_vector_direct { DIRECT = 0, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_range_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub start: root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub step: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_range_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_range_rep>() , 32usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_range_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_range_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_range_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . start
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( start )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . len as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( len )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . step
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( step )
                    ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector13idx_range_rep9unconvertEv"]
        pub fn idx_vector_idx_range_rep_unconvert(this:
                                                      *const root::idx_vector_idx_range_rep)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_range_repC1Eiii"]
        pub fn idx_vector_idx_range_rep_idx_range_rep(this:
                                                          *mut root::idx_vector_idx_range_rep,
                                                      _start:
                                                          root::octave_idx_type,
                                                      _limit:
                                                          root::octave_idx_type,
                                                      _step:
                                                          root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_range_repC1ERK5Range"]
        pub fn idx_vector_idx_range_rep_idx_range_rep1(this:
                                                           *mut root::idx_vector_idx_range_rep,
                                                       arg1:
                                                           *const root::Range);
    }
    impl idx_vector_idx_range_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Range {
            idx_vector_idx_range_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(_start: root::octave_idx_type,
                          _limit: root::octave_idx_type,
                          _step: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep(&mut __bindgen_tmp, _start,
                                                   _limit, _step);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Range) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_scalar_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_scalar_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_scalar_rep>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_scalar_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_scalar_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_scalar_rep
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_scalar_rep ) ) . data
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_scalar_rep ) , "::" , stringify ! ( data )
                    ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14idx_scalar_rep9unconvertEv"]
        pub fn idx_vector_idx_scalar_rep_unconvert(this:
                                                       *const root::idx_vector_idx_scalar_rep)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_scalar_repC1Ei"]
        pub fn idx_vector_idx_scalar_rep_idx_scalar_rep(this:
                                                            *mut root::idx_vector_idx_scalar_rep,
                                                        i:
                                                            root::octave_idx_type);
    }
    impl idx_vector_idx_scalar_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> f64 {
            idx_vector_idx_scalar_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(i: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_scalar_rep_idx_scalar_rep(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_vector_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub aowner: *mut root::Array<::std::os::raw::c_int>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_vector_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_vector_rep>() ,
                   48usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_vector_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_vector_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_vector_rep
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . data
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( data )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . len
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( len )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . ext
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( ext )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) .
                    aowner as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( aowner
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) .
                    orig_dims as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! (
                    orig_dims ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14idx_vector_rep9unconvertEv"]
        pub fn idx_vector_idx_vector_rep_unconvert(this:
                                                       *const root::idx_vector_idx_vector_rep)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIiE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep(this:
                                                            *mut root::idx_vector_idx_vector_rep,
                                                        inda:
                                                            *const root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name =
              "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIiEiNS_6directE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep1(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         inda:
                                                             *const root::Array<::std::os::raw::c_int>,
                                                         _ext:
                                                             root::octave_idx_type,
                                                         arg1:
                                                             root::idx_vector_direct);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1Eb"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep2(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIbEi"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep3(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1:
                                                             *const root::Array<bool>,
                                                         arg2:
                                                             root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK6SparseIbE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep4(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1:
                                                             *const root::Sparse<bool>);
    }
    impl idx_vector_idx_vector_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<f64> {
            idx_vector_idx_vector_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(inda: *const root::Array<::std::os::raw::c_int>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep(&mut __bindgen_tmp,
                                                     inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(inda: *const root::Array<::std::os::raw::c_int>,
                           _ext: root::octave_idx_type,
                           arg1: root::idx_vector_direct) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep1(&mut __bindgen_tmp,
                                                      inda, _ext, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep2(&mut __bindgen_tmp,
                                                      arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(arg1: *const root::Array<bool>,
                           arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep3(&mut __bindgen_tmp,
                                                      arg1, arg2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(arg1: *const root::Sparse<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep4(&mut __bindgen_tmp,
                                                      arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_mask_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const bool,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub lsti: root::octave_idx_type,
        pub lste: root::octave_idx_type,
        pub aowner: *mut root::Array<bool>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_mask_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_mask_rep>() , 56usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_mask_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_mask_rep>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_mask_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . data as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( data )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . len as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( len ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . ext as
                    * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( ext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lsti as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( lsti )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lste as
                    * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( lste )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . aowner
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( aowner )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) .
                    orig_dims as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( orig_dims
                    ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector12idx_mask_rep9unconvertEv"]
        pub fn idx_vector_idx_mask_rep_unconvert(this:
                                                     *const root::idx_vector_idx_mask_rep)
         -> root::Array<bool>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12idx_mask_repC1Eb"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep(this:
                                                        *mut root::idx_vector_idx_mask_rep,
                                                    arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12idx_mask_repC1ERK5ArrayIbEi"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep1(this:
                                                         *mut root::idx_vector_idx_mask_rep,
                                                     arg1:
                                                         *const root::Array<bool>,
                                                     arg2:
                                                         root::octave_idx_type);
    }
    impl idx_vector_idx_mask_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<bool> {
            idx_vector_idx_mask_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Array<bool>,
                           arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep1(&mut __bindgen_tmp, arg1,
                                                  arg2);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector5colonE"]
        pub static idx_vector_colon: root::idx_vector;
    }
    #[test]
    fn bindgen_test_layout_idx_vector() {
        assert_eq!(::std::mem::size_of::<idx_vector>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector ) ));
        assert_eq! (::std::mem::align_of::<idx_vector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector ) ) . rep as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( idx_vector ) , "::"
                    , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12maybe_reduceEiRKS_i"]
        pub fn idx_vector_maybe_reduce(this: *mut root::idx_vector,
                                       n: root::octave_idx_type,
                                       j: *const root::idx_vector,
                                       nj: root::octave_idx_type) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector13is_cont_rangeEiRiS0_"]
        pub fn idx_vector_is_cont_range(this: *const root::idx_vector,
                                        n: root::octave_idx_type,
                                        l: *mut root::octave_idx_type,
                                        u: *mut root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9incrementEv"]
        pub fn idx_vector_increment(this: *const root::idx_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector10complementEi"]
        pub fn idx_vector_complement(this: *const root::idx_vector,
                                     n: root::octave_idx_type)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14is_permutationEi"]
        pub fn idx_vector_is_permutation(this: *const root::idx_vector,
                                         n: root::octave_idx_type) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector19inverse_permutationEi"]
        pub fn idx_vector_inverse_permutation(this: *const root::idx_vector,
                                              n: root::octave_idx_type)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9copy_dataEPi"]
        pub fn idx_vector_copy_data(this: *const root::idx_vector,
                                    data: *mut root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector6unmaskEv"]
        pub fn idx_vector_unmask(this: *const root::idx_vector)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name =
              "_ZNK10idx_vector9unconvertERNS_14idx_class_typeERdR5RangeR5ArrayIdERS5_IbE"]
        pub fn idx_vector_unconvert(this: *const root::idx_vector,
                                    iclass:
                                        *mut root::idx_vector_idx_class_type,
                                    scalar: *mut f64, range: *mut root::Range,
                                    array: *mut root::Array<f64>,
                                    mask: *mut root::Array<bool>);
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector8as_arrayEv"]
        pub fn idx_vector_as_array(this: *const root::idx_vector)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector3rawEv"]
        pub fn idx_vector_raw(this: *mut root::idx_vector)
         -> *const root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9is_vectorEv"]
        pub fn idx_vector_is_vector(this: *const root::idx_vector) -> bool;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector6freezeEiPKcb"]
        pub fn idx_vector_freeze(this: *mut root::idx_vector,
                                 z_len: root::octave_idx_type,
                                 tag: *const ::std::os::raw::c_char,
                                 resize_ok: bool) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector10ones_countEv"]
        pub fn idx_vector_ones_count(this: *const root::idx_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vectorC1ERK5ArrayIbE"]
        pub fn idx_vector_idx_vector(this: *mut root::idx_vector,
                                     nda: *const root::Array<bool>);
    }
    impl idx_vector {
        #[inline]
        pub unsafe fn maybe_reduce(&mut self, n: root::octave_idx_type,
                                   j: *const root::idx_vector,
                                   nj: root::octave_idx_type) -> bool {
            idx_vector_maybe_reduce(self, n, j, nj)
        }
        #[inline]
        pub unsafe fn is_cont_range(&self, n: root::octave_idx_type,
                                    l: *mut root::octave_idx_type,
                                    u: *mut root::octave_idx_type) -> bool {
            idx_vector_is_cont_range(self, n, l, u)
        }
        #[inline]
        pub unsafe fn increment(&self) -> root::octave_idx_type {
            idx_vector_increment(self)
        }
        #[inline]
        pub unsafe fn complement(&self, n: root::octave_idx_type)
         -> root::idx_vector {
            idx_vector_complement(self, n)
        }
        #[inline]
        pub unsafe fn is_permutation(&self, n: root::octave_idx_type)
         -> bool {
            idx_vector_is_permutation(self, n)
        }
        #[inline]
        pub unsafe fn inverse_permutation(&self, n: root::octave_idx_type)
         -> root::idx_vector {
            idx_vector_inverse_permutation(self, n)
        }
        #[inline]
        pub unsafe fn copy_data(&self, data: *mut root::octave_idx_type) {
            idx_vector_copy_data(self, data)
        }
        #[inline]
        pub unsafe fn unmask(&self) -> root::idx_vector {
            idx_vector_unmask(self)
        }
        #[inline]
        pub unsafe fn unconvert(&self,
                                iclass: *mut root::idx_vector_idx_class_type,
                                scalar: *mut f64, range: *mut root::Range,
                                array: *mut root::Array<f64>,
                                mask: *mut root::Array<bool>) {
            idx_vector_unconvert(self, iclass, scalar, range, array, mask)
        }
        #[inline]
        pub unsafe fn as_array(&self) -> root::Array<::std::os::raw::c_int> {
            idx_vector_as_array(self)
        }
        #[inline]
        pub unsafe fn raw(&mut self) -> *const root::octave_idx_type {
            idx_vector_raw(self)
        }
        #[inline]
        pub unsafe fn is_vector(&self) -> bool { idx_vector_is_vector(self) }
        #[inline]
        pub unsafe fn freeze(&mut self, z_len: root::octave_idx_type,
                             tag: *const ::std::os::raw::c_char,
                             resize_ok: bool) -> root::octave_idx_type {
            idx_vector_freeze(self, z_len, tag, resize_ok)
        }
        #[inline]
        pub unsafe fn ones_count(&self) -> root::octave_idx_type {
            idx_vector_ones_count(self)
        }
        #[inline]
        pub unsafe fn new(nda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ref_param {
        pub _address: u8,
    }
    pub type ref_param_type = u8;
    pub type Complex = root::std::complex<f64>;
    pub type FloatComplex = root::std::complex<f32>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum sortmode { UNSORTED = 0, ASCENDING = 1, DESCENDING = 2, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_sort<T> {
        pub compare: root::octave_sort_compare_fcn_type,
        pub ms: *mut root::octave_sort_MergeState<T>,
    }
    pub type octave_sort_compare_fcn_type =
        ::std::option::Option<unsafe extern "C" fn(arg1: root::ref_param,
                                                   arg2: root::ref_param)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_sort_s_slice {
        pub base: root::octave_idx_type,
        pub len: root::octave_idx_type,
    }
    #[repr(C)]
    pub struct octave_sort_MergeState<T> {
        pub min_gallop: root::octave_idx_type,
        pub a: *mut T,
        pub ia: *mut root::octave_idx_type,
        pub alloced: root::octave_idx_type,
        pub n: root::octave_idx_type,
        pub pending: [root::octave_sort_s_slice; 85usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PermMatrix {
        pub _base: root::Array<::std::os::raw::c_int>,
    }
    #[test]
    fn bindgen_test_layout_PermMatrix() {
        assert_eq!(::std::mem::size_of::<PermMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( PermMatrix ) ));
        assert_eq! (::std::mem::align_of::<PermMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( PermMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix9checkelemEii"]
        pub fn PermMatrix_checkelem(this: *const root::PermMatrix,
                                    i: root::octave_idx_type,
                                    j: root::octave_idx_type)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix9transposeEv"]
        pub fn PermMatrix_transpose(this: *const root::PermMatrix)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix7inverseEv"]
        pub fn PermMatrix_inverse(this: *const root::PermMatrix)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix11determinantEv"]
        pub fn PermMatrix_determinant(this: *const root::PermMatrix)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix5powerEi"]
        pub fn PermMatrix_power(this: *const root::PermMatrix,
                                n: root::octave_idx_type) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrix3eyeEi"]
        pub fn PermMatrix_eye(n: root::octave_idx_type) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1Ei"]
        pub fn PermMatrix_PermMatrix(this: *mut root::PermMatrix,
                                     n: root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK5ArrayIiE"]
        pub fn PermMatrix_PermMatrix1(this: *mut root::PermMatrix,
                                      p:
                                          *const root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK5ArrayIiEbb"]
        pub fn PermMatrix_PermMatrix2(this: *mut root::PermMatrix,
                                      p:
                                          *const root::Array<::std::os::raw::c_int>,
                                      colp: bool, check: bool);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK10idx_vector"]
        pub fn PermMatrix_PermMatrix3(this: *mut root::PermMatrix,
                                      idx: *const root::idx_vector);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK10idx_vectorbi"]
        pub fn PermMatrix_PermMatrix4(this: *mut root::PermMatrix,
                                      idx: *const root::idx_vector,
                                      colp: bool, n: root::octave_idx_type);
    }
    impl PermMatrix {
        #[inline]
        pub unsafe fn checkelem(&self, i: root::octave_idx_type,
                                j: root::octave_idx_type)
         -> root::octave_idx_type {
            PermMatrix_checkelem(self, i, j)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::PermMatrix {
            PermMatrix_transpose(self)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::PermMatrix {
            PermMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::octave_idx_type {
            PermMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn power(&self, n: root::octave_idx_type)
         -> root::PermMatrix {
            PermMatrix_power(self, n)
        }
        #[inline]
        pub unsafe fn eye(n: root::octave_idx_type) -> root::PermMatrix {
            PermMatrix_eye(n)
        }
        #[inline]
        pub unsafe fn new(n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix(&mut __bindgen_tmp, n);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(p: *const root::Array<::std::os::raw::c_int>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix1(&mut __bindgen_tmp, p);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(p: *const root::Array<::std::os::raw::c_int>,
                           colp: bool, check: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix2(&mut __bindgen_tmp, p, colp, check);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(idx: *const root::idx_vector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix3(&mut __bindgen_tmp, idx);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(idx: *const root::idx_vector, colp: bool,
                           n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix4(&mut __bindgen_tmp, idx, colp, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_local_buffer<T> {
        pub data: *mut T,
    }
    #[repr(C)]
    pub struct octave_chunk_buffer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_chunk_buffer {
        pub vtable_: *const octave_chunk_buffer__bindgen_vtable,
        pub cnk: *mut ::std::os::raw::c_char,
        pub dat: *mut ::std::os::raw::c_char,
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer10chunk_sizeE"]
        pub static octave_chunk_buffer_chunk_size: usize;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer3topE"]
        pub static mut octave_chunk_buffer_top: *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer5chunkE"]
        pub static mut octave_chunk_buffer_chunk: *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer4leftE"]
        pub static mut octave_chunk_buffer_left: usize;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer6activeE"]
        pub static mut octave_chunk_buffer_active: usize;
    }
    #[test]
    fn bindgen_test_layout_octave_chunk_buffer() {
        assert_eq!(::std::mem::size_of::<octave_chunk_buffer>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_chunk_buffer ) ));
        assert_eq! (::std::mem::align_of::<octave_chunk_buffer>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_chunk_buffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_chunk_buffer ) ) . cnk as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_chunk_buffer
                    ) , "::" , stringify ! ( cnk ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_chunk_buffer ) ) . dat as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_chunk_buffer
                    ) , "::" , stringify ! ( dat ) ));
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer5clearEv"]
        pub fn octave_chunk_buffer_clear();
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_bufferC1Ey"]
        pub fn octave_chunk_buffer_octave_chunk_buffer(this:
                                                           *mut root::octave_chunk_buffer,
                                                       size: usize);
    }
    impl octave_chunk_buffer {
        #[inline]
        pub unsafe fn clear() { octave_chunk_buffer_clear() }
        #[inline]
        pub unsafe fn new(size: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_chunk_buffer_octave_chunk_buffer(&mut __bindgen_tmp, size);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35406() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<bool>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<bool>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35410() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35414() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_ushort>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ushort> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_ushort>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ushort> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35418() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_short>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_short> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_short>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_short> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35422() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_int>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35426() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_uint>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35430() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_long>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_long> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_long>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_long> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35434() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_ulong>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ulong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_ulong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ulong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35438() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<f32>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<f32>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35442() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<f64>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<f64>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35446() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35449() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<root::std::complex<f32>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f32>> ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_prom {
        pub _address: u8,
    }
    pub type octave_int_cmp_op_prom_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_lt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_lt_ltval: bool = true;
    pub const octave_int_cmp_op_lt_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_lt() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_lt>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_lt ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_lt>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_lt ) ));
    }
    impl Clone for octave_int_cmp_op_lt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_le {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_le_ltval: bool = true;
    pub const octave_int_cmp_op_le_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_le() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_le>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_le ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_le>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_le ) ));
    }
    impl Clone for octave_int_cmp_op_le {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_gt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_gt_ltval: bool = false;
    pub const octave_int_cmp_op_gt_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_gt() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_gt>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_gt ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_gt>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_gt ) ));
    }
    impl Clone for octave_int_cmp_op_gt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ge {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ge_ltval: bool = false;
    pub const octave_int_cmp_op_ge_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ge() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ge>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ge ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ge>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ge ) ));
    }
    impl Clone for octave_int_cmp_op_ge {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_eq {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_eq_ltval: bool = false;
    pub const octave_int_cmp_op_eq_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_eq() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_eq>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_eq ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_eq>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_eq ) ));
    }
    impl Clone for octave_int_cmp_op_eq {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ne {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ne_ltval: bool = true;
    pub const octave_int_cmp_op_ne_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ne() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ne>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ne ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ne>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ne ) ));
    }
    impl Clone for octave_int_cmp_op_ne {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ct {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ct_ltval: bool = true;
    pub const octave_int_cmp_op_ct_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ct() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ct>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ct ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ct>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ct ) ));
    }
    impl Clone for octave_int_cmp_op_ct {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_cf {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_cf_ltval: bool = false;
    pub const octave_int_cmp_op_cf_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_cf() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_cf>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_cf ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_cf>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_cf ) ));
    }
    impl Clone for octave_int_cmp_op_cf {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op>() , 1usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_int_cmp_op )
                   ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op ) ));
    }
    impl Clone for octave_int_cmp_op {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_base {
        pub _address: u8,
    }
    #[repr(C)]
    pub struct octave_int_arith {
        pub _address: u8,
    }
    //! Template for N-dimensional array classes with like-type math operators.
    #[repr(C)]
    #[derive(Debug)]
    pub struct MArray<T> {
        pub _base: root::Array<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MSparse<T> {
        pub _base: root::Sparse<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Matrix {
        pub _base: root::NDArray,
    }
    pub type Matrix_column_vector_type = root::ColumnVector;
    pub type Matrix_row_vector_type = root::RowVector;
    pub type Matrix_real_column_vector_type = root::ColumnVector;
    pub type Matrix_real_row_vector_type = root::RowVector;
    pub type Matrix_real_matrix_type = root::Matrix;
    pub type Matrix_complex_matrix_type = root::ComplexMatrix;
    pub type Matrix_real_diag_matrix_type = root::DiagMatrix;
    pub type Matrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type Matrix_real_elt_type = f64;
    pub type Matrix_complex_elt_type = root::Complex;
    pub type Matrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_Matrix() {
        assert_eq!(::std::mem::size_of::<Matrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( Matrix ) ));
        assert_eq! (::std::mem::align_of::<Matrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Matrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix12is_symmetricEv"]
        pub fn Matrix_is_symmetric(this: *const root::Matrix) -> bool;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERKS_ii"]
        pub fn Matrix_insert(this: *mut root::Matrix, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK9RowVectorii"]
        pub fn Matrix_insert1(this: *mut root::Matrix,
                              a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK12ColumnVectorii"]
        pub fn Matrix_insert2(this: *mut root::Matrix,
                              a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK10DiagMatrixii"]
        pub fn Matrix_insert3(this: *mut root::Matrix,
                              a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix4fillEd"]
        pub fn Matrix_fill(this: *mut root::Matrix, val: f64)
         -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix4fillEdiiii"]
        pub fn Matrix_fill1(this: *mut root::Matrix, val: f64,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERKS_"]
        pub fn Matrix_append(this: *const root::Matrix,
                             a: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK9RowVector"]
        pub fn Matrix_append1(this: *const root::Matrix,
                              a: *const root::RowVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK12ColumnVector"]
        pub fn Matrix_append2(this: *const root::Matrix,
                              a: *const root::ColumnVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK10DiagMatrix"]
        pub fn Matrix_append3(this: *const root::Matrix,
                              a: *const root::DiagMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERKS_"]
        pub fn Matrix_stack(this: *const root::Matrix, a: *const root::Matrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK9RowVector"]
        pub fn Matrix_stack1(this: *const root::Matrix,
                             a: *const root::RowVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK12ColumnVector"]
        pub fn Matrix_stack2(this: *const root::Matrix,
                             a: *const root::ColumnVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK10DiagMatrix"]
        pub fn Matrix_stack3(this: *const root::Matrix,
                             a: *const root::DiagMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7extractEiiii"]
        pub fn Matrix_extract(this: *const root::Matrix,
                              r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix9extract_nEiiii"]
        pub fn Matrix_extract_n(this: *const root::Matrix,
                                r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3rowEi"]
        pub fn Matrix_row(this: *const root::Matrix, i: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6columnEi"]
        pub fn Matrix_column(this: *const root::Matrix,
                             i: root::octave_idx_type) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseEv"]
        pub fn Matrix_inverse(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseERi"]
        pub fn Matrix_inverse1(this: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseERiRdbb"]
        pub fn Matrix_inverse2(this: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixType"]
        pub fn Matrix_inverse3(this: *const root::Matrix,
                               mattype: *mut root::MatrixType)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixTypeRi"]
        pub fn Matrix_inverse4(this: *const root::Matrix,
                               mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixTypeRiRdbb"]
        pub fn Matrix_inverse5(this: *const root::Matrix,
                               mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix14pseudo_inverseEd"]
        pub fn Matrix_pseudo_inverse(this: *const root::Matrix, tol: f64)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7fourierEv"]
        pub fn Matrix_fourier(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix8ifourierEv"]
        pub fn Matrix_ifourier(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix9fourier2dEv"]
        pub fn Matrix_fourier2d(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10ifourier2dEv"]
        pub fn Matrix_ifourier2d(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantEv"]
        pub fn Matrix_determinant(this: *const root::Matrix) -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantERi"]
        pub fn Matrix_determinant1(this: *const root::Matrix,
                                   info: *mut root::octave_idx_type)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantERiRdb"]
        pub fn Matrix_determinant2(this: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantER10MatrixTypeRiRdb"]
        pub fn Matrix_determinant3(this: *const root::Matrix,
                                   mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5rcondEv"]
        pub fn Matrix_rcond(this: *const root::Matrix) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5rcondER10MatrixType"]
        pub fn Matrix_rcond1(this: *const root::Matrix,
                             mattype: *mut root::MatrixType) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_"]
        pub fn Matrix_solve(this: *const root::Matrix,
                            typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_Ri"]
        pub fn Matrix_solve1(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn Matrix_solve2(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRKS_RiRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve3(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn Matrix_solve4(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn Matrix_solve5(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn Matrix_solve6(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve7(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn Matrix_solve8(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn Matrix_solve9(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn Matrix_solve10(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve11(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn Matrix_solve12(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn Matrix_solve13(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn Matrix_solve14(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve15(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_"]
        pub fn Matrix_solve16(this: *const root::Matrix,
                              b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_Ri"]
        pub fn Matrix_solve17(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_RiRd"]
        pub fn Matrix_solve18(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_RiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve19(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrix"]
        pub fn Matrix_solve20(this: *const root::Matrix,
                              b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrixRi"]
        pub fn Matrix_solve21(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrixRiRd"]
        pub fn Matrix_solve22(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK13ComplexMatrixRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve23(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVector"]
        pub fn Matrix_solve24(this: *const root::Matrix,
                              b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVectorRi"]
        pub fn Matrix_solve25(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVectorRiRd"]
        pub fn Matrix_solve26(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve27(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVector"]
        pub fn Matrix_solve28(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVectorRi"]
        pub fn Matrix_solve29(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn Matrix_solve30(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve31(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_"]
        pub fn Matrix_lssolve(this: *const root::Matrix,
                              b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_Ri"]
        pub fn Matrix_lssolve1(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_RiS2_"]
        pub fn Matrix_lssolve2(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_RiS2_Rd"]
        pub fn Matrix_lssolve3(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrix"]
        pub fn Matrix_lssolve4(this: *const root::Matrix,
                               b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRi"]
        pub fn Matrix_lssolve5(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRiS3_"]
        pub fn Matrix_lssolve6(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRiS3_Rd"]
        pub fn Matrix_lssolve7(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVector"]
        pub fn Matrix_lssolve8(this: *const root::Matrix,
                               b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRi"]
        pub fn Matrix_lssolve9(this: *const root::Matrix,
                               b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRiS3_"]
        pub fn Matrix_lssolve10(this: *const root::Matrix,
                                b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRiS3_Rd"]
        pub fn Matrix_lssolve11(this: *const root::Matrix,
                                b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVector"]
        pub fn Matrix_lssolve12(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRi"]
        pub fn Matrix_lssolve13(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRiS3_"]
        pub fn Matrix_lssolve14(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRiS3_Rd"]
        pub fn Matrix_lssolve15(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3allEi"]
        pub fn Matrix_all(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3anyEi"]
        pub fn Matrix_any(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7cumprodEi"]
        pub fn Matrix_cumprod(this: *const root::Matrix,
                              dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6cumsumEi"]
        pub fn Matrix_cumsum(this: *const root::Matrix,
                             dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4prodEi"]
        pub fn Matrix_prod(this: *const root::Matrix,
                           dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3sumEi"]
        pub fn Matrix_sum(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5sumsqEi"]
        pub fn Matrix_sumsq(this: *const root::Matrix,
                            dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3absEv"]
        pub fn Matrix_abs(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4diagEi"]
        pub fn Matrix_diag(this: *const root::Matrix,
                           k: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4diagEii"]
        pub fn Matrix_diag1(this: *const root::Matrix,
                            m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_minEv"]
        pub fn Matrix_row_min(this: *const root::Matrix)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_maxEv"]
        pub fn Matrix_row_max(this: *const root::Matrix)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_minER5ArrayIiE"]
        pub fn Matrix_row_min1(this: *const root::Matrix,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_maxER5ArrayIiE"]
        pub fn Matrix_row_max1(this: *const root::Matrix,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_minEv"]
        pub fn Matrix_column_min(this: *const root::Matrix)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_maxEv"]
        pub fn Matrix_column_max(this: *const root::Matrix)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_minER5ArrayIiE"]
        pub fn Matrix_column_min1(this: *const root::Matrix,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_maxER5ArrayIiE"]
        pub fn Matrix_column_max1(this: *const root::Matrix,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK9RowVector"]
        pub fn Matrix_Matrix(this: *mut root::Matrix,
                             rv: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK12ColumnVector"]
        pub fn Matrix_Matrix1(this: *mut root::Matrix,
                              cv: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10DiagMatrix"]
        pub fn Matrix_Matrix2(this: *mut root::Matrix,
                              a: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK11MDiagArray2IdE"]
        pub fn Matrix_Matrix3(this: *mut root::Matrix,
                              a: *const root::MDiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10DiagArray2IdE"]
        pub fn Matrix_Matrix4(this: *mut root::Matrix,
                              a: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10PermMatrix"]
        pub fn Matrix_Matrix5(this: *mut root::Matrix,
                              a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10boolMatrix"]
        pub fn Matrix_Matrix6(this: *mut root::Matrix,
                              a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10charMatrix"]
        pub fn Matrix_Matrix7(this: *mut root::Matrix,
                              a: *const root::charMatrix);
    }
    impl Matrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            Matrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::Matrix {
            Matrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector)
         -> root::Matrix {
            Matrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector)
         -> root::Matrix {
            Matrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix)
         -> root::Matrix {
            Matrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector)
         -> root::Matrix {
            Matrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector)
         -> root::Matrix {
            Matrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix)
         -> root::Matrix {
            Matrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix {
            Matrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type) -> root::Matrix {
            Matrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            Matrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::Matrix { Matrix_inverse(self) }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix {
            Matrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::Matrix {
            Matrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix {
            Matrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::Matrix {
            Matrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            Matrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            Matrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            Matrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            Matrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            Matrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::DET {
            Matrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET {
            Matrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET {
            Matrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { Matrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            Matrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix {
            Matrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::Matrix {
            Matrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type) -> root::Matrix {
            Matrix_solve3(self, typ, b, info, rcon, sing_handler,
                          singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            Matrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            Matrix_solve7(self, typ, b, info, rcon, sing_handler,
                          singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector {
            Matrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector {
            Matrix_solve11(self, typ, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            Matrix_solve15(self, typ, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::Matrix {
            Matrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type) -> root::Matrix {
            Matrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            Matrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            Matrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector {
            Matrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector {
            Matrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            Matrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::Matrix {
            Matrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            Matrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ColumnVector {
            Matrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            Matrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            Matrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix { Matrix_abs(self) }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Matrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::DiagMatrix {
            Matrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ColumnVector {
            Matrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ColumnVector {
            Matrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector {
            Matrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector {
            Matrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::RowVector {
            Matrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::RowVector {
            Matrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector {
            Matrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector {
            Matrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexMatrix {
        pub _base: root::ComplexNDArray,
    }
    pub type ComplexMatrix_column_vector_type = root::ComplexColumnVector;
    pub type ComplexMatrix_row_vector_type = root::ComplexRowVector;
    pub type ComplexMatrix_real_column_vector_type = root::ColumnVector;
    pub type ComplexMatrix_real_row_vector_type = root::RowVector;
    pub type ComplexMatrix_real_matrix_type = root::Matrix;
    pub type ComplexMatrix_complex_matrix_type = root::ComplexMatrix;
    pub type ComplexMatrix_real_diag_matrix_type = root::DiagMatrix;
    pub type ComplexMatrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type ComplexMatrix_real_elt_type = f64;
    pub type ComplexMatrix_complex_elt_type = root::Complex;
    pub type ComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_ComplexMatrix() {
        assert_eq!(::std::mem::size_of::<ComplexMatrix>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( ComplexMatrix ) ));
        assert_eq! (::std::mem::align_of::<ComplexMatrix>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( ComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix12is_hermitianEv"]
        pub fn ComplexMatrix_is_hermitian(this: *const root::ComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK6Matrixii"]
        pub fn ComplexMatrix_insert(this: *mut root::ComplexMatrix,
                                    a: *const root::Matrix,
                                    r: root::octave_idx_type,
                                    c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK9RowVectorii"]
        pub fn ComplexMatrix_insert1(this: *mut root::ComplexMatrix,
                                     a: *const root::RowVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK12ColumnVectorii"]
        pub fn ComplexMatrix_insert2(this: *mut root::ComplexMatrix,
                                     a: *const root::ColumnVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK10DiagMatrixii"]
        pub fn ComplexMatrix_insert3(this: *mut root::ComplexMatrix,
                                     a: *const root::DiagMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERKS_ii"]
        pub fn ComplexMatrix_insert4(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK16ComplexRowVectorii"]
        pub fn ComplexMatrix_insert5(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexRowVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK19ComplexColumnVectorii"]
        pub fn ComplexMatrix_insert6(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexColumnVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK17ComplexDiagMatrixii"]
        pub fn ComplexMatrix_insert7(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexDiagMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillEd"]
        pub fn ComplexMatrix_fill(this: *mut root::ComplexMatrix, val: f64)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillERKSt7complexIdE"]
        pub fn ComplexMatrix_fill1(this: *mut root::ComplexMatrix,
                                   val: *const root::Complex)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillEdiiii"]
        pub fn ComplexMatrix_fill2(this: *mut root::ComplexMatrix, val: f64,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillERKSt7complexIdEiiii"]
        pub fn ComplexMatrix_fill3(this: *mut root::ComplexMatrix,
                                   val: *const root::Complex,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK6Matrix"]
        pub fn ComplexMatrix_append(this: *const root::ComplexMatrix,
                                    a: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK9RowVector"]
        pub fn ComplexMatrix_append1(this: *const root::ComplexMatrix,
                                     a: *const root::RowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK12ColumnVector"]
        pub fn ComplexMatrix_append2(this: *const root::ComplexMatrix,
                                     a: *const root::ColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK10DiagMatrix"]
        pub fn ComplexMatrix_append3(this: *const root::ComplexMatrix,
                                     a: *const root::DiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERKS_"]
        pub fn ComplexMatrix_append4(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK16ComplexRowVector"]
        pub fn ComplexMatrix_append5(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexRowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK19ComplexColumnVector"]
        pub fn ComplexMatrix_append6(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_append7(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK6Matrix"]
        pub fn ComplexMatrix_stack(this: *const root::ComplexMatrix,
                                   a: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK9RowVector"]
        pub fn ComplexMatrix_stack1(this: *const root::ComplexMatrix,
                                    a: *const root::RowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK12ColumnVector"]
        pub fn ComplexMatrix_stack2(this: *const root::ComplexMatrix,
                                    a: *const root::ColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK10DiagMatrix"]
        pub fn ComplexMatrix_stack3(this: *const root::ComplexMatrix,
                                    a: *const root::DiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERKS_"]
        pub fn ComplexMatrix_stack4(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK16ComplexRowVector"]
        pub fn ComplexMatrix_stack5(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexRowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK19ComplexColumnVector"]
        pub fn ComplexMatrix_stack6(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_stack7(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7extractEiiii"]
        pub fn ComplexMatrix_extract(this: *const root::ComplexMatrix,
                                     r1: root::octave_idx_type,
                                     c1: root::octave_idx_type,
                                     r2: root::octave_idx_type,
                                     c2: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix9extract_nEiiii"]
        pub fn ComplexMatrix_extract_n(this: *const root::ComplexMatrix,
                                       r1: root::octave_idx_type,
                                       c1: root::octave_idx_type,
                                       nr: root::octave_idx_type,
                                       nc: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3rowEi"]
        pub fn ComplexMatrix_row(this: *const root::ComplexMatrix,
                                 i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6columnEi"]
        pub fn ComplexMatrix_column(this: *const root::ComplexMatrix,
                                    i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseEv"]
        pub fn ComplexMatrix_inverse(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseERi"]
        pub fn ComplexMatrix_inverse1(this: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseERiRdbb"]
        pub fn ComplexMatrix_inverse2(this: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rcon: *mut f64, force: bool,
                                      calc_cond: bool) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixType"]
        pub fn ComplexMatrix_inverse3(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn ComplexMatrix_inverse4(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn ComplexMatrix_inverse5(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType,
                                      info: *mut root::octave_idx_type,
                                      rcon: *mut f64, force: bool,
                                      calc_cond: bool) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix14pseudo_inverseEd"]
        pub fn ComplexMatrix_pseudo_inverse(this: *const root::ComplexMatrix,
                                            tol: f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7fourierEv"]
        pub fn ComplexMatrix_fourier(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix8ifourierEv"]
        pub fn ComplexMatrix_ifourier(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix9fourier2dEv"]
        pub fn ComplexMatrix_fourier2d(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10ifourier2dEv"]
        pub fn ComplexMatrix_ifourier2d(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantEv"]
        pub fn ComplexMatrix_determinant(this: *const root::ComplexMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantERi"]
        pub fn ComplexMatrix_determinant1(this: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantERiRdb"]
        pub fn ComplexMatrix_determinant2(this: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantER10MatrixTypeRiRdb"]
        pub fn ComplexMatrix_determinant3(this: *const root::ComplexMatrix,
                                          mattype: *mut root::MatrixType,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5rcondEv"]
        pub fn ComplexMatrix_rcond(this: *const root::ComplexMatrix) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5rcondER10MatrixType"]
        pub fn ComplexMatrix_rcond1(this: *const root::ComplexMatrix,
                                    mattype: *mut root::MatrixType) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn ComplexMatrix_solve(this: *const root::ComplexMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn ComplexMatrix_solve1(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn ComplexMatrix_solve2(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve3(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64,
                                    sing_handler:
                                        root::ComplexMatrix_solve_singularity_handler,
                                    singular_fallback: bool,
                                    transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn ComplexMatrix_solve4(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn ComplexMatrix_solve5(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn ComplexMatrix_solve6(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve7(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64,
                                    sing_handler:
                                        root::ComplexMatrix_solve_singularity_handler,
                                    singular_fallback: bool,
                                    transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn ComplexMatrix_solve8(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn ComplexMatrix_solve9(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn ComplexMatrix_solve10(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve11(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve12(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_solve13(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn ComplexMatrix_solve14(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve15(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6Matrix"]
        pub fn ComplexMatrix_solve16(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6MatrixRi"]
        pub fn ComplexMatrix_solve17(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6MatrixRiRd"]
        pub fn ComplexMatrix_solve18(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK6MatrixRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve19(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_"]
        pub fn ComplexMatrix_solve20(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_Ri"]
        pub fn ComplexMatrix_solve21(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_RiRd"]
        pub fn ComplexMatrix_solve22(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERKS_RiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve23(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVector"]
        pub fn ComplexMatrix_solve24(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVectorRi"]
        pub fn ComplexMatrix_solve25(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVectorRiRd"]
        pub fn ComplexMatrix_solve26(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve27(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve28(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_solve29(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn ComplexMatrix_solve30(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve31(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6Matrix"]
        pub fn ComplexMatrix_lssolve(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRi"]
        pub fn ComplexMatrix_lssolve1(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRiS3_"]
        pub fn ComplexMatrix_lssolve2(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRiS3_Rd"]
        pub fn ComplexMatrix_lssolve3(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type,
                                      rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_"]
        pub fn ComplexMatrix_lssolve4(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_Ri"]
        pub fn ComplexMatrix_lssolve5(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_RiS2_"]
        pub fn ComplexMatrix_lssolve6(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_RiS2_Rd"]
        pub fn ComplexMatrix_lssolve7(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type,
                                      rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVector"]
        pub fn ComplexMatrix_lssolve8(this: *const root::ComplexMatrix,
                                      b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRi"]
        pub fn ComplexMatrix_lssolve9(this: *const root::ComplexMatrix,
                                      b: *const root::ColumnVector,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRiS3_"]
        pub fn ComplexMatrix_lssolve10(this: *const root::ComplexMatrix,
                                       b: *const root::ColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRiS3_Rd"]
        pub fn ComplexMatrix_lssolve11(this: *const root::ComplexMatrix,
                                       b: *const root::ColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type,
                                       rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_lssolve12(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_lssolve13(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRiS3_"]
        pub fn ComplexMatrix_lssolve14(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRiS3_Rd"]
        pub fn ComplexMatrix_lssolve15(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type,
                                       rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3allEi"]
        pub fn ComplexMatrix_all(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3anyEi"]
        pub fn ComplexMatrix_any(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7cumprodEi"]
        pub fn ComplexMatrix_cumprod(this: *const root::ComplexMatrix,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6cumsumEi"]
        pub fn ComplexMatrix_cumsum(this: *const root::ComplexMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4prodEi"]
        pub fn ComplexMatrix_prod(this: *const root::ComplexMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3sumEi"]
        pub fn ComplexMatrix_sum(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5sumsqEi"]
        pub fn ComplexMatrix_sumsq(this: *const root::ComplexMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3absEv"]
        pub fn ComplexMatrix_abs(this: *const root::ComplexMatrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4diagEi"]
        pub fn ComplexMatrix_diag(this: *const root::ComplexMatrix,
                                  k: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4diagEii"]
        pub fn ComplexMatrix_diag1(this: *const root::ComplexMatrix,
                                   m: root::octave_idx_type,
                                   n: root::octave_idx_type)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix16row_is_real_onlyEi"]
        pub fn ComplexMatrix_row_is_real_only(this:
                                                  *const root::ComplexMatrix,
                                              arg1: root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix19column_is_real_onlyEi"]
        pub fn ComplexMatrix_column_is_real_only(this:
                                                     *const root::ComplexMatrix,
                                                 arg1: root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_minEv"]
        pub fn ComplexMatrix_row_min(this: *const root::ComplexMatrix)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_maxEv"]
        pub fn ComplexMatrix_row_max(this: *const root::ComplexMatrix)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_minER5ArrayIiE"]
        pub fn ComplexMatrix_row_min1(this: *const root::ComplexMatrix,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_maxER5ArrayIiE"]
        pub fn ComplexMatrix_row_max1(this: *const root::ComplexMatrix,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_minEv"]
        pub fn ComplexMatrix_column_min(this: *const root::ComplexMatrix)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_maxEv"]
        pub fn ComplexMatrix_column_max(this: *const root::ComplexMatrix)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_minER5ArrayIiE"]
        pub fn ComplexMatrix_column_min1(this: *const root::ComplexMatrix,
                                         index:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_maxER5ArrayIiE"]
        pub fn ComplexMatrix_column_max1(this: *const root::ComplexMatrix,
                                         index:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK6MatrixS2_"]
        pub fn ComplexMatrix_ComplexMatrix(this: *mut root::ComplexMatrix,
                                           re: *const root::Matrix,
                                           im: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK6Matrix"]
        pub fn ComplexMatrix_ComplexMatrix1(this: *mut root::ComplexMatrix,
                                            a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK9RowVector"]
        pub fn ComplexMatrix_ComplexMatrix2(this: *mut root::ComplexMatrix,
                                            rv: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK12ColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix3(this: *mut root::ComplexMatrix,
                                            cv: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix4(this: *mut root::ComplexMatrix,
                                            a: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK11MDiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix5(this: *mut root::ComplexMatrix,
                                            a: *const root::MDiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix6(this: *mut root::ComplexMatrix,
                                            a: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK16ComplexRowVector"]
        pub fn ComplexMatrix_ComplexMatrix7(this: *mut root::ComplexMatrix,
                                            rv:
                                                *const root::ComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK19ComplexColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix8(this: *mut root::ComplexMatrix,
                                            cv:
                                                *const root::ComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix9(this: *mut root::ComplexMatrix,
                                            a:
                                                *const root::ComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK11MDiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix10(this: *mut root::ComplexMatrix,
                                             a:
                                                 *const root::MDiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix11(this: *mut root::ComplexMatrix,
                                             a:
                                                 *const root::DiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10boolMatrix"]
        pub fn ComplexMatrix_ComplexMatrix12(this: *mut root::ComplexMatrix,
                                             a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10charMatrix"]
        pub fn ComplexMatrix_ComplexMatrix13(this: *mut root::ComplexMatrix,
                                             a: *const root::charMatrix);
    }
    impl ComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            ComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(&mut self, a: *const root::ComplexMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(&mut self, a: *const root::ComplexRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(&mut self, a: *const root::ComplexColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(&mut self, a: *const root::ComplexDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(&self, a: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(&self, a: *const root::ComplexRowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(&self, a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(&self, a: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(&self, a: *const root::ComplexRowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(&self, a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::ComplexMatrix {
            ComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse5(self, mattype, info, rcon, force,
                                   calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::ComplexMatrix {
            ComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDET {
            ComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            ComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            ComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { ComplexMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            ComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            ComplexMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::ComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                                 singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            ComplexMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::ComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                                 singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                  transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                  transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            ComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            ComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix { ComplexMatrix_abs(self) }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::ComplexDiagMatrix {
            ComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            ComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            ComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector {
            ComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector {
            ComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector {
            ComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector {
            ComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(re: *const root::Matrix, im: *const root::Matrix)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix(&mut __bindgen_tmp, re, im);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix2(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix3(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(rv: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix7(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(cv: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix8(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a:
                                *const root::MDiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a:
                                *const root::DiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix13(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatMatrix {
        pub _base: root::FloatNDArray,
    }
    pub type FloatMatrix_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatMatrix_complex_matrix_type = root::FloatComplexMatrix;
    pub type FloatMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatMatrix_complex_diag_matrix_type =
        root::FloatComplexDiagMatrix;
    pub type FloatMatrix_real_elt_type = f32;
    pub type FloatMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatMatrix() {
        assert_eq!(::std::mem::size_of::<FloatMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( FloatMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatMatrix>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( FloatMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix12is_symmetricEv"]
        pub fn FloatMatrix_is_symmetric(this: *const root::FloatMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERKS_ii"]
        pub fn FloatMatrix_insert(this: *mut root::FloatMatrix,
                                  a: *const root::FloatMatrix,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK14FloatRowVectorii"]
        pub fn FloatMatrix_insert1(this: *mut root::FloatMatrix,
                                   a: *const root::FloatRowVector,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK17FloatColumnVectorii"]
        pub fn FloatMatrix_insert2(this: *mut root::FloatMatrix,
                                   a: *const root::FloatColumnVector,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK15FloatDiagMatrixii"]
        pub fn FloatMatrix_insert3(this: *mut root::FloatMatrix,
                                   a: *const root::FloatDiagMatrix,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix4fillEf"]
        pub fn FloatMatrix_fill(this: *mut root::FloatMatrix, val: f32)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix4fillEfiiii"]
        pub fn FloatMatrix_fill1(this: *mut root::FloatMatrix, val: f32,
                                 r1: root::octave_idx_type,
                                 c1: root::octave_idx_type,
                                 r2: root::octave_idx_type,
                                 c2: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERKS_"]
        pub fn FloatMatrix_append(this: *const root::FloatMatrix,
                                  a: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK14FloatRowVector"]
        pub fn FloatMatrix_append1(this: *const root::FloatMatrix,
                                   a: *const root::FloatRowVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK17FloatColumnVector"]
        pub fn FloatMatrix_append2(this: *const root::FloatMatrix,
                                   a: *const root::FloatColumnVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatMatrix_append3(this: *const root::FloatMatrix,
                                   a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERKS_"]
        pub fn FloatMatrix_stack(this: *const root::FloatMatrix,
                                 a: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK14FloatRowVector"]
        pub fn FloatMatrix_stack1(this: *const root::FloatMatrix,
                                  a: *const root::FloatRowVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK17FloatColumnVector"]
        pub fn FloatMatrix_stack2(this: *const root::FloatMatrix,
                                  a: *const root::FloatColumnVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatMatrix_stack3(this: *const root::FloatMatrix,
                                  a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7extractEiiii"]
        pub fn FloatMatrix_extract(this: *const root::FloatMatrix,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix9extract_nEiiii"]
        pub fn FloatMatrix_extract_n(this: *const root::FloatMatrix,
                                     r1: root::octave_idx_type,
                                     c1: root::octave_idx_type,
                                     nr: root::octave_idx_type,
                                     nc: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3rowEi"]
        pub fn FloatMatrix_row(this: *const root::FloatMatrix,
                               i: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6columnEi"]
        pub fn FloatMatrix_column(this: *const root::FloatMatrix,
                                  i: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseEv"]
        pub fn FloatMatrix_inverse(this: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseERi"]
        pub fn FloatMatrix_inverse1(this: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseERiRfbb"]
        pub fn FloatMatrix_inverse2(this: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f32, force: bool,
                                    calc_cond: bool) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixType"]
        pub fn FloatMatrix_inverse3(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixTypeRi"]
        pub fn FloatMatrix_inverse4(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixTypeRiRfbb"]
        pub fn FloatMatrix_inverse5(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f32, force: bool,
                                    calc_cond: bool) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix14pseudo_inverseEf"]
        pub fn FloatMatrix_pseudo_inverse(this: *const root::FloatMatrix,
                                          tol: f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7fourierEv"]
        pub fn FloatMatrix_fourier(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix8ifourierEv"]
        pub fn FloatMatrix_ifourier(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix9fourier2dEv"]
        pub fn FloatMatrix_fourier2d(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10ifourier2dEv"]
        pub fn FloatMatrix_ifourier2d(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantEv"]
        pub fn FloatMatrix_determinant(this: *const root::FloatMatrix)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantERi"]
        pub fn FloatMatrix_determinant1(this: *const root::FloatMatrix,
                                        info: *mut root::octave_idx_type)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantERiRfb"]
        pub fn FloatMatrix_determinant2(this: *const root::FloatMatrix,
                                        info: *mut root::octave_idx_type,
                                        rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantER10MatrixTypeRiRfb"]
        pub fn FloatMatrix_determinant3(this: *const root::FloatMatrix,
                                        mattype: *mut root::MatrixType,
                                        info: *mut root::octave_idx_type,
                                        rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5rcondEv"]
        pub fn FloatMatrix_rcond(this: *const root::FloatMatrix) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5rcondER10MatrixType"]
        pub fn FloatMatrix_rcond1(this: *const root::FloatMatrix,
                                  mattype: *mut root::MatrixType) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatMatrix_solve(this: *const root::FloatMatrix,
                                 typ: *mut root::MatrixType,
                                 b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn FloatMatrix_solve1(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RiRf"]
        pub fn FloatMatrix_solve2(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RiRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve3(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32,
                                  sing_handler:
                                      root::FloatMatrix_solve_singularity_handler,
                                  singular_fallback: bool,
                                  transt: root::blas_trans_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve4(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_solve5(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRiRf"]
        pub fn FloatMatrix_solve6(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRiRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve7(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32,
                                  sing_handler:
                                      root::FloatMatrix_solve_singularity_handler,
                                  singular_fallback: bool,
                                  transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatMatrix_solve8(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRi"]
        pub fn FloatMatrix_solve9(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatColumnVector,
                                  info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRf"]
        pub fn FloatMatrix_solve10(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve11(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve12(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_solve13(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRf"]
        pub fn FloatMatrix_solve14(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve15(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_"]
        pub fn FloatMatrix_solve16(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_Ri"]
        pub fn FloatMatrix_solve17(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_RiRf"]
        pub fn FloatMatrix_solve18(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERKS_RiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve19(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve20(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_solve21(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRiRf"]
        pub fn FloatMatrix_solve22(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve23(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVector"]
        pub fn FloatMatrix_solve24(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRi"]
        pub fn FloatMatrix_solve25(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRiRf"]
        pub fn FloatMatrix_solve26(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve27(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve28(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_solve29(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRiRf"]
        pub fn FloatMatrix_solve30(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve31(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_"]
        pub fn FloatMatrix_lssolve(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_Ri"]
        pub fn FloatMatrix_lssolve1(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_RiS2_"]
        pub fn FloatMatrix_lssolve2(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_RiS2_Rf"]
        pub fn FloatMatrix_lssolve3(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type,
                                    rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_lssolve4(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_lssolve5(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRiS3_"]
        pub fn FloatMatrix_lssolve6(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRiS3_Rf"]
        pub fn FloatMatrix_lssolve7(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type,
                                    rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatMatrix_lssolve8(this: *const root::FloatMatrix,
                                    b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRi"]
        pub fn FloatMatrix_lssolve9(this: *const root::FloatMatrix,
                                    b: *const root::FloatColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRiS3_"]
        pub fn FloatMatrix_lssolve10(this: *const root::FloatMatrix,
                                     b: *const root::FloatColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRiS3_Rf"]
        pub fn FloatMatrix_lssolve11(this: *const root::FloatMatrix,
                                     b: *const root::FloatColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type,
                                     rcon: *mut f32)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_lssolve12(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_lssolve13(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRiS3_"]
        pub fn FloatMatrix_lssolve14(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRiS3_Rf"]
        pub fn FloatMatrix_lssolve15(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type,
                                     rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7cumprodEi"]
        pub fn FloatMatrix_cumprod(this: *const root::FloatMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6cumsumEi"]
        pub fn FloatMatrix_cumsum(this: *const root::FloatMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4prodEi"]
        pub fn FloatMatrix_prod(this: *const root::FloatMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3sumEi"]
        pub fn FloatMatrix_sum(this: *const root::FloatMatrix,
                               dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5sumsqEi"]
        pub fn FloatMatrix_sumsq(this: *const root::FloatMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3absEv"]
        pub fn FloatMatrix_abs(this: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4diagEi"]
        pub fn FloatMatrix_diag(this: *const root::FloatMatrix,
                                k: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4diagEii"]
        pub fn FloatMatrix_diag1(this: *const root::FloatMatrix,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_minEv"]
        pub fn FloatMatrix_row_min(this: *const root::FloatMatrix)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_maxEv"]
        pub fn FloatMatrix_row_max(this: *const root::FloatMatrix)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_minER5ArrayIiE"]
        pub fn FloatMatrix_row_min1(this: *const root::FloatMatrix,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_maxER5ArrayIiE"]
        pub fn FloatMatrix_row_max1(this: *const root::FloatMatrix,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_minEv"]
        pub fn FloatMatrix_column_min(this: *const root::FloatMatrix)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_maxEv"]
        pub fn FloatMatrix_column_max(this: *const root::FloatMatrix)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_minER5ArrayIiE"]
        pub fn FloatMatrix_column_min1(this: *const root::FloatMatrix,
                                       index:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_maxER5ArrayIiE"]
        pub fn FloatMatrix_column_max1(this: *const root::FloatMatrix,
                                       index:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK14FloatRowVector"]
        pub fn FloatMatrix_FloatMatrix(this: *mut root::FloatMatrix,
                                       rv: *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK17FloatColumnVector"]
        pub fn FloatMatrix_FloatMatrix1(this: *mut root::FloatMatrix,
                                        cv: *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatMatrix_FloatMatrix2(this: *mut root::FloatMatrix,
                                        a: *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix3(this: *mut root::FloatMatrix,
                                        a: *const root::MDiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix4(this: *mut root::FloatMatrix,
                                        a: *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10PermMatrix"]
        pub fn FloatMatrix_FloatMatrix5(this: *mut root::FloatMatrix,
                                        a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10boolMatrix"]
        pub fn FloatMatrix_FloatMatrix6(this: *mut root::FloatMatrix,
                                        a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10charMatrix"]
        pub fn FloatMatrix_FloatMatrix7(this: *mut root::FloatMatrix,
                                        a: *const root::charMatrix);
    }
    impl FloatMatrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            FloatMatrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::FloatDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatMatrix {
            FloatMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector)
         -> root::FloatMatrix {
            FloatMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::FloatColumnVector)
         -> root::FloatMatrix {
            FloatMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix {
            FloatMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector)
         -> root::FloatMatrix {
            FloatMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector)
         -> root::FloatMatrix {
            FloatMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix {
            FloatMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatMatrix {
            FloatMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatMatrix {
            FloatMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::FloatMatrix {
            FloatMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatMatrix {
            FloatMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatMatrix {
            FloatMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::FloatDET {
            FloatMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET {
            FloatMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET {
            FloatMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatMatrix {
            FloatMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatMatrix {
            FloatMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                               singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                               singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatMatrix {
            FloatMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatMatrix {
            FloatMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatMatrix {
            FloatMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::FloatColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self,
                                b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatDiagMatrix {
            FloatMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatColumnVector {
            FloatMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatColumnVector {
            FloatMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector {
            FloatMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector {
            FloatMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatRowVector {
            FloatMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatRowVector {
            FloatMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector {
            FloatMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector {
            FloatMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexMatrix {
        pub _base: root::FloatComplexNDArray,
    }
    pub type FloatComplexMatrix_column_vector_type =
        root::FloatComplexColumnVector;
    pub type FloatComplexMatrix_row_vector_type = root::FloatComplexRowVector;
    pub type FloatComplexMatrix_real_column_vector_type =
        root::FloatColumnVector;
    pub type FloatComplexMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatComplexMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatComplexMatrix_complex_matrix_type =
        root::FloatComplexMatrix;
    pub type FloatComplexMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatComplexMatrix_complex_diag_matrix_type =
        root::FloatComplexDiagMatrix;
    pub type FloatComplexMatrix_real_elt_type = f32;
    pub type FloatComplexMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatComplexMatrix() {
        assert_eq!(::std::mem::size_of::<FloatComplexMatrix>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( FloatComplexMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<FloatComplexMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix12is_hermitianEv"]
        pub fn FloatComplexMatrix_is_hermitian(this:
                                                   *const root::FloatComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK11FloatMatrixii"]
        pub fn FloatComplexMatrix_insert(this: *mut root::FloatComplexMatrix,
                                         a: *const root::FloatMatrix,
                                         r: root::octave_idx_type,
                                         c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK14FloatRowVectorii"]
        pub fn FloatComplexMatrix_insert1(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatRowVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK17FloatColumnVectorii"]
        pub fn FloatComplexMatrix_insert2(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatColumnVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK15FloatDiagMatrixii"]
        pub fn FloatComplexMatrix_insert3(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatDiagMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERKS_ii"]
        pub fn FloatComplexMatrix_insert4(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatComplexMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK21FloatComplexRowVectorii"]
        pub fn FloatComplexMatrix_insert5(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexRowVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK24FloatComplexColumnVectorii"]
        pub fn FloatComplexMatrix_insert6(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexColumnVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK22FloatComplexDiagMatrixii"]
        pub fn FloatComplexMatrix_insert7(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexDiagMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillEf"]
        pub fn FloatComplexMatrix_fill(this: *mut root::FloatComplexMatrix,
                                       val: f32)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexMatrix_fill1(this: *mut root::FloatComplexMatrix,
                                        val: *const root::FloatComplex)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillEfiiii"]
        pub fn FloatComplexMatrix_fill2(this: *mut root::FloatComplexMatrix,
                                        val: f32, r1: root::octave_idx_type,
                                        c1: root::octave_idx_type,
                                        r2: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillERKSt7complexIfEiiii"]
        pub fn FloatComplexMatrix_fill3(this: *mut root::FloatComplexMatrix,
                                        val: *const root::FloatComplex,
                                        r1: root::octave_idx_type,
                                        c1: root::octave_idx_type,
                                        r2: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK11FloatMatrix"]
        pub fn FloatComplexMatrix_append(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK14FloatRowVector"]
        pub fn FloatComplexMatrix_append1(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_append2(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_append3(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERKS_"]
        pub fn FloatComplexMatrix_append4(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_append5(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_append6(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_append7(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK11FloatMatrix"]
        pub fn FloatComplexMatrix_stack(this: *const root::FloatComplexMatrix,
                                        a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK14FloatRowVector"]
        pub fn FloatComplexMatrix_stack1(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_stack2(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_stack3(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERKS_"]
        pub fn FloatComplexMatrix_stack4(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_stack5(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_stack6(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_stack7(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7extractEiiii"]
        pub fn FloatComplexMatrix_extract(this:
                                              *const root::FloatComplexMatrix,
                                          r1: root::octave_idx_type,
                                          c1: root::octave_idx_type,
                                          r2: root::octave_idx_type,
                                          c2: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix9extract_nEiiii"]
        pub fn FloatComplexMatrix_extract_n(this:
                                                *const root::FloatComplexMatrix,
                                            r1: root::octave_idx_type,
                                            c1: root::octave_idx_type,
                                            nr: root::octave_idx_type,
                                            nc: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3rowEi"]
        pub fn FloatComplexMatrix_row(this: *const root::FloatComplexMatrix,
                                      i: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6columnEi"]
        pub fn FloatComplexMatrix_column(this:
                                             *const root::FloatComplexMatrix,
                                         i: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseEv"]
        pub fn FloatComplexMatrix_inverse(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseERi"]
        pub fn FloatComplexMatrix_inverse1(this:
                                               *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseERiRfbb"]
        pub fn FloatComplexMatrix_inverse2(this:
                                               *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcon: *mut f32, force: bool,
                                           calc_cond: bool)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixType"]
        pub fn FloatComplexMatrix_inverse3(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn FloatComplexMatrix_inverse4(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRiRfbb"]
        pub fn FloatComplexMatrix_inverse5(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType,
                                           info: *mut root::octave_idx_type,
                                           rcon: *mut f32, force: bool,
                                           calc_cond: bool)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix14pseudo_inverseEf"]
        pub fn FloatComplexMatrix_pseudo_inverse(this:
                                                     *const root::FloatComplexMatrix,
                                                 tol: f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7fourierEv"]
        pub fn FloatComplexMatrix_fourier(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix8ifourierEv"]
        pub fn FloatComplexMatrix_ifourier(this:
                                               *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix9fourier2dEv"]
        pub fn FloatComplexMatrix_fourier2d(this:
                                                *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10ifourier2dEv"]
        pub fn FloatComplexMatrix_ifourier2d(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantEv"]
        pub fn FloatComplexMatrix_determinant(this:
                                                  *const root::FloatComplexMatrix)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantERi"]
        pub fn FloatComplexMatrix_determinant1(this:
                                                   *const root::FloatComplexMatrix,
                                               info:
                                                   *mut root::octave_idx_type)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantERiRfb"]
        pub fn FloatComplexMatrix_determinant2(this:
                                                   *const root::FloatComplexMatrix,
                                               info:
                                                   *mut root::octave_idx_type,
                                               rcon: *mut f32,
                                               calc_cond: bool)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix11determinantER10MatrixTypeRiRfb"]
        pub fn FloatComplexMatrix_determinant3(this:
                                                   *const root::FloatComplexMatrix,
                                               mattype: *mut root::MatrixType,
                                               info:
                                                   *mut root::octave_idx_type,
                                               rcon: *mut f32,
                                               calc_cond: bool)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5rcondEv"]
        pub fn FloatComplexMatrix_rcond(this: *const root::FloatComplexMatrix)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5rcondER10MatrixType"]
        pub fn FloatComplexMatrix_rcond1(this:
                                             *const root::FloatComplexMatrix,
                                         mattype: *mut root::MatrixType)
         -> f32;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve(this: *const root::FloatComplexMatrix,
                                        typ: *mut root::MatrixType,
                                        b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_solve1(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRiRf"]
        pub fn FloatComplexMatrix_solve2(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRiRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve3(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32,
                                         sing_handler:
                                             root::FloatComplexMatrix_solve_singularity_handler,
                                         singular_fallback: bool,
                                         transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatComplexMatrix_solve4(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn FloatComplexMatrix_solve5(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RiRf"]
        pub fn FloatComplexMatrix_solve6(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RiRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve7(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32,
                                         sing_handler:
                                             root::FloatComplexMatrix_solve_singularity_handler,
                                         singular_fallback: bool,
                                         transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve8(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_solve9(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatColumnVector,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve10(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve11(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve12(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_solve13(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve14(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve15(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve16(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_solve17(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRiRf"]
        pub fn FloatComplexMatrix_solve18(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve19(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_"]
        pub fn FloatComplexMatrix_solve20(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_Ri"]
        pub fn FloatComplexMatrix_solve21(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_RiRf"]
        pub fn FloatComplexMatrix_solve22(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERKS_RiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve23(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve24(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_solve25(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve26(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve27(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve28(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_solve29(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve30(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve31(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_lssolve(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_lssolve1(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRiS3_"]
        pub fn FloatComplexMatrix_lssolve2(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve3(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type,
                                           rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_"]
        pub fn FloatComplexMatrix_lssolve4(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_Ri"]
        pub fn FloatComplexMatrix_lssolve5(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_RiS2_"]
        pub fn FloatComplexMatrix_lssolve6(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_RiS2_Rf"]
        pub fn FloatComplexMatrix_lssolve7(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type,
                                           rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_lssolve8(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_lssolve9(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRiS3_"]
        pub fn FloatComplexMatrix_lssolve10(this:
                                                *const root::FloatComplexMatrix,
                                            b: *const root::FloatColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve11(this:
                                                *const root::FloatComplexMatrix,
                                            b: *const root::FloatColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type,
                                            rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_lssolve12(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_lssolve13(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRiS3_"]
        pub fn FloatComplexMatrix_lssolve14(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve15(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type,
                                            rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3allEi"]
        pub fn FloatComplexMatrix_all(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3anyEi"]
        pub fn FloatComplexMatrix_any(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7cumprodEi"]
        pub fn FloatComplexMatrix_cumprod(this:
                                              *const root::FloatComplexMatrix,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6cumsumEi"]
        pub fn FloatComplexMatrix_cumsum(this:
                                             *const root::FloatComplexMatrix,
                                         dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4prodEi"]
        pub fn FloatComplexMatrix_prod(this: *const root::FloatComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3sumEi"]
        pub fn FloatComplexMatrix_sum(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5sumsqEi"]
        pub fn FloatComplexMatrix_sumsq(this: *const root::FloatComplexMatrix,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3absEv"]
        pub fn FloatComplexMatrix_abs(this: *const root::FloatComplexMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4diagEi"]
        pub fn FloatComplexMatrix_diag(this: *const root::FloatComplexMatrix,
                                       k: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4diagEii"]
        pub fn FloatComplexMatrix_diag1(this: *const root::FloatComplexMatrix,
                                        m: root::octave_idx_type,
                                        n: root::octave_idx_type)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix16row_is_real_onlyEi"]
        pub fn FloatComplexMatrix_row_is_real_only(this:
                                                       *const root::FloatComplexMatrix,
                                                   arg1:
                                                       root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix19column_is_real_onlyEi"]
        pub fn FloatComplexMatrix_column_is_real_only(this:
                                                          *const root::FloatComplexMatrix,
                                                      arg1:
                                                          root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_minEv"]
        pub fn FloatComplexMatrix_row_min(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_maxEv"]
        pub fn FloatComplexMatrix_row_max(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_minER5ArrayIiE"]
        pub fn FloatComplexMatrix_row_min1(this:
                                               *const root::FloatComplexMatrix,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_maxER5ArrayIiE"]
        pub fn FloatComplexMatrix_row_max1(this:
                                               *const root::FloatComplexMatrix,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_minEv"]
        pub fn FloatComplexMatrix_column_min(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_maxEv"]
        pub fn FloatComplexMatrix_column_max(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_minER5ArrayIiE"]
        pub fn FloatComplexMatrix_column_min1(this:
                                                  *const root::FloatComplexMatrix,
                                              index:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_maxER5ArrayIiE"]
        pub fn FloatComplexMatrix_column_max1(this:
                                                  *const root::FloatComplexMatrix,
                                              index:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11FloatMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix(this:
                                                         *mut root::FloatComplexMatrix,
                                                     a:
                                                         *const root::FloatMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK14FloatRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix1(this:
                                                          *mut root::FloatComplexMatrix,
                                                      rv:
                                                          *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix2(this:
                                                          *mut root::FloatComplexMatrix,
                                                      cv:
                                                          *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix3(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix4(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::MDiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix5(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix6(this:
                                                          *mut root::FloatComplexMatrix,
                                                      rv:
                                                          *const root::FloatComplexRowVector);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix7(this:
                                                          *mut root::FloatComplexMatrix,
                                                      cv:
                                                          *const root::FloatComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix8(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::FloatComplexDiagMatrix);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK11MDiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix9(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::MDiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix10(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::DiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10boolMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix11(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10charMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix12(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::charMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11FloatMatrixS2_"]
        pub fn FloatComplexMatrix_FloatComplexMatrix13(this:
                                                           *mut root::FloatComplexMatrix,
                                                       re:
                                                           *const root::FloatMatrix,
                                                       im:
                                                           *const root::FloatMatrix);
    }
    impl FloatComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            FloatComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::FloatDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(&mut self, a: *const root::FloatComplexMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(&mut self,
                              a: *const root::FloatComplexRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(&mut self,
                              a: *const root::FloatComplexColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(&mut self,
                              a: *const root::FloatComplexDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(&self, a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(&self, a: *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(&self, a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(&self, a: *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse5(self, mattype, info, rcon, force,
                                        calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant3(self, mattype, info, rcon,
                                            calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatComplexMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                                      singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                                      singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve19(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve23(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve27(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve31(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::FloatColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self,
                                b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            FloatComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            FloatComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatComplexDiagMatrix {
            FloatComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            FloatComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            FloatComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix1(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix2(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(rv: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix6(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(cv: *const root::FloatComplexColumnVector)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix7(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(a: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix8(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a:
                               *const root::MDiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a:
                                *const root::DiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(re: *const root::FloatMatrix,
                            im: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix13(&mut __bindgen_tmp, re,
                                                    im);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseMatrix {
        pub _base: root::MSparse<f64>,
    }
    pub type SparseMatrix_dense_matrix_type = root::Matrix;
    pub type SparseMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseMatrix() {
        assert_eq!(::std::mem::size_of::<SparseMatrix>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( SparseMatrix ) ));
        assert_eq! (::std::mem::align_of::<SparseMatrix>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( SparseMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12is_symmetricEv"]
        pub fn SparseMatrix_is_symmetric(this: *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3maxEi"]
        pub fn SparseMatrix_max(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3maxER5ArrayIiEi"]
        pub fn SparseMatrix_max1(this: *const root::SparseMatrix,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3minEi"]
        pub fn SparseMatrix_min(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3minER5ArrayIiEi"]
        pub fn SparseMatrix_min1(this: *const root::SparseMatrix,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6insertERKS_ii"]
        pub fn SparseMatrix_insert(this: *mut root::SparseMatrix,
                                   a: *const root::SparseMatrix,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseMatrix_insert1(this: *mut root::SparseMatrix,
                                    a: *const root::SparseMatrix,
                                    indx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseMatrix_concat(this: *mut root::SparseMatrix,
                                   rb: *const root::SparseMatrix,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN12SparseMatrix6concatERK19SparseComplexMatrixRK5ArrayIiE"]
        pub fn SparseMatrix_concat1(this: *mut root::SparseMatrix,
                                    rb: *const root::SparseComplexMatrix,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3rowEi"]
        pub fn SparseMatrix_row(this: *const root::SparseMatrix,
                                i: root::octave_idx_type) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix6columnEi"]
        pub fn SparseMatrix_column(this: *const root::SparseMatrix,
                                   i: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseEv"]
        pub fn SparseMatrix_inverse(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixType"]
        pub fn SparseMatrix_inverse1(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixTypeRi"]
        pub fn SparseMatrix_inverse2(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType,
                                     info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn SparseMatrix_inverse3(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType,
                                     info: *mut root::octave_idx_type,
                                     rcond: *mut f64, force: bool,
                                     calc_cond: bool) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantEv"]
        pub fn SparseMatrix_determinant(this: *const root::SparseMatrix)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantERi"]
        pub fn SparseMatrix_determinant1(this: *const root::SparseMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantERiRdb"]
        pub fn SparseMatrix_determinant2(this: *const root::SparseMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcond: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseMatrix_solve(this: *const root::SparseMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn SparseMatrix_solve1(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn SparseMatrix_solve2(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve3(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64,
                                   sing_handler:
                                       root::SparseMatrix_solve_singularity_handler,
                                   singular_fallback: bool) -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseMatrix_solve4(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn SparseMatrix_solve5(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn SparseMatrix_solve6(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve7(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64,
                                   sing_handler:
                                       root::SparseMatrix_solve_singularity_handler,
                                   singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseMatrix_solve8(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn SparseMatrix_solve9(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::SparseMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn SparseMatrix_solve10(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb"]
        pub fn SparseMatrix_solve11(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler,
                                    singular_fallback: bool)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve12(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRi"]
        pub fn SparseMatrix_solve13(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRiRd"]
        pub fn SparseMatrix_solve14(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve15(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler,
                                    singular_fallabck: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseMatrix_solve16(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn SparseMatrix_solve17(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn SparseMatrix_solve18(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve19(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseMatrix_solve20(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn SparseMatrix_solve21(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn SparseMatrix_solve22(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve23(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6Matrix"]
        pub fn SparseMatrix_solve24(this: *const root::SparseMatrix,
                                    b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRi"]
        pub fn SparseMatrix_solve25(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRiRd"]
        pub fn SparseMatrix_solve26(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve27(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrix"]
        pub fn SparseMatrix_solve28(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRi"]
        pub fn SparseMatrix_solve29(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRiRd"]
        pub fn SparseMatrix_solve30(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve31(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_"]
        pub fn SparseMatrix_solve32(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_Ri"]
        pub fn SparseMatrix_solve33(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_RiRd"]
        pub fn SparseMatrix_solve34(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_RiRdPFvdE"]
        pub fn SparseMatrix_solve35(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve36(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRi"]
        pub fn SparseMatrix_solve37(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRiRd"]
        pub fn SparseMatrix_solve38(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve39(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVector"]
        pub fn SparseMatrix_solve40(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRi"]
        pub fn SparseMatrix_solve41(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRiRd"]
        pub fn SparseMatrix_solve42(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve43(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseMatrix_solve44(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn SparseMatrix_solve45(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn SparseMatrix_solve46(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve47(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix23any_element_is_negativeEb"]
        pub fn SparseMatrix_any_element_is_negative(this:
                                                        *const root::SparseMatrix,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix18any_element_is_nanEv"]
        pub fn SparseMatrix_any_element_is_nan(this:
                                                   *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseMatrix_any_element_is_inf_or_nan(this:
                                                          *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix27any_element_not_one_or_zeroEv"]
        pub fn SparseMatrix_any_element_not_one_or_zero(this:
                                                            *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix21all_elements_are_zeroEv"]
        pub fn SparseMatrix_all_elements_are_zero(this:
                                                      *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix34all_elements_are_int_or_inf_or_nanEv"]
        pub fn SparseMatrix_all_elements_are_int_or_inf_or_nan(this:
                                                                   *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12all_integersERdS0_"]
        pub fn SparseMatrix_all_integers(this: *const root::SparseMatrix,
                                         max_val: *mut f64, min_val: *mut f64)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix19too_large_for_floatEv"]
        pub fn SparseMatrix_too_large_for_float(this:
                                                    *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3allEi"]
        pub fn SparseMatrix_all(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3anyEi"]
        pub fn SparseMatrix_any(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7cumprodEi"]
        pub fn SparseMatrix_cumprod(this: *const root::SparseMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix6cumsumEi"]
        pub fn SparseMatrix_cumsum(this: *const root::SparseMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix4prodEi"]
        pub fn SparseMatrix_prod(this: *const root::SparseMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3sumEi"]
        pub fn SparseMatrix_sum(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5sumsqEi"]
        pub fn SparseMatrix_sumsq(this: *const root::SparseMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3absEv"]
        pub fn SparseMatrix_abs(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix4diagEi"]
        pub fn SparseMatrix_diag(this: *const root::SparseMatrix,
                                 k: root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12matrix_valueEv"]
        pub fn SparseMatrix_matrix_value(this: *const root::SparseMatrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7squeezeEv"]
        pub fn SparseMatrix_squeeze(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7reshapeERK10dim_vector"]
        pub fn SparseMatrix_reshape(this: *const root::SparseMatrix,
                                    new_dims: *const root::dim_vector)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseMatrix_permute(this: *const root::SparseMatrix,
                                    vec:
                                        *const root::Array<::std::os::raw::c_int>,
                                    inv: bool) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseMatrix_ipermute(this: *const root::SparseMatrix,
                                     vec:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseMatrix_SparseMatrix(this: *mut root::SparseMatrix,
                                         a: *const root::SparseBoolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrixC1ERK10DiagMatrix"]
        pub fn SparseMatrix_SparseMatrix1(this: *mut root::SparseMatrix,
                                          a: *const root::DiagMatrix);
    }
    impl SparseMatrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            SparseMatrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseMatrix {
            SparseMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseMatrix {
            SparseMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix {
            SparseMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::SparseComplexMatrix,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            SparseMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseMatrix {
            SparseMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType)
         -> root::SparseMatrix {
            SparseMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcond: *mut f64, force: bool, calc_cond: bool)
         -> root::SparseMatrix {
            SparseMatrix_inverse3(self, mattype, info, rcond, force,
                                  calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            SparseMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::DET {
            SparseMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcond: *mut f64, calc_cond: bool)
         -> root::DET {
            SparseMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix {
            SparseMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix {
            SparseMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::Matrix {
            SparseMatrix_solve2(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::Matrix {
            SparseMatrix_solve3(self, typ, b, info, rcond, sing_handler,
                                singular_fallback)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseMatrix_solve6(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseMatrix_solve7(self, typ, b, info, rcond, sing_handler,
                                singular_fallback)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix)
         -> root::SparseMatrix {
            SparseMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix,
                             info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseMatrix {
            SparseMatrix_solve10(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler,
                              singular_fallback: bool) -> root::SparseMatrix {
            SparseMatrix_solve11(self, typ, b, info, rcond, sing_handler,
                                 singular_fallback)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseMatrix_solve14(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler,
                              singular_fallabck: bool)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve15(self, typ, b, info, rcond, sing_handler,
                                 singular_fallabck)
        }
        #[inline]
        pub unsafe fn solve16(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector)
         -> root::ColumnVector {
            SparseMatrix_solve16(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_solve17(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ColumnVector {
            SparseMatrix_solve18(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector {
            SparseMatrix_solve19(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseMatrix_solve20(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseMatrix_solve21(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseMatrix_solve22(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseMatrix_solve23(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix) -> root::Matrix {
            SparseMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix {
            SparseMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::Matrix {
            SparseMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::Matrix {
            SparseMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix)
         -> root::SparseMatrix {
            SparseMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseMatrix {
            SparseMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::SparseMatrix {
            SparseMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(&self, b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            SparseMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ColumnVector {
            SparseMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector {
            SparseMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            SparseMatrix_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            SparseMatrix_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            SparseMatrix_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            SparseMatrix_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            SparseMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            SparseMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseMatrix {
            SparseMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseMatrix {
            SparseMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseMatrix {
            SparseMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix {
            SparseMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseMatrix_SparseMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseMatrix_SparseMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseComplexMatrix {
        pub _base: root::MSparse<root::std::complex<f64>>,
    }
    pub type SparseComplexMatrix_dense_matrix_type = root::ComplexMatrix;
    pub type SparseComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseComplexMatrix() {
        assert_eq!(::std::mem::size_of::<SparseComplexMatrix>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( SparseComplexMatrix ) ));
        assert_eq! (::std::mem::align_of::<SparseComplexMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( SparseComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12is_hermitianEv"]
        pub fn SparseComplexMatrix_is_hermitian(this:
                                                    *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3maxEi"]
        pub fn SparseComplexMatrix_max(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3maxER5ArrayIiEi"]
        pub fn SparseComplexMatrix_max1(this:
                                            *const root::SparseComplexMatrix,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3minEi"]
        pub fn SparseComplexMatrix_min(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3minER5ArrayIiEi"]
        pub fn SparseComplexMatrix_min1(this:
                                            *const root::SparseComplexMatrix,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERKS_ii"]
        pub fn SparseComplexMatrix_insert(this:
                                              *mut root::SparseComplexMatrix,
                                          a: *const root::SparseComplexMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERK12SparseMatrixii"]
        pub fn SparseComplexMatrix_insert1(this:
                                               *mut root::SparseComplexMatrix,
                                           a: *const root::SparseMatrix,
                                           r: root::octave_idx_type,
                                           c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseComplexMatrix_insert2(this:
                                               *mut root::SparseComplexMatrix,
                                           a:
                                               *const root::SparseComplexMatrix,
                                           indx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN19SparseComplexMatrix6insertERK12SparseMatrixRK5ArrayIiE"]
        pub fn SparseComplexMatrix_insert3(this:
                                               *mut root::SparseComplexMatrix,
                                           a: *const root::SparseMatrix,
                                           indx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseComplexMatrix_concat(this:
                                              *mut root::SparseComplexMatrix,
                                          rb:
                                              *const root::SparseComplexMatrix,
                                          ra_idx:
                                              *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN19SparseComplexMatrix6concatERK12SparseMatrixRK5ArrayIiE"]
        pub fn SparseComplexMatrix_concat1(this:
                                               *mut root::SparseComplexMatrix,
                                           rb: *const root::SparseMatrix,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12matrix_valueEv"]
        pub fn SparseComplexMatrix_matrix_value(this:
                                                    *const root::SparseComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix9hermitianEv"]
        pub fn SparseComplexMatrix_hermitian(this:
                                                 *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3rowEi"]
        pub fn SparseComplexMatrix_row(this: *const root::SparseComplexMatrix,
                                       i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix6columnEi"]
        pub fn SparseComplexMatrix_column(this:
                                              *const root::SparseComplexMatrix,
                                          i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseEv"]
        pub fn SparseComplexMatrix_inverse(this:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixType"]
        pub fn SparseComplexMatrix_inverse1(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn SparseComplexMatrix_inverse2(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType,
                                            info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn SparseComplexMatrix_inverse3(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType,
                                            info: *mut root::octave_idx_type,
                                            rcond: *mut f64, force: bool,
                                            calc_cond: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantEv"]
        pub fn SparseComplexMatrix_determinant(this:
                                                   *const root::SparseComplexMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantERi"]
        pub fn SparseComplexMatrix_determinant1(this:
                                                    *const root::SparseComplexMatrix,
                                                info:
                                                    *mut root::octave_idx_type)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantERiRdb"]
        pub fn SparseComplexMatrix_determinant2(this:
                                                    *const root::SparseComplexMatrix,
                                                info:
                                                    *mut root::octave_idx_type,
                                                rcond: *mut f64,
                                                calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseComplexMatrix_solve(this:
                                             *const root::SparseComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn SparseComplexMatrix_solve1(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn SparseComplexMatrix_solve2(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve3(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64,
                                          sing_handler:
                                              root::SparseComplexMatrix_solve_singularity_handler,
                                          singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve4(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn SparseComplexMatrix_solve5(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn SparseComplexMatrix_solve6(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve7(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64,
                                          sing_handler:
                                              root::SparseComplexMatrix_solve_singularity_handler,
                                          singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve8(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRi"]
        pub fn SparseComplexMatrix_solve9(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::SparseMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRiRd"]
        pub fn SparseComplexMatrix_solve10(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve11(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler,
                                           singular_fallback: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseComplexMatrix_solve12(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn SparseComplexMatrix_solve13(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn SparseComplexMatrix_solve14(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve15(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler,
                                           singular_fallback: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseComplexMatrix_solve16(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn SparseComplexMatrix_solve17(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve18(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve19(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve20(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn SparseComplexMatrix_solve21(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve22(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve23(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6Matrix"]
        pub fn SparseComplexMatrix_solve24(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRi"]
        pub fn SparseComplexMatrix_solve25(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRiRd"]
        pub fn SparseComplexMatrix_solve26(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve27(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve28(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRi"]
        pub fn SparseComplexMatrix_solve29(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRiRd"]
        pub fn SparseComplexMatrix_solve30(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve31(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve32(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRi"]
        pub fn SparseComplexMatrix_solve33(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRiRd"]
        pub fn SparseComplexMatrix_solve34(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve35(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_"]
        pub fn SparseComplexMatrix_solve36(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_Ri"]
        pub fn SparseComplexMatrix_solve37(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_RiRd"]
        pub fn SparseComplexMatrix_solve38(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_RiRdPFvdE"]
        pub fn SparseComplexMatrix_solve39(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVector"]
        pub fn SparseComplexMatrix_solve40(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRi"]
        pub fn SparseComplexMatrix_solve41(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve42(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve43(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve44(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn SparseComplexMatrix_solve45(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve46(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve47(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7squeezeEv"]
        pub fn SparseComplexMatrix_squeeze(this:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7reshapeERK10dim_vector"]
        pub fn SparseComplexMatrix_reshape(this:
                                               *const root::SparseComplexMatrix,
                                           new_dims: *const root::dim_vector)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseComplexMatrix_permute(this:
                                               *const root::SparseComplexMatrix,
                                           vec:
                                               *const root::Array<::std::os::raw::c_int>,
                                           inv: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseComplexMatrix_ipermute(this:
                                                *const root::SparseComplexMatrix,
                                            vec:
                                                *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix18any_element_is_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_nan(this:
                                                          *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_inf_or_nan(this:
                                                                 *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix21all_elements_are_realEv"]
        pub fn SparseComplexMatrix_all_elements_are_real(this:
                                                             *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12all_integersERdS0_"]
        pub fn SparseComplexMatrix_all_integers(this:
                                                    *const root::SparseComplexMatrix,
                                                max_val: *mut f64,
                                                min_val: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix19too_large_for_floatEv"]
        pub fn SparseComplexMatrix_too_large_for_float(this:
                                                           *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3allEi"]
        pub fn SparseComplexMatrix_all(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3anyEi"]
        pub fn SparseComplexMatrix_any(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7cumprodEi"]
        pub fn SparseComplexMatrix_cumprod(this:
                                               *const root::SparseComplexMatrix,
                                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix6cumsumEi"]
        pub fn SparseComplexMatrix_cumsum(this:
                                              *const root::SparseComplexMatrix,
                                          dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix4prodEi"]
        pub fn SparseComplexMatrix_prod(this:
                                            *const root::SparseComplexMatrix,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3sumEi"]
        pub fn SparseComplexMatrix_sum(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5sumsqEi"]
        pub fn SparseComplexMatrix_sumsq(this:
                                             *const root::SparseComplexMatrix,
                                         dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3absEv"]
        pub fn SparseComplexMatrix_abs(this: *const root::SparseComplexMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix4diagEi"]
        pub fn SparseComplexMatrix_diag(this:
                                            *const root::SparseComplexMatrix,
                                        k: root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK12SparseMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix(this:
                                                           *mut root::SparseComplexMatrix,
                                                       a:
                                                           *const root::SparseMatrix);
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix1(this:
                                                            *mut root::SparseComplexMatrix,
                                                        a:
                                                            *const root::SparseBoolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix2(this:
                                                            *mut root::SparseComplexMatrix,
                                                        a:
                                                            *const root::ComplexDiagMatrix);
    }
    impl SparseComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            SparseComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseComplexMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::SparseComplexMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert2(self, a, indx)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::SparseMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert3(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseComplexMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::SparseMatrix,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::ComplexMatrix {
            SparseComplexMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_hermitian(self)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            SparseComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcond: *mut f64, force: bool, calc_cond: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse3(self, mattype, info, rcond, force,
                                         calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            SparseComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDET {
            SparseComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcond: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            SparseComplexMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::ComplexMatrix {
            SparseComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve2(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseComplexMatrix_solve3(self, typ, b, info, rcond,
                                       sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve6(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseComplexMatrix_solve7(self, typ, b, info, rcond,
                                       sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix,
                             info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve10(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler,
                              singular_fallback: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve11(self, typ, b, info, rcond,
                                        sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve14(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler,
                              singular_fallback: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve15(self, typ, b, info, rcond,
                                        sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve16(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve16(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve17(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve18(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve19(self, typ, b, info, rcond,
                                        sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve20(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve21(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve22(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve23(self, typ, b, info, rcond,
                                        sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(&self, b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseComplexMatrix {
            SparseComplexMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            SparseComplexMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            SparseComplexMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseComplexMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MatrixType {
        pub typ: root::MatrixType_matrix_type,
        pub sp_bandden: f64,
        pub bandden: f64,
        pub upper_band: root::octave_idx_type,
        pub lower_band: root::octave_idx_type,
        pub dense: bool,
        pub full: bool,
        pub nperm: root::octave_idx_type,
        pub perm: *mut root::octave_idx_type,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum MatrixType_matrix_type {
        Unknown = 0,
        Full = 1,
        Diagonal = 2,
        Permuted_Diagonal = 3,
        Upper = 4,
        Lower = 5,
        Permuted_Upper = 6,
        Permuted_Lower = 7,
        Banded = 8,
        Hermitian = 9,
        Banded_Hermitian = 10,
        Tridiagonal = 11,
        Tridiagonal_Hermitian = 12,
        Rectangular = 13,
    }
    #[test]
    fn bindgen_test_layout_MatrixType() {
        assert_eq!(::std::mem::size_of::<MatrixType>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( MatrixType ) ));
        assert_eq! (::std::mem::align_of::<MatrixType>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( MatrixType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . typ as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( typ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . sp_bandden as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( sp_bandden ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . bandden as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( bandden ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . upper_band as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( upper_band ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . lower_band as *
                    const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( lower_band ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . dense as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( dense ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . full as * const _ as
                    usize } , 33usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( full ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . nperm as * const _
                    as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( nperm ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . perm as * const _ as
                    usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( perm ) ));
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeEb"]
        pub fn MatrixType_type(this: *mut root::MatrixType, quiet: bool)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK6Matrix"]
        pub fn MatrixType_type1(this: *mut root::MatrixType,
                                a: *const root::Matrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK13ComplexMatrix"]
        pub fn MatrixType_type2(this: *mut root::MatrixType,
                                a: *const root::ComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK11FloatMatrix"]
        pub fn MatrixType_type3(this: *mut root::MatrixType,
                                a: *const root::FloatMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK18FloatComplexMatrix"]
        pub fn MatrixType_type4(this: *mut root::MatrixType,
                                a: *const root::FloatComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK12SparseMatrix"]
        pub fn MatrixType_type5(this: *mut root::MatrixType,
                                a: *const root::SparseMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK19SparseComplexMatrix"]
        pub fn MatrixType_type6(this: *mut root::MatrixType,
                                a: *const root::SparseComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK10MatrixType4infoEv"]
        pub fn MatrixType_info(this: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType17mark_as_symmetricEv"]
        pub fn MatrixType_mark_as_symmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType19mark_as_unsymmetricEv"]
        pub fn MatrixType_mark_as_unsymmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType16mark_as_permutedEiPKi"]
        pub fn MatrixType_mark_as_permuted(this: *mut root::MatrixType,
                                           np: root::octave_idx_type,
                                           p: *const root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType18mark_as_unpermutedEv"]
        pub fn MatrixType_mark_as_unpermuted(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZNK10MatrixType9transposeEv"]
        pub fn MatrixType_transpose(this: *const root::MatrixType)
         -> root::MatrixType;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1Ev"]
        pub fn MatrixType_MatrixType(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERKS_"]
        pub fn MatrixType_MatrixType1(this: *mut root::MatrixType,
                                      a: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK6Matrix"]
        pub fn MatrixType_MatrixType2(this: *mut root::MatrixType,
                                      a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK13ComplexMatrix"]
        pub fn MatrixType_MatrixType3(this: *mut root::MatrixType,
                                      a: *const root::ComplexMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK11FloatMatrix"]
        pub fn MatrixType_MatrixType4(this: *mut root::MatrixType,
                                      a: *const root::FloatMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK18FloatComplexMatrix"]
        pub fn MatrixType_MatrixType5(this: *mut root::MatrixType,
                                      a: *const root::FloatComplexMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEb"]
        pub fn MatrixType_MatrixType6(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEiPKib"]
        pub fn MatrixType_MatrixType7(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      np: root::octave_idx_type,
                                      p: *const root::octave_idx_type,
                                      _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEiib"]
        pub fn MatrixType_MatrixType8(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      ku: root::octave_idx_type,
                                      kl: root::octave_idx_type, _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeD1Ev"]
        pub fn MatrixType_MatrixType_destructor(this: *mut root::MatrixType);
    }
    impl MatrixType {
        #[inline]
        pub unsafe fn type_(&mut self, quiet: bool) -> ::std::os::raw::c_int {
            MatrixType_type(self, quiet)
        }
        #[inline]
        pub unsafe fn type1(&mut self, a: *const root::Matrix)
         -> ::std::os::raw::c_int {
            MatrixType_type1(self, a)
        }
        #[inline]
        pub unsafe fn type2(&mut self, a: *const root::ComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type2(self, a)
        }
        #[inline]
        pub unsafe fn type3(&mut self, a: *const root::FloatMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type3(self, a)
        }
        #[inline]
        pub unsafe fn type4(&mut self, a: *const root::FloatComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type4(self, a)
        }
        #[inline]
        pub unsafe fn type5(&mut self, a: *const root::SparseMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type5(self, a)
        }
        #[inline]
        pub unsafe fn type6(&mut self, a: *const root::SparseComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type6(self, a)
        }
        #[inline]
        pub unsafe fn info(&self) { MatrixType_info(self) }
        #[inline]
        pub unsafe fn mark_as_symmetric(&mut self) {
            MatrixType_mark_as_symmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_unsymmetric(&mut self) {
            MatrixType_mark_as_unsymmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_permuted(&mut self, np: root::octave_idx_type,
                                       p: *const root::octave_idx_type) {
            MatrixType_mark_as_permuted(self, np, p)
        }
        #[inline]
        pub unsafe fn mark_as_unpermuted(&mut self) {
            MatrixType_mark_as_unpermuted(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::MatrixType {
            MatrixType_transpose(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::ComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::FloatComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(t: root::MatrixType_matrix_type, _full: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType6(&mut __bindgen_tmp, t, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(t: root::MatrixType_matrix_type,
                           np: root::octave_idx_type,
                           p: *const root::octave_idx_type, _full: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType7(&mut __bindgen_tmp, t, np, p, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(t: root::MatrixType_matrix_type,
                           ku: root::octave_idx_type,
                           kl: root::octave_idx_type, _full: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType8(&mut __bindgen_tmp, t, ku, kl, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            MatrixType_MatrixType_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolMatrix {
        pub _base: root::boolNDArray,
    }
    #[test]
    fn bindgen_test_layout_boolMatrix() {
        assert_eq!(::std::mem::size_of::<boolMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( boolMatrix ) ));
        assert_eq! (::std::mem::align_of::<boolMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( boolMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10boolMatrix6insertERKS_ii"]
        pub fn boolMatrix_insert(this: *mut root::boolMatrix,
                                 a: *const root::boolMatrix,
                                 r: root::octave_idx_type,
                                 c: root::octave_idx_type)
         -> *mut root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10boolMatrix4diagEi"]
        pub fn boolMatrix_diag(this: *const root::boolMatrix,
                               k: root::octave_idx_type) -> root::boolMatrix;
    }
    impl boolMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::boolMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::boolMatrix {
            boolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::boolMatrix {
            boolMatrix_diag(self, k)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charMatrix {
        pub _base: root::charNDArray,
    }
    #[test]
    fn bindgen_test_layout_charMatrix() {
        assert_eq!(::std::mem::size_of::<charMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( charMatrix ) ));
        assert_eq! (::std::mem::align_of::<charMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( charMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10charMatrix6insertEPKcii"]
        pub fn charMatrix_insert(this: *mut root::charMatrix,
                                 s: *const ::std::os::raw::c_char,
                                 r: root::octave_idx_type,
                                 c: root::octave_idx_type)
         -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10charMatrix6insertERKS_ii"]
        pub fn charMatrix_insert1(this: *mut root::charMatrix,
                                  a: *const root::charMatrix,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10charMatrix13row_as_stringEib"]
        pub fn charMatrix_row_as_string(this: *const root::charMatrix,
                                        arg1: root::octave_idx_type,
                                        strip_ws: bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK10charMatrix7extractEiiii"]
        pub fn charMatrix_extract(this: *const root::charMatrix,
                                  r1: root::octave_idx_type,
                                  c1: root::octave_idx_type,
                                  r2: root::octave_idx_type,
                                  c2: root::octave_idx_type)
         -> root::charMatrix;
    }
    impl charMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, s: *const ::std::os::raw::c_char,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::charMatrix {
            charMatrix_insert(self, s, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::charMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::charMatrix {
            charMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn row_as_string(&self, arg1: root::octave_idx_type,
                                    strip_ws: bool) -> root::std::string {
            charMatrix_row_as_string(self, arg1, strip_ws)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::charMatrix {
            charMatrix_extract(self, r1, c1, r2, c2)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct NDArray {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_NDArray() {
        assert_eq!(::std::mem::size_of::<NDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( NDArray ) ));
        assert_eq! (::std::mem::align_of::<NDArray>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( NDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray23any_element_is_negativeEb"]
        pub fn NDArray_any_element_is_negative(this: *const root::NDArray,
                                               arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray23any_element_is_positiveEb"]
        pub fn NDArray_any_element_is_positive(this: *const root::NDArray,
                                               arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray18any_element_is_nanEv"]
        pub fn NDArray_any_element_is_nan(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray25any_element_is_inf_or_nanEv"]
        pub fn NDArray_any_element_is_inf_or_nan(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray27any_element_not_one_or_zeroEv"]
        pub fn NDArray_any_element_not_one_or_zero(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray21all_elements_are_zeroEv"]
        pub fn NDArray_all_elements_are_zero(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn NDArray_all_elements_are_int_or_inf_or_nan(this:
                                                              *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray12all_integersERdS0_"]
        pub fn NDArray_all_integers(this: *const root::NDArray,
                                    max_val: *mut f64, min_val: *mut f64)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray12all_integersEv"]
        pub fn NDArray_all_integers1(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray19too_large_for_floatEv"]
        pub fn NDArray_too_large_for_float(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3allEi"]
        pub fn NDArray_all(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3anyEi"]
        pub fn NDArray_any(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray7cumprodEi"]
        pub fn NDArray_cumprod(this: *const root::NDArray,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumsumEi"]
        pub fn NDArray_cumsum(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4prodEi"]
        pub fn NDArray_prod(this: *const root::NDArray,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3sumEi"]
        pub fn NDArray_sum(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4xsumEi"]
        pub fn NDArray_xsum(this: *const root::NDArray,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5sumsqEi"]
        pub fn NDArray_sumsq(this: *const root::NDArray,
                             dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERKS_RK5ArrayIiE"]
        pub fn NDArray_concat(this: *mut root::NDArray,
                              rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERK14ComplexNDArrayRK5ArrayIiE"]
        pub fn NDArray_concat1(this: *mut root::NDArray,
                               rb: *const root::ComplexNDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERK11charNDArrayRK5ArrayIiE"]
        pub fn NDArray_concat2(this: *mut root::NDArray,
                               rb: *const root::charNDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3maxEi"]
        pub fn NDArray_max(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3maxER5ArrayIiEi"]
        pub fn NDArray_max1(this: *const root::NDArray,
                            index: *mut root::Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3minEi"]
        pub fn NDArray_min(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3minER5ArrayIiEi"]
        pub fn NDArray_min1(this: *const root::NDArray,
                            index: *mut root::Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cummaxEi"]
        pub fn NDArray_cummax(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cummaxER5ArrayIiEi"]
        pub fn NDArray_cummax1(this: *const root::NDArray,
                               index: *mut root::Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumminEi"]
        pub fn NDArray_cummin(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumminER5ArrayIiEi"]
        pub fn NDArray_cummin1(this: *const root::NDArray,
                               index: *mut root::Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diffEii"]
        pub fn NDArray_diff(this: *const root::NDArray,
                            order: root::octave_idx_type,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6insertERKS_ii"]
        pub fn NDArray_insert(this: *mut root::NDArray,
                              a: *const root::NDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6insertERKS_RK5ArrayIiE"]
        pub fn NDArray_insert1(this: *mut root::NDArray,
                               a: *const root::NDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3absEv"]
        pub fn NDArray_abs(this: *const root::NDArray) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5isnanEv"]
        pub fn NDArray_isnan(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5isinfEv"]
        pub fn NDArray_isinf(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray8isfiniteEv"]
        pub fn NDArray_isfinite(this: *const root::NDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray7fourierEi"]
        pub fn NDArray_fourier(this: *const root::NDArray,
                               dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray8ifourierEi"]
        pub fn NDArray_ifourier(this: *const root::NDArray,
                                dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray9fourier2dEv"]
        pub fn NDArray_fourier2d(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray10ifourier2dEv"]
        pub fn NDArray_ifourier2d(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray9fourierNdEv"]
        pub fn NDArray_fourierNd(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray10ifourierNdEv"]
        pub fn NDArray_ifourierNd(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN7NDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn NDArray_increment_index(ra_idx:
                                           *mut root::Array<::std::os::raw::c_int>,
                                       dimensions: *const root::dim_vector,
                                       start_dimension:
                                           ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "_ZN7NDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn NDArray_compute_index(ra_idx:
                                         *mut root::Array<::std::os::raw::c_int>,
                                     dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diagEi"]
        pub fn NDArray_diag(this: *const root::NDArray,
                            k: root::octave_idx_type) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diagEii"]
        pub fn NDArray_diag1(this: *const root::NDArray,
                             m: root::octave_idx_type,
                             n: root::octave_idx_type) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArrayC1ERK5ArrayIiEbb"]
        pub fn NDArray_NDArray(this: *mut root::NDArray,
                               a: *const root::Array<::std::os::raw::c_int>,
                               zero_based: bool, negative_to_nan: bool);
    }
    extern "C" {
        #[link_name = "_ZN7NDArrayC1ERK11charNDArray"]
        pub fn NDArray_NDArray1(this: *mut root::NDArray,
                                arg1: *const root::charNDArray);
    }
    impl NDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            NDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            NDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            NDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            NDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            NDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            NDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            NDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            NDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            NDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            NDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            NDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            NDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::NDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::NDArray {
            NDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::ComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            NDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(&mut self, rb: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            NDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::NDArray {
            NDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::NDArray {
            NDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray { NDArray_abs(self) }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            NDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            NDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            NDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            NDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            NDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            NDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            NDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            NDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            NDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            NDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            NDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::NDArray {
            NDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::NDArray {
            NDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(a: *const root::Array<::std::os::raw::c_int>,
                          zero_based: bool, negative_to_nan: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            NDArray_NDArray(&mut __bindgen_tmp, a, zero_based,
                            negative_to_nan);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            NDArray_NDArray1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexNDArray {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexNDArray() {
        assert_eq!(::std::mem::size_of::<ComplexNDArray>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( ComplexNDArray ) ));
        assert_eq! (::std::mem::align_of::<ComplexNDArray>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( ComplexNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray18any_element_is_nanEv"]
        pub fn ComplexNDArray_any_element_is_nan(this:
                                                     *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn ComplexNDArray_any_element_is_inf_or_nan(this:
                                                            *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray21all_elements_are_realEv"]
        pub fn ComplexNDArray_all_elements_are_real(this:
                                                        *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray12all_integersERdS0_"]
        pub fn ComplexNDArray_all_integers(this: *const root::ComplexNDArray,
                                           max_val: *mut f64,
                                           min_val: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray19too_large_for_floatEv"]
        pub fn ComplexNDArray_too_large_for_float(this:
                                                      *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3allEi"]
        pub fn ComplexNDArray_all(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3anyEi"]
        pub fn ComplexNDArray_any(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray7cumprodEi"]
        pub fn ComplexNDArray_cumprod(this: *const root::ComplexNDArray,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumsumEi"]
        pub fn ComplexNDArray_cumsum(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4prodEi"]
        pub fn ComplexNDArray_prod(this: *const root::ComplexNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3sumEi"]
        pub fn ComplexNDArray_sum(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4xsumEi"]
        pub fn ComplexNDArray_xsum(this: *const root::ComplexNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5sumsqEi"]
        pub fn ComplexNDArray_sumsq(this: *const root::ComplexNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6concatERKS_RK5ArrayIiE"]
        pub fn ComplexNDArray_concat(this: *mut root::ComplexNDArray,
                                     rb: *const root::ComplexNDArray,
                                     ra_idx:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6concatERK7NDArrayRK5ArrayIiE"]
        pub fn ComplexNDArray_concat1(this: *mut root::ComplexNDArray,
                                      rb: *const root::NDArray,
                                      ra_idx:
                                          *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3maxEi"]
        pub fn ComplexNDArray_max(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3maxER5ArrayIiEi"]
        pub fn ComplexNDArray_max1(this: *const root::ComplexNDArray,
                                   index:
                                       *mut root::Array<::std::os::raw::c_int>,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3minEi"]
        pub fn ComplexNDArray_min(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3minER5ArrayIiEi"]
        pub fn ComplexNDArray_min1(this: *const root::ComplexNDArray,
                                   index:
                                       *mut root::Array<::std::os::raw::c_int>,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cummaxEi"]
        pub fn ComplexNDArray_cummax(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cummaxER5ArrayIiEi"]
        pub fn ComplexNDArray_cummax1(this: *const root::ComplexNDArray,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumminEi"]
        pub fn ComplexNDArray_cummin(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumminER5ArrayIiEi"]
        pub fn ComplexNDArray_cummin1(this: *const root::ComplexNDArray,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diffEii"]
        pub fn ComplexNDArray_diff(this: *const root::ComplexNDArray,
                                   order: root::octave_idx_type,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERK7NDArrayii"]
        pub fn ComplexNDArray_insert(this: *mut root::ComplexNDArray,
                                     a: *const root::NDArray,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERKS_ii"]
        pub fn ComplexNDArray_insert1(this: *mut root::ComplexNDArray,
                                      a: *const root::ComplexNDArray,
                                      r: root::octave_idx_type,
                                      c: root::octave_idx_type)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERKS_RK5ArrayIiE"]
        pub fn ComplexNDArray_insert2(this: *mut root::ComplexNDArray,
                                      a: *const root::ComplexNDArray,
                                      ra_idx:
                                          *const root::Array<::std::os::raw::c_int>)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3absEv"]
        pub fn ComplexNDArray_abs(this: *const root::ComplexNDArray)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5isnanEv"]
        pub fn ComplexNDArray_isnan(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5isinfEv"]
        pub fn ComplexNDArray_isinf(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray8isfiniteEv"]
        pub fn ComplexNDArray_isfinite(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray7fourierEi"]
        pub fn ComplexNDArray_fourier(this: *const root::ComplexNDArray,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray8ifourierEi"]
        pub fn ComplexNDArray_ifourier(this: *const root::ComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray9fourier2dEv"]
        pub fn ComplexNDArray_fourier2d(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray10ifourier2dEv"]
        pub fn ComplexNDArray_ifourier2d(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray9fourierNdEv"]
        pub fn ComplexNDArray_fourierNd(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray10ifourierNdEv"]
        pub fn ComplexNDArray_ifourierNd(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN14ComplexNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn ComplexNDArray_increment_index(ra_idx:
                                                  *mut root::Array<::std::os::raw::c_int>,
                                              dimensions:
                                                  *const root::dim_vector,
                                              start_dimension:
                                                  ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN14ComplexNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn ComplexNDArray_compute_index(ra_idx:
                                                *mut root::Array<::std::os::raw::c_int>,
                                            dimensions:
                                                *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diagEi"]
        pub fn ComplexNDArray_diag(this: *const root::ComplexNDArray,
                                   k: root::octave_idx_type)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diagEii"]
        pub fn ComplexNDArray_diag1(this: *const root::ComplexNDArray,
                                    m: root::octave_idx_type,
                                    n: root::octave_idx_type)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArrayC1ERK11charNDArray"]
        pub fn ComplexNDArray_ComplexNDArray(this: *mut root::ComplexNDArray,
                                             arg1: *const root::charNDArray);
    }
    impl ComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            ComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            ComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            ComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            ComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            ComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            ComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::ComplexNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            ComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            ComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexNDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray { ComplexNDArray_abs(self) }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            ComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            ComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            ComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            ComplexNDArray_increment_index(ra_idx, dimensions,
                                           start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            ComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::ComplexNDArray {
            ComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::ComplexNDArray {
            ComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexNDArray_ComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatNDArray {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatNDArray() {
        assert_eq!(::std::mem::size_of::<FloatNDArray>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( FloatNDArray ) ));
        assert_eq! (::std::mem::align_of::<FloatNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( FloatNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray23any_element_is_negativeEb"]
        pub fn FloatNDArray_any_element_is_negative(this:
                                                        *const root::FloatNDArray,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray23any_element_is_positiveEb"]
        pub fn FloatNDArray_any_element_is_positive(this:
                                                        *const root::FloatNDArray,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray18any_element_is_nanEv"]
        pub fn FloatNDArray_any_element_is_nan(this:
                                                   *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatNDArray_any_element_is_inf_or_nan(this:
                                                          *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray27any_element_not_one_or_zeroEv"]
        pub fn FloatNDArray_any_element_not_one_or_zero(this:
                                                            *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray21all_elements_are_zeroEv"]
        pub fn FloatNDArray_all_elements_are_zero(this:
                                                      *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK12FloatNDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn FloatNDArray_all_elements_are_int_or_inf_or_nan(this:
                                                                   *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray12all_integersERfS0_"]
        pub fn FloatNDArray_all_integers(this: *const root::FloatNDArray,
                                         max_val: *mut f32, min_val: *mut f32)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray12all_integersEv"]
        pub fn FloatNDArray_all_integers1(this: *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray19too_large_for_floatEv"]
        pub fn FloatNDArray_too_large_for_float(this:
                                                    *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3allEi"]
        pub fn FloatNDArray_all(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3anyEi"]
        pub fn FloatNDArray_any(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray7cumprodEi"]
        pub fn FloatNDArray_cumprod(this: *const root::FloatNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumsumEi"]
        pub fn FloatNDArray_cumsum(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4prodEi"]
        pub fn FloatNDArray_prod(this: *const root::FloatNDArray,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5dprodEi"]
        pub fn FloatNDArray_dprod(this: *const root::FloatNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3sumEi"]
        pub fn FloatNDArray_sum(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4dsumEi"]
        pub fn FloatNDArray_dsum(this: *const root::FloatNDArray,
                                 dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5sumsqEi"]
        pub fn FloatNDArray_sumsq(this: *const root::FloatNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6concatERKS_RK5ArrayIiE"]
        pub fn FloatNDArray_concat(this: *mut root::FloatNDArray,
                                   rb: *const root::FloatNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray6concatERK19FloatComplexNDArrayRK5ArrayIiE"]
        pub fn FloatNDArray_concat1(this: *mut root::FloatNDArray,
                                    rb: *const root::FloatComplexNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6concatERK11charNDArrayRK5ArrayIiE"]
        pub fn FloatNDArray_concat2(this: *mut root::FloatNDArray,
                                    rb: *const root::charNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3maxEi"]
        pub fn FloatNDArray_max(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3maxER5ArrayIiEi"]
        pub fn FloatNDArray_max1(this: *const root::FloatNDArray,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3minEi"]
        pub fn FloatNDArray_min(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3minER5ArrayIiEi"]
        pub fn FloatNDArray_min1(this: *const root::FloatNDArray,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cummaxEi"]
        pub fn FloatNDArray_cummax(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cummaxER5ArrayIiEi"]
        pub fn FloatNDArray_cummax1(this: *const root::FloatNDArray,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumminEi"]
        pub fn FloatNDArray_cummin(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumminER5ArrayIiEi"]
        pub fn FloatNDArray_cummin1(this: *const root::FloatNDArray,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diffEii"]
        pub fn FloatNDArray_diff(this: *const root::FloatNDArray,
                                 order: root::octave_idx_type,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6insertERKS_ii"]
        pub fn FloatNDArray_insert(this: *mut root::FloatNDArray,
                                   a: *const root::FloatNDArray,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6insertERKS_RK5ArrayIiE"]
        pub fn FloatNDArray_insert1(this: *mut root::FloatNDArray,
                                    a: *const root::FloatNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3absEv"]
        pub fn FloatNDArray_abs(this: *const root::FloatNDArray)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5isnanEv"]
        pub fn FloatNDArray_isnan(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5isinfEv"]
        pub fn FloatNDArray_isinf(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray8isfiniteEv"]
        pub fn FloatNDArray_isfinite(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray7fourierEi"]
        pub fn FloatNDArray_fourier(this: *const root::FloatNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray8ifourierEi"]
        pub fn FloatNDArray_ifourier(this: *const root::FloatNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray9fourier2dEv"]
        pub fn FloatNDArray_fourier2d(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray10ifourier2dEv"]
        pub fn FloatNDArray_ifourier2d(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray9fourierNdEv"]
        pub fn FloatNDArray_fourierNd(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray10ifourierNdEv"]
        pub fn FloatNDArray_ifourierNd(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn FloatNDArray_increment_index(ra_idx:
                                                *mut root::Array<::std::os::raw::c_int>,
                                            dimensions:
                                                *const root::dim_vector,
                                            start_dimension:
                                                ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn FloatNDArray_compute_index(ra_idx:
                                              *mut root::Array<::std::os::raw::c_int>,
                                          dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diagEi"]
        pub fn FloatNDArray_diag(this: *const root::FloatNDArray,
                                 k: root::octave_idx_type)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diagEii"]
        pub fn FloatNDArray_diag1(this: *const root::FloatNDArray,
                                  m: root::octave_idx_type,
                                  n: root::octave_idx_type)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArrayC1ERK11charNDArray"]
        pub fn FloatNDArray_FloatNDArray(this: *mut root::FloatNDArray,
                                         arg1: *const root::charNDArray);
    }
    impl FloatNDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            FloatNDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            FloatNDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            FloatNDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32,
                                   min_val: *mut f32) -> bool {
            FloatNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            FloatNDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            FloatNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            FloatNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::FloatNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::FloatNDArray {
            FloatNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::FloatComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(&mut self, rb: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            FloatNDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatNDArray {
            FloatNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatNDArray {
            FloatNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            FloatNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            FloatNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatNDArray {
            FloatNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::FloatNDArray {
            FloatNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatNDArray_FloatNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexNDArray {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexNDArray() {
        assert_eq!(::std::mem::size_of::<FloatComplexNDArray>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexNDArray ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexNDArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray18any_element_is_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_nan(this:
                                                          *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK19FloatComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_inf_or_nan(this:
                                                                 *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray21all_elements_are_realEv"]
        pub fn FloatComplexNDArray_all_elements_are_real(this:
                                                             *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray12all_integersERfS0_"]
        pub fn FloatComplexNDArray_all_integers(this:
                                                    *const root::FloatComplexNDArray,
                                                max_val: *mut f32,
                                                min_val: *mut f32) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray19too_large_for_floatEv"]
        pub fn FloatComplexNDArray_too_large_for_float(this:
                                                           *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3allEi"]
        pub fn FloatComplexNDArray_all(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3anyEi"]
        pub fn FloatComplexNDArray_any(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray7cumprodEi"]
        pub fn FloatComplexNDArray_cumprod(this:
                                               *const root::FloatComplexNDArray,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumsumEi"]
        pub fn FloatComplexNDArray_cumsum(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4prodEi"]
        pub fn FloatComplexNDArray_prod(this:
                                            *const root::FloatComplexNDArray,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5dprodEi"]
        pub fn FloatComplexNDArray_dprod(this:
                                             *const root::FloatComplexNDArray,
                                         dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3sumEi"]
        pub fn FloatComplexNDArray_sum(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4dsumEi"]
        pub fn FloatComplexNDArray_dsum(this:
                                            *const root::FloatComplexNDArray,
                                        dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5sumsqEi"]
        pub fn FloatComplexNDArray_sumsq(this:
                                             *const root::FloatComplexNDArray,
                                         dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6concatERKS_RK5ArrayIiE"]
        pub fn FloatComplexNDArray_concat(this:
                                              *mut root::FloatComplexNDArray,
                                          rb:
                                              *const root::FloatComplexNDArray,
                                          ra_idx:
                                              *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray6concatERK12FloatNDArrayRK5ArrayIiE"]
        pub fn FloatComplexNDArray_concat1(this:
                                               *mut root::FloatComplexNDArray,
                                           rb: *const root::FloatNDArray,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3maxEi"]
        pub fn FloatComplexNDArray_max(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3maxER5ArrayIiEi"]
        pub fn FloatComplexNDArray_max1(this:
                                            *const root::FloatComplexNDArray,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3minEi"]
        pub fn FloatComplexNDArray_min(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3minER5ArrayIiEi"]
        pub fn FloatComplexNDArray_min1(this:
                                            *const root::FloatComplexNDArray,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cummaxEi"]
        pub fn FloatComplexNDArray_cummax(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cummaxER5ArrayIiEi"]
        pub fn FloatComplexNDArray_cummax1(this:
                                               *const root::FloatComplexNDArray,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumminEi"]
        pub fn FloatComplexNDArray_cummin(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumminER5ArrayIiEi"]
        pub fn FloatComplexNDArray_cummin1(this:
                                               *const root::FloatComplexNDArray,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diffEii"]
        pub fn FloatComplexNDArray_diff(this:
                                            *const root::FloatComplexNDArray,
                                        order: root::octave_idx_type,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERK7NDArrayii"]
        pub fn FloatComplexNDArray_insert(this:
                                              *mut root::FloatComplexNDArray,
                                          a: *const root::NDArray,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERKS_ii"]
        pub fn FloatComplexNDArray_insert1(this:
                                               *mut root::FloatComplexNDArray,
                                           a:
                                               *const root::FloatComplexNDArray,
                                           r: root::octave_idx_type,
                                           c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERKS_RK5ArrayIiE"]
        pub fn FloatComplexNDArray_insert2(this:
                                               *mut root::FloatComplexNDArray,
                                           a:
                                               *const root::FloatComplexNDArray,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3absEv"]
        pub fn FloatComplexNDArray_abs(this: *const root::FloatComplexNDArray)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5isnanEv"]
        pub fn FloatComplexNDArray_isnan(this:
                                             *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5isinfEv"]
        pub fn FloatComplexNDArray_isinf(this:
                                             *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray8isfiniteEv"]
        pub fn FloatComplexNDArray_isfinite(this:
                                                *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray7fourierEi"]
        pub fn FloatComplexNDArray_fourier(this:
                                               *const root::FloatComplexNDArray,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray8ifourierEi"]
        pub fn FloatComplexNDArray_ifourier(this:
                                                *const root::FloatComplexNDArray,
                                            dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray9fourier2dEv"]
        pub fn FloatComplexNDArray_fourier2d(this:
                                                 *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray10ifourier2dEv"]
        pub fn FloatComplexNDArray_ifourier2d(this:
                                                  *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray9fourierNdEv"]
        pub fn FloatComplexNDArray_fourierNd(this:
                                                 *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray10ifourierNdEv"]
        pub fn FloatComplexNDArray_ifourierNd(this:
                                                  *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn FloatComplexNDArray_increment_index(ra_idx:
                                                       *mut root::Array<::std::os::raw::c_int>,
                                                   dimensions:
                                                       *const root::dim_vector,
                                                   start_dimension:
                                                       ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn FloatComplexNDArray_compute_index(ra_idx:
                                                     *mut root::Array<::std::os::raw::c_int>,
                                                 dimensions:
                                                     *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diagEi"]
        pub fn FloatComplexNDArray_diag(this:
                                            *const root::FloatComplexNDArray,
                                        k: root::octave_idx_type)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diagEii"]
        pub fn FloatComplexNDArray_diag1(this:
                                             *const root::FloatComplexNDArray,
                                         m: root::octave_idx_type,
                                         n: root::octave_idx_type)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArrayC1ERK11charNDArray"]
        pub fn FloatComplexNDArray_FloatComplexNDArray(this:
                                                           *mut root::FloatComplexNDArray,
                                                       arg1:
                                                           *const root::charNDArray);
    }
    impl FloatComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32,
                                   min_val: *mut f32) -> bool {
            FloatComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            FloatComplexNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            FloatComplexNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::FloatComplexNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::FloatNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatComplexNDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatComplexNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            FloatComplexNDArray_increment_index(ra_idx, dimensions,
                                                start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            FloatComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexNDArray_FloatComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolNDArray {
        pub _base: root::Array<bool>,
    }
    pub type boolNDArray_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_boolNDArray() {
        assert_eq!(::std::mem::size_of::<boolNDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( boolNDArray ) ));
        assert_eq! (::std::mem::align_of::<boolNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( boolNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6invertEv"]
        pub fn boolNDArray_invert(this: *mut root::boolNDArray)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3allEi"]
        pub fn boolNDArray_all(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3anyEi"]
        pub fn boolNDArray_any(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3sumEi"]
        pub fn boolNDArray_sum(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray6cumsumEi"]
        pub fn boolNDArray_cumsum(this: *const root::boolNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6concatERKS_RK5ArrayIiE"]
        pub fn boolNDArray_concat(this: *mut root::boolNDArray,
                                  rb: *const root::boolNDArray,
                                  ra_idx:
                                      *const root::Array<::std::os::raw::c_int>)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6insertERKS_ii"]
        pub fn boolNDArray_insert(this: *mut root::boolNDArray,
                                  a: *const root::boolNDArray,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6insertERKS_RK5ArrayIiE"]
        pub fn boolNDArray_insert1(this: *mut root::boolNDArray,
                                   a: *const root::boolNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN11boolNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn boolNDArray_increment_index(ra_idx:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dimensions:
                                               *const root::dim_vector,
                                           start_dimension:
                                               ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN11boolNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn boolNDArray_compute_index(ra_idx:
                                             *mut root::Array<::std::os::raw::c_int>,
                                         dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray4diagEi"]
        pub fn boolNDArray_diag(this: *const root::boolNDArray,
                                k: root::octave_idx_type)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray4diagEii"]
        pub fn boolNDArray_diag1(this: *const root::boolNDArray,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::boolNDArray;
    }
    impl boolNDArray {
        #[inline]
        pub unsafe fn invert(&mut self) -> *mut root::boolNDArray {
            boolNDArray_invert(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            boolNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            boolNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            boolNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            boolNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::boolNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::boolNDArray {
            boolNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::boolNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::boolNDArray {
            boolNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::boolNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::boolNDArray {
            boolNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            boolNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            boolNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::boolNDArray {
            boolNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::boolNDArray {
            boolNDArray_diag1(self, m, n)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charNDArray {
        pub _base: root::Array<::std::os::raw::c_char>,
    }
    pub type charNDArray_matrix_type = root::charMatrix;
    #[test]
    fn bindgen_test_layout_charNDArray() {
        assert_eq!(::std::mem::size_of::<charNDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( charNDArray ) ));
        assert_eq! (::std::mem::align_of::<charNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( charNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3allEi"]
        pub fn charNDArray_all(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3anyEi"]
        pub fn charNDArray_any(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6concatERKS_RK5ArrayIiE"]
        pub fn charNDArray_concat(this: *mut root::charNDArray,
                                  rb: *const root::charNDArray,
                                  ra_idx:
                                      *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6concatERK7NDArrayRK5ArrayIiE"]
        pub fn charNDArray_concat1(this: *mut root::charNDArray,
                                   rb: *const root::NDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3maxEi"]
        pub fn charNDArray_max(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3maxER5ArrayIiEi"]
        pub fn charNDArray_max1(this: *const root::charNDArray,
                                index:
                                    *mut root::Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3minEi"]
        pub fn charNDArray_min(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3minER5ArrayIiEi"]
        pub fn charNDArray_min1(this: *const root::charNDArray,
                                index:
                                    *mut root::Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6insertERKS_ii"]
        pub fn charNDArray_insert(this: *mut root::charNDArray,
                                  a: *const root::charNDArray,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6insertERKS_RK5ArrayIiE"]
        pub fn charNDArray_insert1(this: *mut root::charNDArray,
                                   a: *const root::charNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN11charNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn charNDArray_increment_index(ra_idx:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dimensions:
                                               *const root::dim_vector,
                                           start_dimension:
                                               ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN11charNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn charNDArray_compute_index(ra_idx:
                                             *mut root::Array<::std::os::raw::c_int>,
                                         dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray4diagEi"]
        pub fn charNDArray_diag(this: *const root::charNDArray,
                                k: root::octave_idx_type)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray4diagEii"]
        pub fn charNDArray_diag1(this: *const root::charNDArray,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1Ec"]
        pub fn charNDArray_charNDArray(this: *mut root::charNDArray,
                                       c: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1EPKc"]
        pub fn charNDArray_charNDArray1(this: *mut root::charNDArray,
                                        s: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1ERKSs"]
        pub fn charNDArray_charNDArray2(this: *mut root::charNDArray,
                                        s: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1ERK13string_vectorc"]
        pub fn charNDArray_charNDArray3(this: *mut root::charNDArray,
                                        s: *const root::string_vector,
                                        fill_value: ::std::os::raw::c_char);
    }
    impl charNDArray {
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            charNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            charNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::charNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            charNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            charNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::charNDArray {
            charNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::charNDArray {
            charNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::charNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::charNDArray {
            charNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::charNDArray {
            charNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            charNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            charNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::charNDArray {
            charNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::charNDArray {
            charNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(s: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray1(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(s: *const root::std::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray2(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(s: *const root::string_vector,
                           fill_value: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray3(&mut __bindgen_tmp, s, fill_value);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ColumnVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_ColumnVector() {
        assert_eq!(::std::mem::size_of::<ColumnVector>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( ColumnVector ) ));
        assert_eq! (::std::mem::align_of::<ColumnVector>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( ColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector6insertERKS_i"]
        pub fn ColumnVector_insert(this: *mut root::ColumnVector,
                                   a: *const root::ColumnVector,
                                   r: root::octave_idx_type)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector4fillEd"]
        pub fn ColumnVector_fill(this: *mut root::ColumnVector, val: f64)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector4fillEdii"]
        pub fn ColumnVector_fill1(this: *mut root::ColumnVector, val: f64,
                                  r1: root::octave_idx_type,
                                  r2: root::octave_idx_type)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector5stackERKS_"]
        pub fn ColumnVector_stack(this: *const root::ColumnVector,
                                  a: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector9transposeEv"]
        pub fn ColumnVector_transpose(this: *const root::ColumnVector)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector7extractEii"]
        pub fn ColumnVector_extract(this: *const root::ColumnVector,
                                    r1: root::octave_idx_type,
                                    r2: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector9extract_nEii"]
        pub fn ColumnVector_extract_n(this: *const root::ColumnVector,
                                      r1: root::octave_idx_type,
                                      n: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3minEv"]
        pub fn ColumnVector_min(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3maxEv"]
        pub fn ColumnVector_max(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3absEv"]
        pub fn ColumnVector_abs(this: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    impl ColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::ColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::ColumnVector {
            ColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ColumnVector {
            ColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ColumnVector {
            ColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector)
         -> root::ColumnVector {
            ColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::RowVector {
            ColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::ColumnVector {
            ColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ColumnVector {
            ColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { ColumnVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { ColumnVector_max(self) }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexColumnVector {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexColumnVector() {
        assert_eq!(::std::mem::size_of::<ComplexColumnVector>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( ComplexColumnVector ) ));
        assert_eq! (::std::mem::align_of::<ComplexColumnVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector6insertERK12ColumnVectori"]
        pub fn ComplexColumnVector_insert(this:
                                              *mut root::ComplexColumnVector,
                                          a: *const root::ColumnVector,
                                          r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector6insertERKS_i"]
        pub fn ComplexColumnVector_insert1(this:
                                               *mut root::ComplexColumnVector,
                                           a:
                                               *const root::ComplexColumnVector,
                                           r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillEd"]
        pub fn ComplexColumnVector_fill(this: *mut root::ComplexColumnVector,
                                        val: f64)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillERKSt7complexIdE"]
        pub fn ComplexColumnVector_fill1(this: *mut root::ComplexColumnVector,
                                         val: *const root::Complex)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillEdii"]
        pub fn ComplexColumnVector_fill2(this: *mut root::ComplexColumnVector,
                                         val: f64, r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillERKSt7complexIdEii"]
        pub fn ComplexColumnVector_fill3(this: *mut root::ComplexColumnVector,
                                         val: *const root::Complex,
                                         r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector5stackERK12ColumnVector"]
        pub fn ComplexColumnVector_stack(this:
                                             *const root::ComplexColumnVector,
                                         a: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector5stackERKS_"]
        pub fn ComplexColumnVector_stack1(this:
                                              *const root::ComplexColumnVector,
                                          a: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9hermitianEv"]
        pub fn ComplexColumnVector_hermitian(this:
                                                 *const root::ComplexColumnVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9transposeEv"]
        pub fn ComplexColumnVector_transpose(this:
                                                 *const root::ComplexColumnVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector7extractEii"]
        pub fn ComplexColumnVector_extract(this:
                                               *const root::ComplexColumnVector,
                                           r1: root::octave_idx_type,
                                           r2: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9extract_nEii"]
        pub fn ComplexColumnVector_extract_n(this:
                                                 *const root::ComplexColumnVector,
                                             r1: root::octave_idx_type,
                                             n: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3minEv"]
        pub fn ComplexColumnVector_min(this: *const root::ComplexColumnVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3maxEv"]
        pub fn ComplexColumnVector_max(this: *const root::ComplexColumnVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3absEv"]
        pub fn ComplexColumnVector_abs(this: *const root::ComplexColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVectorC1ERK12ColumnVector"]
        pub fn ComplexColumnVector_ComplexColumnVector(this:
                                                           *mut root::ComplexColumnVector,
                                                       a:
                                                           *const root::ColumnVector);
    }
    impl ComplexColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::ColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexColumnVector,
                              r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexRowVector {
            ComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexRowVector {
            ComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexColumnVector_ComplexColumnVector(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatColumnVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatColumnVector() {
        assert_eq!(::std::mem::size_of::<FloatColumnVector>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( FloatColumnVector )
                   ));
        assert_eq! (::std::mem::align_of::<FloatColumnVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector6insertERKS_i"]
        pub fn FloatColumnVector_insert(this: *mut root::FloatColumnVector,
                                        a: *const root::FloatColumnVector,
                                        r: root::octave_idx_type)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector4fillEf"]
        pub fn FloatColumnVector_fill(this: *mut root::FloatColumnVector,
                                      val: f32)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector4fillEfii"]
        pub fn FloatColumnVector_fill1(this: *mut root::FloatColumnVector,
                                       val: f32, r1: root::octave_idx_type,
                                       r2: root::octave_idx_type)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector5stackERKS_"]
        pub fn FloatColumnVector_stack(this: *const root::FloatColumnVector,
                                       a: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector9transposeEv"]
        pub fn FloatColumnVector_transpose(this:
                                               *const root::FloatColumnVector)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector7extractEii"]
        pub fn FloatColumnVector_extract(this: *const root::FloatColumnVector,
                                         r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector9extract_nEii"]
        pub fn FloatColumnVector_extract_n(this:
                                               *const root::FloatColumnVector,
                                           r1: root::octave_idx_type,
                                           n: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3minEv"]
        pub fn FloatColumnVector_min(this: *const root::FloatColumnVector)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3maxEv"]
        pub fn FloatColumnVector_max(this: *const root::FloatColumnVector)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3absEv"]
        pub fn FloatColumnVector_abs(this: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    impl FloatColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatRowVector {
            FloatColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 { FloatColumnVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f32 { FloatColumnVector_max(self) }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexColumnVector {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexColumnVector() {
        assert_eq!(::std::mem::size_of::<FloatComplexColumnVector>() , 40usize
                   , concat ! (
                   "Size of: " , stringify ! ( FloatComplexColumnVector ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexColumnVector>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( FloatComplexColumnVector )
                    ));
    }
    extern "C" {
        #[link_name =
              "_ZN24FloatComplexColumnVector6insertERK17FloatColumnVectori"]
        pub fn FloatComplexColumnVector_insert(this:
                                                   *mut root::FloatComplexColumnVector,
                                               a:
                                                   *const root::FloatColumnVector,
                                               r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector6insertERKS_i"]
        pub fn FloatComplexColumnVector_insert1(this:
                                                    *mut root::FloatComplexColumnVector,
                                                a:
                                                    *const root::FloatComplexColumnVector,
                                                r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillEf"]
        pub fn FloatComplexColumnVector_fill(this:
                                                 *mut root::FloatComplexColumnVector,
                                             val: f32)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillERKSt7complexIfE"]
        pub fn FloatComplexColumnVector_fill1(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: *const root::FloatComplex)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillEfii"]
        pub fn FloatComplexColumnVector_fill2(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: f32,
                                              r1: root::octave_idx_type,
                                              r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillERKSt7complexIfEii"]
        pub fn FloatComplexColumnVector_fill3(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: *const root::FloatComplex,
                                              r1: root::octave_idx_type,
                                              r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK24FloatComplexColumnVector5stackERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_stack(this:
                                                  *const root::FloatComplexColumnVector,
                                              a:
                                                  *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector5stackERKS_"]
        pub fn FloatComplexColumnVector_stack1(this:
                                                   *const root::FloatComplexColumnVector,
                                               a:
                                                   *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9hermitianEv"]
        pub fn FloatComplexColumnVector_hermitian(this:
                                                      *const root::FloatComplexColumnVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9transposeEv"]
        pub fn FloatComplexColumnVector_transpose(this:
                                                      *const root::FloatComplexColumnVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector7extractEii"]
        pub fn FloatComplexColumnVector_extract(this:
                                                    *const root::FloatComplexColumnVector,
                                                r1: root::octave_idx_type,
                                                r2: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9extract_nEii"]
        pub fn FloatComplexColumnVector_extract_n(this:
                                                      *const root::FloatComplexColumnVector,
                                                  r1: root::octave_idx_type,
                                                  n: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3minEv"]
        pub fn FloatComplexColumnVector_min(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3maxEv"]
        pub fn FloatComplexColumnVector_max(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3absEv"]
        pub fn FloatComplexColumnVector_abs(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVectorC1ERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_FloatComplexColumnVector(this:
                                                                     *mut root::FloatComplexColumnVector,
                                                                 a:
                                                                     *const root::FloatColumnVector);
    }
    impl FloatComplexColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(&mut self,
                              a: *const root::FloatComplexColumnVector,
                              r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexColumnVector_FloatComplexColumnVector(&mut __bindgen_tmp,
                                                              a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RowVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_RowVector() {
        assert_eq!(::std::mem::size_of::<RowVector>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( RowVector ) ));
        assert_eq! (::std::mem::align_of::<RowVector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( RowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN9RowVector6insertERKS_i"]
        pub fn RowVector_insert(this: *mut root::RowVector,
                                a: *const root::RowVector,
                                c: root::octave_idx_type)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN9RowVector4fillEd"]
        pub fn RowVector_fill(this: *mut root::RowVector, val: f64)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN9RowVector4fillEdii"]
        pub fn RowVector_fill1(this: *mut root::RowVector, val: f64,
                               c1: root::octave_idx_type,
                               c2: root::octave_idx_type)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector6appendERKS_"]
        pub fn RowVector_append(this: *const root::RowVector,
                                a: *const root::RowVector) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector9transposeEv"]
        pub fn RowVector_transpose(this: *const root::RowVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector7extractEii"]
        pub fn RowVector_extract(this: *const root::RowVector,
                                 c1: root::octave_idx_type,
                                 c2: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector9extract_nEii"]
        pub fn RowVector_extract_n(this: *const root::RowVector,
                                   c1: root::octave_idx_type,
                                   n: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector3minEv"]
        pub fn RowVector_min(this: *const root::RowVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector3maxEv"]
        pub fn RowVector_max(this: *const root::RowVector) -> f64;
    }
    impl RowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::RowVector,
                             c: root::octave_idx_type)
         -> *mut root::RowVector {
            RowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::RowVector {
            RowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::RowVector {
            RowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector)
         -> root::RowVector {
            RowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ColumnVector {
            RowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::RowVector {
            RowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type) -> root::RowVector {
            RowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { RowVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { RowVector_max(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexRowVector {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexRowVector() {
        assert_eq!(::std::mem::size_of::<ComplexRowVector>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( ComplexRowVector )
                   ));
        assert_eq! (::std::mem::align_of::<ComplexRowVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexRowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector6insertERK9RowVectori"]
        pub fn ComplexRowVector_insert(this: *mut root::ComplexRowVector,
                                       a: *const root::RowVector,
                                       c: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector6insertERKS_i"]
        pub fn ComplexRowVector_insert1(this: *mut root::ComplexRowVector,
                                        a: *const root::ComplexRowVector,
                                        c: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillEd"]
        pub fn ComplexRowVector_fill(this: *mut root::ComplexRowVector,
                                     val: f64) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillERKSt7complexIdE"]
        pub fn ComplexRowVector_fill1(this: *mut root::ComplexRowVector,
                                      val: *const root::Complex)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillEdii"]
        pub fn ComplexRowVector_fill2(this: *mut root::ComplexRowVector,
                                      val: f64, c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillERKSt7complexIdEii"]
        pub fn ComplexRowVector_fill3(this: *mut root::ComplexRowVector,
                                      val: *const root::Complex,
                                      c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector6appendERK9RowVector"]
        pub fn ComplexRowVector_append(this: *const root::ComplexRowVector,
                                       a: *const root::RowVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector6appendERKS_"]
        pub fn ComplexRowVector_append1(this: *const root::ComplexRowVector,
                                        a: *const root::ComplexRowVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9hermitianEv"]
        pub fn ComplexRowVector_hermitian(this: *const root::ComplexRowVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9transposeEv"]
        pub fn ComplexRowVector_transpose(this: *const root::ComplexRowVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector7extractEii"]
        pub fn ComplexRowVector_extract(this: *const root::ComplexRowVector,
                                        c1: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9extract_nEii"]
        pub fn ComplexRowVector_extract_n(this: *const root::ComplexRowVector,
                                          c1: root::octave_idx_type,
                                          n: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector3minEv"]
        pub fn ComplexRowVector_min(this: *const root::ComplexRowVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector3maxEv"]
        pub fn ComplexRowVector_max(this: *const root::ComplexRowVector)
         -> root::Complex;
    }
    impl ComplexRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::RowVector,
                             c: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexRowVector,
                              c: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector)
         -> root::ComplexRowVector {
            ComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::ComplexRowVector)
         -> root::ComplexRowVector {
            ComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexColumnVector {
            ComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexColumnVector {
            ComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatRowVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatRowVector() {
        assert_eq!(::std::mem::size_of::<FloatRowVector>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( FloatRowVector ) ));
        assert_eq! (::std::mem::align_of::<FloatRowVector>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( FloatRowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector6insertERKS_i"]
        pub fn FloatRowVector_insert(this: *mut root::FloatRowVector,
                                     a: *const root::FloatRowVector,
                                     c: root::octave_idx_type)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector4fillEf"]
        pub fn FloatRowVector_fill(this: *mut root::FloatRowVector, val: f32)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector4fillEfii"]
        pub fn FloatRowVector_fill1(this: *mut root::FloatRowVector, val: f32,
                                    c1: root::octave_idx_type,
                                    c2: root::octave_idx_type)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector6appendERKS_"]
        pub fn FloatRowVector_append(this: *const root::FloatRowVector,
                                     a: *const root::FloatRowVector)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector9transposeEv"]
        pub fn FloatRowVector_transpose(this: *const root::FloatRowVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector7extractEii"]
        pub fn FloatRowVector_extract(this: *const root::FloatRowVector,
                                      c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector9extract_nEii"]
        pub fn FloatRowVector_extract_n(this: *const root::FloatRowVector,
                                        c1: root::octave_idx_type,
                                        n: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector3minEv"]
        pub fn FloatRowVector_min(this: *const root::FloatRowVector) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector3maxEv"]
        pub fn FloatRowVector_max(this: *const root::FloatRowVector) -> f32;
    }
    impl FloatRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatRowVector,
                             c: root::octave_idx_type)
         -> *mut root::FloatRowVector {
            FloatRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatRowVector {
            FloatRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatRowVector {
            FloatRowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector)
         -> root::FloatRowVector {
            FloatRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatColumnVector {
            FloatRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 { FloatRowVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f32 { FloatRowVector_max(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexRowVector {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexRowVector() {
        assert_eq!(::std::mem::size_of::<FloatComplexRowVector>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexRowVector ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexRowVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexRowVector )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector6insertERK14FloatRowVectori"]
        pub fn FloatComplexRowVector_insert(this:
                                                *mut root::FloatComplexRowVector,
                                            a: *const root::FloatRowVector,
                                            c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector6insertERKS_i"]
        pub fn FloatComplexRowVector_insert1(this:
                                                 *mut root::FloatComplexRowVector,
                                             a:
                                                 *const root::FloatComplexRowVector,
                                             c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillEf"]
        pub fn FloatComplexRowVector_fill(this:
                                              *mut root::FloatComplexRowVector,
                                          val: f32)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillERKSt7complexIfE"]
        pub fn FloatComplexRowVector_fill1(this:
                                               *mut root::FloatComplexRowVector,
                                           val: *const root::FloatComplex)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillEfii"]
        pub fn FloatComplexRowVector_fill2(this:
                                               *mut root::FloatComplexRowVector,
                                           val: f32,
                                           c1: root::octave_idx_type,
                                           c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillERKSt7complexIfEii"]
        pub fn FloatComplexRowVector_fill3(this:
                                               *mut root::FloatComplexRowVector,
                                           val: *const root::FloatComplex,
                                           c1: root::octave_idx_type,
                                           c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector6appendERK14FloatRowVector"]
        pub fn FloatComplexRowVector_append(this:
                                                *const root::FloatComplexRowVector,
                                            a: *const root::FloatRowVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector6appendERKS_"]
        pub fn FloatComplexRowVector_append1(this:
                                                 *const root::FloatComplexRowVector,
                                             a:
                                                 *const root::FloatComplexRowVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9hermitianEv"]
        pub fn FloatComplexRowVector_hermitian(this:
                                                   *const root::FloatComplexRowVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9transposeEv"]
        pub fn FloatComplexRowVector_transpose(this:
                                                   *const root::FloatComplexRowVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector7extractEii"]
        pub fn FloatComplexRowVector_extract(this:
                                                 *const root::FloatComplexRowVector,
                                             c1: root::octave_idx_type,
                                             c2: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9extract_nEii"]
        pub fn FloatComplexRowVector_extract_n(this:
                                                   *const root::FloatComplexRowVector,
                                               c1: root::octave_idx_type,
                                               n: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector3minEv"]
        pub fn FloatComplexRowVector_min(this:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector3maxEv"]
        pub fn FloatComplexRowVector_max(this:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplex;
    }
    impl FloatComplexRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatRowVector,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self,
                              a: *const root::FloatComplexRowVector,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagMatrix {
        pub _base: root::MDiagArray2<f64>,
    }
    #[test]
    fn bindgen_test_layout_DiagMatrix() {
        assert_eq!(::std::mem::size_of::<DiagMatrix>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( DiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<DiagMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( DiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillEd"]
        pub fn DiagMatrix_fill(this: *mut root::DiagMatrix, val: f64)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillEdii"]
        pub fn DiagMatrix_fill1(this: *mut root::DiagMatrix, val: f64,
                                beg: root::octave_idx_type,
                                end: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK12ColumnVector"]
        pub fn DiagMatrix_fill2(this: *mut root::DiagMatrix,
                                a: *const root::ColumnVector)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK9RowVector"]
        pub fn DiagMatrix_fill3(this: *mut root::DiagMatrix,
                                a: *const root::RowVector)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK12ColumnVectori"]
        pub fn DiagMatrix_fill4(this: *mut root::DiagMatrix,
                                a: *const root::ColumnVector,
                                beg: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK9RowVectori"]
        pub fn DiagMatrix_fill5(this: *mut root::DiagMatrix,
                                a: *const root::RowVector,
                                beg: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3absEv"]
        pub fn DiagMatrix_abs(this: *const root::DiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7extractEiiii"]
        pub fn DiagMatrix_extract(this: *const root::DiagMatrix,
                                  r1: root::octave_idx_type,
                                  c1: root::octave_idx_type,
                                  r2: root::octave_idx_type,
                                  c2: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3rowEi"]
        pub fn DiagMatrix_row(this: *const root::DiagMatrix,
                              i: root::octave_idx_type) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3rowEPc"]
        pub fn DiagMatrix_row1(this: *const root::DiagMatrix,
                               s: *mut ::std::os::raw::c_char)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix6columnEi"]
        pub fn DiagMatrix_column(this: *const root::DiagMatrix,
                                 i: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix6columnEPc"]
        pub fn DiagMatrix_column1(this: *const root::DiagMatrix,
                                  s: *mut ::std::os::raw::c_char)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7inverseEv"]
        pub fn DiagMatrix_inverse(this: *const root::DiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7inverseERi"]
        pub fn DiagMatrix_inverse1(this: *const root::DiagMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix14pseudo_inverseEd"]
        pub fn DiagMatrix_pseudo_inverse(this: *const root::DiagMatrix,
                                         tol: f64) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix11determinantEv"]
        pub fn DiagMatrix_determinant(this: *const root::DiagMatrix)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix5rcondEv"]
        pub fn DiagMatrix_rcond(this: *const root::DiagMatrix) -> f64;
    }
    impl DiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::DiagMatrix {
            DiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, a: *const root::ColumnVector)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, a: *const root::RowVector)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::ColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::RowVector,
                            beg: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix { DiagMatrix_abs(self) }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix {
            DiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            DiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::RowVector {
            DiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            DiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ColumnVector {
            DiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::DiagMatrix {
            DiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::DiagMatrix {
            DiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::DiagMatrix {
            DiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            DiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { DiagMatrix_rcond(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexDiagMatrix() {
        assert_eq!(::std::mem::size_of::<ComplexDiagMatrix>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( ComplexDiagMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<ComplexDiagMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexDiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillEd"]
        pub fn ComplexDiagMatrix_fill(this: *mut root::ComplexDiagMatrix,
                                      val: f64)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERKSt7complexIdE"]
        pub fn ComplexDiagMatrix_fill1(this: *mut root::ComplexDiagMatrix,
                                       val: *const root::Complex)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillEdii"]
        pub fn ComplexDiagMatrix_fill2(this: *mut root::ComplexDiagMatrix,
                                       val: f64, beg: root::octave_idx_type,
                                       end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERKSt7complexIdEii"]
        pub fn ComplexDiagMatrix_fill3(this: *mut root::ComplexDiagMatrix,
                                       val: *const root::Complex,
                                       beg: root::octave_idx_type,
                                       end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK12ColumnVector"]
        pub fn ComplexDiagMatrix_fill4(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ColumnVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVector"]
        pub fn ComplexDiagMatrix_fill5(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexColumnVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK9RowVector"]
        pub fn ComplexDiagMatrix_fill6(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::RowVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK16ComplexRowVector"]
        pub fn ComplexDiagMatrix_fill7(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexRowVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK12ColumnVectori"]
        pub fn ComplexDiagMatrix_fill8(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ColumnVector,
                                       beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVectori"]
        pub fn ComplexDiagMatrix_fill9(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexColumnVector,
                                       beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK9RowVectori"]
        pub fn ComplexDiagMatrix_fill10(this: *mut root::ComplexDiagMatrix,
                                        a: *const root::RowVector,
                                        beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK16ComplexRowVectori"]
        pub fn ComplexDiagMatrix_fill11(this: *mut root::ComplexDiagMatrix,
                                        a: *const root::ComplexRowVector,
                                        beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3absEv"]
        pub fn ComplexDiagMatrix_abs(this: *const root::ComplexDiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7extractEiiii"]
        pub fn ComplexDiagMatrix_extract(this: *const root::ComplexDiagMatrix,
                                         r1: root::octave_idx_type,
                                         c1: root::octave_idx_type,
                                         r2: root::octave_idx_type,
                                         c2: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3rowEi"]
        pub fn ComplexDiagMatrix_row(this: *const root::ComplexDiagMatrix,
                                     i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3rowEPc"]
        pub fn ComplexDiagMatrix_row1(this: *const root::ComplexDiagMatrix,
                                      s: *mut ::std::os::raw::c_char)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix6columnEi"]
        pub fn ComplexDiagMatrix_column(this: *const root::ComplexDiagMatrix,
                                        i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix6columnEPc"]
        pub fn ComplexDiagMatrix_column1(this: *const root::ComplexDiagMatrix,
                                         s: *mut ::std::os::raw::c_char)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7inverseERi"]
        pub fn ComplexDiagMatrix_inverse(this: *const root::ComplexDiagMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7inverseEv"]
        pub fn ComplexDiagMatrix_inverse1(this:
                                              *const root::ComplexDiagMatrix)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix14pseudo_inverseEd"]
        pub fn ComplexDiagMatrix_pseudo_inverse(this:
                                                    *const root::ComplexDiagMatrix,
                                                tol: f64)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix21all_elements_are_realEv"]
        pub fn ComplexDiagMatrix_all_elements_are_real(this:
                                                           *const root::ComplexDiagMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix11determinantEv"]
        pub fn ComplexDiagMatrix_determinant(this:
                                                 *const root::ComplexDiagMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix5rcondEv"]
        pub fn ComplexDiagMatrix_rcond(this: *const root::ComplexDiagMatrix)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrixC1ERK10DiagMatrix"]
        pub fn ComplexDiagMatrix_ComplexDiagMatrix(this:
                                                       *mut root::ComplexDiagMatrix,
                                                   a:
                                                       *const root::DiagMatrix);
    }
    impl ComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::ColumnVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::ComplexColumnVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(&mut self, a: *const root::RowVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(&mut self, a: *const root::ComplexRowVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(&mut self, a: *const root::ColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(&mut self, a: *const root::ComplexColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(&mut self, a: *const root::RowVector,
                             beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(&mut self, a: *const root::ComplexRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix {
            ComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ComplexRowVector {
            ComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ComplexColumnVector {
            ComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64)
         -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { ComplexDiagMatrix_rcond(self) }
        #[inline]
        pub unsafe fn new(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexDiagMatrix_ComplexDiagMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatDiagMatrix {
        pub _base: root::MDiagArray2<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatDiagMatrix() {
        assert_eq!(::std::mem::size_of::<FloatDiagMatrix>() , 48usize , concat
                   ! ( "Size of: " , stringify ! ( FloatDiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatDiagMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatDiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillEf"]
        pub fn FloatDiagMatrix_fill(this: *mut root::FloatDiagMatrix,
                                    val: f32) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillEfii"]
        pub fn FloatDiagMatrix_fill1(this: *mut root::FloatDiagMatrix,
                                     val: f32, beg: root::octave_idx_type,
                                     end: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatDiagMatrix_fill2(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatColumnVector)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatDiagMatrix_fill3(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatRowVector)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK17FloatColumnVectori"]
        pub fn FloatDiagMatrix_fill4(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatColumnVector,
                                     beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK14FloatRowVectori"]
        pub fn FloatDiagMatrix_fill5(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatRowVector,
                                     beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3absEv"]
        pub fn FloatDiagMatrix_abs(this: *const root::FloatDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7extractEiiii"]
        pub fn FloatDiagMatrix_extract(this: *const root::FloatDiagMatrix,
                                       r1: root::octave_idx_type,
                                       c1: root::octave_idx_type,
                                       r2: root::octave_idx_type,
                                       c2: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3rowEi"]
        pub fn FloatDiagMatrix_row(this: *const root::FloatDiagMatrix,
                                   i: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3rowEPc"]
        pub fn FloatDiagMatrix_row1(this: *const root::FloatDiagMatrix,
                                    s: *mut ::std::os::raw::c_char)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix6columnEi"]
        pub fn FloatDiagMatrix_column(this: *const root::FloatDiagMatrix,
                                      i: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix6columnEPc"]
        pub fn FloatDiagMatrix_column1(this: *const root::FloatDiagMatrix,
                                       s: *mut ::std::os::raw::c_char)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7inverseEv"]
        pub fn FloatDiagMatrix_inverse(this: *const root::FloatDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7inverseERi"]
        pub fn FloatDiagMatrix_inverse1(this: *const root::FloatDiagMatrix,
                                        info: *mut root::octave_idx_type)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix14pseudo_inverseEf"]
        pub fn FloatDiagMatrix_pseudo_inverse(this:
                                                  *const root::FloatDiagMatrix,
                                              tol: f32)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix11determinantEv"]
        pub fn FloatDiagMatrix_determinant(this: *const root::FloatDiagMatrix)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix5rcondEv"]
        pub fn FloatDiagMatrix_rcond(this: *const root::FloatDiagMatrix)
         -> f32;
    }
    impl FloatDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, a: *const root::FloatColumnVector)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, a: *const root::FloatRowVector)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::FloatColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::FloatRowVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatRowVector {
            FloatDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatColumnVector {
            FloatDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatDiagMatrix {
            FloatDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatDiagMatrix_rcond(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexDiagMatrix() {
        assert_eq!(::std::mem::size_of::<FloatComplexDiagMatrix>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexDiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexDiagMatrix>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( FloatComplexDiagMatrix )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillEf"]
        pub fn FloatComplexDiagMatrix_fill(this:
                                               *mut root::FloatComplexDiagMatrix,
                                           val: f32)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexDiagMatrix_fill1(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: *const root::FloatComplex)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillEfii"]
        pub fn FloatComplexDiagMatrix_fill2(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: f32,
                                            beg: root::octave_idx_type,
                                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfEii"]
        pub fn FloatComplexDiagMatrix_fill3(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: *const root::FloatComplex,
                                            beg: root::octave_idx_type,
                                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatComplexDiagMatrix_fill4(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatColumnVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVector"]
        pub fn FloatComplexDiagMatrix_fill5(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexColumnVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatComplexDiagMatrix_fill6(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatRowVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVector"]
        pub fn FloatComplexDiagMatrix_fill7(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexRowVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVectori"]
        pub fn FloatComplexDiagMatrix_fill8(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatColumnVector,
                                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVectori"]
        pub fn FloatComplexDiagMatrix_fill9(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexColumnVector,
                                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVectori"]
        pub fn FloatComplexDiagMatrix_fill10(this:
                                                 *mut root::FloatComplexDiagMatrix,
                                             a: *const root::FloatRowVector,
                                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVectori"]
        pub fn FloatComplexDiagMatrix_fill11(this:
                                                 *mut root::FloatComplexDiagMatrix,
                                             a:
                                                 *const root::FloatComplexRowVector,
                                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3absEv"]
        pub fn FloatComplexDiagMatrix_abs(this:
                                              *const root::FloatComplexDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7extractEiiii"]
        pub fn FloatComplexDiagMatrix_extract(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              r1: root::octave_idx_type,
                                              c1: root::octave_idx_type,
                                              r2: root::octave_idx_type,
                                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3rowEi"]
        pub fn FloatComplexDiagMatrix_row(this:
                                              *const root::FloatComplexDiagMatrix,
                                          i: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3rowEPc"]
        pub fn FloatComplexDiagMatrix_row1(this:
                                               *const root::FloatComplexDiagMatrix,
                                           s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix6columnEi"]
        pub fn FloatComplexDiagMatrix_column(this:
                                                 *const root::FloatComplexDiagMatrix,
                                             i: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix6columnEPc"]
        pub fn FloatComplexDiagMatrix_column1(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7inverseERi"]
        pub fn FloatComplexDiagMatrix_inverse(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              info:
                                                  *mut root::octave_idx_type)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7inverseEv"]
        pub fn FloatComplexDiagMatrix_inverse1(this:
                                                   *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix14pseudo_inverseEf"]
        pub fn FloatComplexDiagMatrix_pseudo_inverse(this:
                                                         *const root::FloatComplexDiagMatrix,
                                                     tol: f32)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix21all_elements_are_realEv"]
        pub fn FloatComplexDiagMatrix_all_elements_are_real(this:
                                                                *const root::FloatComplexDiagMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix11determinantEv"]
        pub fn FloatComplexDiagMatrix_determinant(this:
                                                      *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix5rcondEv"]
        pub fn FloatComplexDiagMatrix_rcond(this:
                                                *const root::FloatComplexDiagMatrix)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexDiagMatrix_FloatComplexDiagMatrix(this:
                                                                 *mut root::FloatComplexDiagMatrix,
                                                             a:
                                                                 *const root::FloatDiagMatrix);
    }
    impl FloatComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::FloatColumnVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(&mut self,
                            a: *const root::FloatComplexColumnVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(&mut self, a: *const root::FloatRowVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(&mut self, a: *const root::FloatComplexRowVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(&mut self, a: *const root::FloatColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(&mut self,
                            a: *const root::FloatComplexColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(&mut self, a: *const root::FloatRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(&mut self, a: *const root::FloatComplexRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatComplexDiagMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexDiagMatrix_FloatComplexDiagMatrix(&mut __bindgen_tmp,
                                                          a);
            __bindgen_tmp
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum blas_trans_type {
        blas_no_trans = 78,
        blas_trans = 84,
        blas_conj_trans = 67,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct string_vector {
        pub _base: root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                       root::std::allocator>>,
    }
    #[test]
    fn bindgen_test_layout_string_vector() {
        assert_eq!(::std::mem::size_of::<string_vector>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( string_vector ) ));
        assert_eq! (::std::mem::align_of::<string_vector>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( string_vector ) ));
    }
    extern "C" {
        #[link_name = "_ZN13string_vector4sortEb"]
        pub fn string_vector_sort(this: *mut root::string_vector,
                                  make_uniq: bool)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector4uniqEv"]
        pub fn string_vector_uniq(this: *mut root::string_vector)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector6appendERKSs"]
        pub fn string_vector_append(this: *mut root::string_vector,
                                    s: *const root::std::string)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector6appendERKS_"]
        pub fn string_vector_append1(this: *mut root::string_vector,
                                     sv: *const root::string_vector)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector4joinERKSs"]
        pub fn string_vector_join(this: *const root::string_vector,
                                  sep: *const root::std::string)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector9c_str_vecEv"]
        pub fn string_vector_c_str_vec(this: *const root::string_vector)
         -> *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector8std_listEv"]
        pub fn string_vector_std_list(this: *const root::string_vector)
         -> root::std::list;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector16delete_c_str_vecEPKPKc"]
        pub fn string_vector_delete_c_str_vec(arg1:
                                                  *const *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector15list_in_columnsERSoiRKSs"]
        pub fn string_vector_list_in_columns(this: *const root::string_vector,
                                             arg1: *mut root::std::ostream,
                                             width: ::std::os::raw::c_int,
                                             prefix: *const root::std::string)
         -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN13string_vectorC1EPKPKc"]
        pub fn string_vector_string_vector(this: *mut root::string_vector,
                                           s:
                                               *const *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN13string_vectorC1EPKPKci"]
        pub fn string_vector_string_vector1(this: *mut root::string_vector,
                                            s:
                                                *const *const ::std::os::raw::c_char,
                                            n: root::octave_idx_type);
    }
    impl string_vector {
        #[inline]
        pub unsafe fn sort(&mut self, make_uniq: bool)
         -> *mut root::string_vector {
            string_vector_sort(self, make_uniq)
        }
        #[inline]
        pub unsafe fn uniq(&mut self) -> *mut root::string_vector {
            string_vector_uniq(self)
        }
        #[inline]
        pub unsafe fn append(&mut self, s: *const root::std::string)
         -> *mut root::string_vector {
            string_vector_append(self, s)
        }
        #[inline]
        pub unsafe fn append1(&mut self, sv: *const root::string_vector)
         -> *mut root::string_vector {
            string_vector_append1(self, sv)
        }
        #[inline]
        pub unsafe fn join(&self, sep: *const root::std::string)
         -> root::std::string {
            string_vector_join(self, sep)
        }
        #[inline]
        pub unsafe fn c_str_vec(&self) -> *mut *mut ::std::os::raw::c_char {
            string_vector_c_str_vec(self)
        }
        #[inline]
        pub unsafe fn std_list(&self) -> root::std::list {
            string_vector_std_list(self)
        }
        #[inline]
        pub unsafe fn delete_c_str_vec(arg1:
                                           *const *const ::std::os::raw::c_char) {
            string_vector_delete_c_str_vec(arg1)
        }
        #[inline]
        pub unsafe fn list_in_columns(&self, arg1: *mut root::std::ostream,
                                      width: ::std::os::raw::c_int,
                                      prefix: *const root::std::string)
         -> *mut root::std::ostream {
            string_vector_list_in_columns(self, arg1, width, prefix)
        }
        #[inline]
        pub unsafe fn new(s: *const *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            string_vector_string_vector(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(s: *const *const ::std::os::raw::c_char,
                           n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            string_vector_string_vector1(&mut __bindgen_tmp, s, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct intNDArray<T> {
        pub _base: root::MArray<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagArray2<T> {
        pub _base: root::Array<T>,
        pub d1: root::octave_idx_type,
        pub d2: root::octave_idx_type,
    }
    //! Template for two dimensional diagonal array with math operators.
    #[repr(C)]
    #[derive(Debug)]
    pub struct MDiagArray2<T> {
        pub _base: root::DiagArray2<T>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct base_det<T> {
        pub c2: T,
        pub e2: ::std::os::raw::c_int,
    }
    pub type DET = root::base_det<f64>;
    pub type FloatDET = root::base_det<f32>;
    pub type ComplexDET = root::base_det<root::std::complex<f64>>;
    pub type FloatComplexDET = root::base_det<root::std::complex<f32>>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseBoolMatrix {
        pub _base: root::Sparse<bool>,
    }
    pub type SparseBoolMatrix_dense_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_SparseBoolMatrix() {
        assert_eq!(::std::mem::size_of::<SparseBoolMatrix>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( SparseBoolMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<SparseBoolMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( SparseBoolMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6insertERKS_ii"]
        pub fn SparseBoolMatrix_insert(this: *mut root::SparseBoolMatrix,
                                       a: *const root::SparseBoolMatrix,
                                       r: root::octave_idx_type,
                                       c: root::octave_idx_type)
         -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseBoolMatrix_insert1(this: *mut root::SparseBoolMatrix,
                                        a: *const root::SparseBoolMatrix,
                                        indx:
                                            *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseBoolMatrix_concat(this: *mut root::SparseBoolMatrix,
                                       rb: *const root::SparseBoolMatrix,
                                       ra_idx:
                                           *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix4diagEi"]
        pub fn SparseBoolMatrix_diag(this: *const root::SparseBoolMatrix,
                                     k: root::octave_idx_type)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix12matrix_valueEv"]
        pub fn SparseBoolMatrix_matrix_value(this:
                                                 *const root::SparseBoolMatrix)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7squeezeEv"]
        pub fn SparseBoolMatrix_squeeze(this: *const root::SparseBoolMatrix)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix5indexERK10idx_vectorb"]
        pub fn SparseBoolMatrix_index(this: *const root::SparseBoolMatrix,
                                      i: *const root::idx_vector,
                                      resize_ok: bool)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix5indexERK10idx_vectorS2_b"]
        pub fn SparseBoolMatrix_index1(this: *const root::SparseBoolMatrix,
                                       i: *const root::idx_vector,
                                       j: *const root::idx_vector,
                                       resize_ok: bool)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7reshapeERK10dim_vector"]
        pub fn SparseBoolMatrix_reshape(this: *const root::SparseBoolMatrix,
                                        new_dims: *const root::dim_vector)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseBoolMatrix_permute(this: *const root::SparseBoolMatrix,
                                        vec:
                                            *const root::Array<::std::os::raw::c_int>,
                                        inv: bool) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseBoolMatrix_ipermute(this: *const root::SparseBoolMatrix,
                                         vec:
                                             *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3allEi"]
        pub fn SparseBoolMatrix_all(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3anyEi"]
        pub fn SparseBoolMatrix_any(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3sumEi"]
        pub fn SparseBoolMatrix_sum(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    impl SparseBoolMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseBoolMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseBoolMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseBoolMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::boolMatrix {
            SparseBoolMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseBoolMatrix {
            SparseBoolMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector,
                            resize_ok: bool) -> root::SparseBoolMatrix {
            SparseBoolMatrix_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(&self, i: *const root::idx_vector,
                             j: *const root::idx_vector, resize_ok: bool)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseBoolMatrix {
            SparseBoolMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseBoolMatrix_sum(self, dim)
        }
    }
    pub type int8NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_schar>>;
    pub type int16NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_short>>;
    pub type int32NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_int>>;
    pub type int64NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>;
    pub type uint8NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>;
    pub type uint16NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>;
    pub type uint32NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_uint>>;
    pub type uint64NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>;
    pub type octave_time = root::octave::sys::time;
    pub type octave_base_tm = root::octave::sys::base_tm;
    pub type octave_localtime = root::octave::sys::localtime;
    pub type octave_gmtime = root::octave::sys::gmtime;
    pub type octave_strptime = root::octave::sys::strptime;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Cell {
        pub _base: root::Array<root::octave_value>,
    }
    pub type Cell_ctype_mapper =
        ::std::option::Option<unsafe extern "C" fn() -> root::octave_value>;
    #[test]
    fn bindgen_test_layout_Cell() {
        assert_eq!(::std::mem::size_of::<Cell>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( Cell ) ));
        assert_eq! (::std::mem::align_of::<Cell>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Cell ) ));
    }
    extern "C" {
        #[link_name = "_ZNK4Cell10is_cellstrEv"]
        pub fn Cell_is_cellstr(this: *const root::Cell) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell13cellstr_valueEv"]
        pub fn Cell_cellstr_value(this: *const root::Cell)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>>;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell5indexERK17octave_value_listb"]
        pub fn Cell_index(this: *const root::Cell,
                          idx: *const root::octave_value_list,
                          resize_ok: bool) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell15delete_elementsERK17octave_value_list"]
        pub fn Cell_delete_elements(this: *mut root::Cell,
                                    idx: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name =
              "_ZN4Cell6assignERK17octave_value_listRKS_RK12octave_value"]
        pub fn Cell_assign(this: *mut root::Cell,
                           idx: *const root::octave_value_list,
                           rhs: *const root::Cell,
                           fill_val: *const root::octave_value);
    }
    extern "C" {
        #[link_name = "_ZNK4Cell3nnzEv"]
        pub fn Cell_nnz(this: *const root::Cell) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell6columnEi"]
        pub fn Cell_column(this: *const root::Cell, i: root::octave_idx_type)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6concatERKS_RK5ArrayIiE"]
        pub fn Cell_concat(this: *mut root::Cell, rb: *const root::Cell,
                           ra_idx: *const root::Array<::std::os::raw::c_int>)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6insertERKS_ii"]
        pub fn Cell_insert(this: *mut root::Cell, a: *const root::Cell,
                           r: root::octave_idx_type, c: root::octave_idx_type)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6insertERKS_RK5ArrayIiE"]
        pub fn Cell_insert1(this: *mut root::Cell, a: *const root::Cell,
                            ra_idx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell4diagEi"]
        pub fn Cell_diag(this: *const root::Cell, k: root::octave_idx_type)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell4diagEii"]
        pub fn Cell_diag1(this: *const root::Cell, m: root::octave_idx_type,
                          n: root::octave_idx_type) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK17octave_value_list"]
        pub fn Cell_Cell(this: *mut root::Cell,
                         ovl: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK13string_vectorb"]
        pub fn Cell_Cell1(this: *mut root::Cell,
                          sv: *const root::string_vector, trim: bool);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERKSt4listISsSaISsEE"]
        pub fn Cell_Cell2(this: *mut root::Cell, lst: *const root::std::list);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK5ArrayISsE"]
        pub fn Cell_Cell3(this: *mut root::Cell,
                          sa:
                              *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                         root::std::allocator>>);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK10dim_vectorRK13string_vectorb"]
        pub fn Cell_Cell4(this: *mut root::Cell, dv: *const root::dim_vector,
                          sv: *const root::string_vector, trim: bool);
    }
    impl Cell {
        #[inline]
        pub unsafe fn is_cellstr(&self) -> bool { Cell_is_cellstr(self) }
        #[inline]
        pub unsafe fn cellstr_value(&self)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>> {
            Cell_cellstr_value(self)
        }
        #[inline]
        pub unsafe fn index(&self, idx: *const root::octave_value_list,
                            resize_ok: bool) -> root::Cell {
            Cell_index(self, idx, resize_ok)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self,
                                      idx: *const root::octave_value_list) {
            Cell_delete_elements(self, idx)
        }
        #[inline]
        pub unsafe fn assign(&mut self, idx: *const root::octave_value_list,
                             rhs: *const root::Cell,
                             fill_val: *const root::octave_value) {
            Cell_assign(self, idx, rhs, fill_val)
        }
        #[inline]
        pub unsafe fn nnz(&self) -> root::octave_idx_type { Cell_nnz(self) }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::Cell {
            Cell_column(self, i)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::Cell,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::Cell {
            Cell_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Cell,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Cell {
            Cell_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::Cell,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::Cell {
            Cell_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Cell {
            Cell_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::Cell {
            Cell_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(ovl: *const root::octave_value_list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell(&mut __bindgen_tmp, ovl);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(sv: *const root::string_vector, trim: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell1(&mut __bindgen_tmp, sv, trim);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(lst: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell2(&mut __bindgen_tmp, lst);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(sa:
                               *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                          root::std::allocator>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell3(&mut __bindgen_tmp, sa);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(dv: *const root::dim_vector,
                           sv: *const root::string_vector, trim: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell4(&mut __bindgen_tmp, dv, sv, trim);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mxArray([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_map {
        pub xkeys: root::octave_fields,
        pub xvals: root::std::vector,
        pub dimensions: root::dim_vector,
    }
    pub type octave_map_element_type = root::octave_scalar_map;
    pub type octave_map_const_iterator = root::octave_fields_const_iterator;
    pub type octave_map_iterator = root::octave_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_map() {
        assert_eq!(::std::mem::size_of::<octave_map>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( octave_map ) ));
        assert_eq! (::std::mem::align_of::<octave_map>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( octave_map ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . xkeys as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( xkeys ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . xvals as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( xvals ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . dimensions as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( dimensions ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map8getfieldERKSs"]
        pub fn octave_map_getfield(this: *const root::octave_map,
                                   key: *const root::std::string)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map8setfieldERKSsRK4Cell"]
        pub fn octave_map_setfield(this: *mut root::octave_map,
                                   key: *const root::std::string,
                                   val: *const root::Cell);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map7rmfieldERKSs"]
        pub fn octave_map_rmfield(this: *mut root::octave_map,
                                  key: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsEv"]
        pub fn octave_map_orderfields(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsER5ArrayIiE"]
        pub fn octave_map_orderfields1(this: *const root::octave_map,
                                       perm:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsERKS_R5ArrayIiE"]
        pub fn octave_map_orderfields2(this: *const root::octave_map,
                                       other: *const root::octave_map,
                                       perm:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map8contentsERKSs"]
        pub fn octave_map_contents(this: *const root::octave_map,
                                   k: *const root::std::string) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map8contentsERKSs"]
        pub fn octave_map_contents1(this: *mut root::octave_map,
                                    k: *const root::std::string)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemEi"]
        pub fn octave_map_checkelem(this: *const root::octave_map,
                                    n: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemEii"]
        pub fn octave_map_checkelem1(this: *const root::octave_map,
                                     i: root::octave_idx_type,
                                     j: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemERK5ArrayIiE"]
        pub fn octave_map_checkelem2(this: *const root::octave_map,
                                     ra_idx:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7squeezeEv"]
        pub fn octave_map_squeeze(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7permuteERK5ArrayIiEb"]
        pub fn octave_map_permute(this: *const root::octave_map,
                                  vec:
                                      *const root::Array<::std::os::raw::c_int>,
                                  inv: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9transposeEv"]
        pub fn octave_map_transpose(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7reshapeERK10dim_vector"]
        pub fn octave_map_reshape(this: *const root::octave_map,
                                  dv: *const root::dim_vector)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6resizeERK10dim_vectorb"]
        pub fn octave_map_resize(this: *mut root::octave_map,
                                 dv: *const root::dim_vector, fill: bool);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map3catEiiPK17octave_scalar_map"]
        pub fn octave_map_cat(dim: ::std::os::raw::c_int,
                              n: root::octave_idx_type,
                              map_list: *const root::octave_scalar_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map3catEiiPKS_"]
        pub fn octave_map_cat1(dim: ::std::os::raw::c_int,
                               n: root::octave_idx_type,
                               map_list: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK10idx_vectorb"]
        pub fn octave_map_index(this: *const root::octave_map,
                                i: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK10idx_vectorS2_b"]
        pub fn octave_map_index1(this: *const root::octave_map,
                                 i: *const root::idx_vector,
                                 j: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK5ArrayI10idx_vectorEb"]
        pub fn octave_map_index2(this: *const root::octave_map,
                                 ia: *const root::Array<root::idx_vector>,
                                 resize_ok: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK17octave_value_listb"]
        pub fn octave_map_index3(this: *const root::octave_map,
                                 arg1: *const root::octave_value_list,
                                 resize_ok: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map6columnEi"]
        pub fn octave_map_column(this: *const root::octave_map,
                                 k: root::octave_idx_type)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map4pageEi"]
        pub fn octave_map_page(this: *const root::octave_map,
                               k: root::octave_idx_type) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK10idx_vectorRKS_"]
        pub fn octave_map_assign(this: *mut root::octave_map,
                                 i: *const root::idx_vector,
                                 rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK10idx_vectorS2_RKS_"]
        pub fn octave_map_assign1(this: *mut root::octave_map,
                                  i: *const root::idx_vector,
                                  j: *const root::idx_vector,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK5ArrayI10idx_vectorERKS_"]
        pub fn octave_map_assign2(this: *mut root::octave_map,
                                  ia: *const root::Array<root::idx_vector>,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK17octave_value_listRKS_"]
        pub fn octave_map_assign3(this: *mut root::octave_map,
                                  arg1: *const root::octave_value_list,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map6assignERK17octave_value_listRKSsRK4Cell"]
        pub fn octave_map_assign4(this: *mut root::octave_map,
                                  idx: *const root::octave_value_list,
                                  k: *const root::std::string,
                                  rhs: *const root::Cell);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map15delete_elementsERK10idx_vector"]
        pub fn octave_map_delete_elements(this: *mut root::octave_map,
                                          i: *const root::idx_vector);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map15delete_elementsEiRK10idx_vector"]
        pub fn octave_map_delete_elements1(this: *mut root::octave_map,
                                           dim: ::std::os::raw::c_int,
                                           i: *const root::idx_vector);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map15delete_elementsERK5ArrayI10idx_vectorE"]
        pub fn octave_map_delete_elements2(this: *mut root::octave_map,
                                           ia:
                                               *const root::Array<root::idx_vector>);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map15delete_elementsERK17octave_value_list"]
        pub fn octave_map_delete_elements3(this: *mut root::octave_map,
                                           arg1:
                                               *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6concatERKS_RK5ArrayIiE"]
        pub fn octave_map_concat(this: *mut root::octave_map,
                                 rb: *const root::octave_map,
                                 ra_idx:
                                     *const root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map17fast_elem_extractEi"]
        pub fn octave_map_fast_elem_extract(this: *const root::octave_map,
                                            n: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map16fast_elem_insertEiRK17octave_scalar_map"]
        pub fn octave_map_fast_elem_insert(this: *mut root::octave_map,
                                           n: root::octave_idx_type,
                                           rhs:
                                               *const root::octave_scalar_map)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN10octave_mapC1ERK17octave_scalar_map"]
        pub fn octave_map_octave_map(this: *mut root::octave_map,
                                     m: *const root::octave_scalar_map);
    }
    impl octave_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string)
         -> root::Cell {
            octave_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(&mut self, key: *const root::std::string,
                               val: *const root::Cell) {
            octave_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_map {
            octave_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(&self,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(&self, other: *const root::octave_map,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string)
         -> root::Cell {
            octave_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string)
         -> *mut root::Cell {
            octave_map_contents1(self, k)
        }
        #[inline]
        pub unsafe fn checkelem(&self, n: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_checkelem(self, n)
        }
        #[inline]
        pub unsafe fn checkelem1(&self, i: root::octave_idx_type,
                                 j: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_checkelem1(self, i, j)
        }
        #[inline]
        pub unsafe fn checkelem2(&self,
                                 ra_idx:
                                     *const root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_map_checkelem2(self, ra_idx)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::octave_map {
            octave_map_squeeze(self)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::octave_map {
            octave_map_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::octave_map {
            octave_map_transpose(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, dv: *const root::dim_vector)
         -> root::octave_map {
            octave_map_reshape(self, dv)
        }
        #[inline]
        pub unsafe fn resize(&mut self, dv: *const root::dim_vector,
                             fill: bool) {
            octave_map_resize(self, dv, fill)
        }
        #[inline]
        pub unsafe fn cat(dim: ::std::os::raw::c_int,
                          n: root::octave_idx_type,
                          map_list: *const root::octave_scalar_map)
         -> root::octave_map {
            octave_map_cat(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn cat1(dim: ::std::os::raw::c_int,
                           n: root::octave_idx_type,
                           map_list: *const root::octave_map)
         -> root::octave_map {
            octave_map_cat1(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector,
                            resize_ok: bool) -> root::octave_map {
            octave_map_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(&self, i: *const root::idx_vector,
                             j: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map {
            octave_map_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn index2(&self, ia: *const root::Array<root::idx_vector>,
                             resize_ok: bool) -> root::octave_map {
            octave_map_index2(self, ia, resize_ok)
        }
        #[inline]
        pub unsafe fn index3(&self, arg1: *const root::octave_value_list,
                             resize_ok: bool) -> root::octave_map {
            octave_map_index3(self, arg1, resize_ok)
        }
        #[inline]
        pub unsafe fn column(&self, k: root::octave_idx_type)
         -> root::octave_map {
            octave_map_column(self, k)
        }
        #[inline]
        pub unsafe fn page(&self, k: root::octave_idx_type)
         -> root::octave_map {
            octave_map_page(self, k)
        }
        #[inline]
        pub unsafe fn assign(&mut self, i: *const root::idx_vector,
                             rhs: *const root::octave_map) {
            octave_map_assign(self, i, rhs)
        }
        #[inline]
        pub unsafe fn assign1(&mut self, i: *const root::idx_vector,
                              j: *const root::idx_vector,
                              rhs: *const root::octave_map) {
            octave_map_assign1(self, i, j, rhs)
        }
        #[inline]
        pub unsafe fn assign2(&mut self,
                              ia: *const root::Array<root::idx_vector>,
                              rhs: *const root::octave_map) {
            octave_map_assign2(self, ia, rhs)
        }
        #[inline]
        pub unsafe fn assign3(&mut self, arg1: *const root::octave_value_list,
                              rhs: *const root::octave_map) {
            octave_map_assign3(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn assign4(&mut self, idx: *const root::octave_value_list,
                              k: *const root::std::string,
                              rhs: *const root::Cell) {
            octave_map_assign4(self, idx, k, rhs)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self, i: *const root::idx_vector) {
            octave_map_delete_elements(self, i)
        }
        #[inline]
        pub unsafe fn delete_elements1(&mut self, dim: ::std::os::raw::c_int,
                                       i: *const root::idx_vector) {
            octave_map_delete_elements1(self, dim, i)
        }
        #[inline]
        pub unsafe fn delete_elements2(&mut self,
                                       ia:
                                           *const root::Array<root::idx_vector>) {
            octave_map_delete_elements2(self, ia)
        }
        #[inline]
        pub unsafe fn delete_elements3(&mut self,
                                       arg1: *const root::octave_value_list) {
            octave_map_delete_elements3(self, arg1)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::octave_map,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn fast_elem_extract(&self, n: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_fast_elem_extract(self, n)
        }
        #[inline]
        pub unsafe fn fast_elem_insert(&mut self, n: root::octave_idx_type,
                                       rhs: *const root::octave_scalar_map)
         -> bool {
            octave_map_fast_elem_insert(self, n, rhs)
        }
        #[inline]
        pub unsafe fn new(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_map_octave_map(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_scalar_map {
        pub xkeys: root::octave_fields,
        pub xvals: root::std::vector,
    }
    pub type octave_scalar_map_const_iterator =
        root::octave_fields_const_iterator;
    pub type octave_scalar_map_iterator =
        root::octave_scalar_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_scalar_map() {
        assert_eq!(::std::mem::size_of::<octave_scalar_map>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_scalar_map )
                   ));
        assert_eq! (::std::mem::align_of::<octave_scalar_map>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_scalar_map ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_scalar_map ) ) . xkeys as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_scalar_map )
                    , "::" , stringify ! ( xkeys ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_scalar_map ) ) . xvals as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_scalar_map )
                    , "::" , stringify ! ( xvals ) ));
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map8getfieldERKSs"]
        pub fn octave_scalar_map_getfield(this:
                                              *const root::octave_scalar_map,
                                          key: *const root::std::string)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map8setfieldERKSsRK12octave_value"]
        pub fn octave_scalar_map_setfield(this: *mut root::octave_scalar_map,
                                          key: *const root::std::string,
                                          val: *const root::octave_value);
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map7rmfieldERKSs"]
        pub fn octave_scalar_map_rmfield(this: *mut root::octave_scalar_map,
                                         key: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsEv"]
        pub fn octave_scalar_map_orderfields(this:
                                                 *const root::octave_scalar_map)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsER5ArrayIiE"]
        pub fn octave_scalar_map_orderfields1(this:
                                                  *const root::octave_scalar_map,
                                              perm:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsERKS_R5ArrayIiE"]
        pub fn octave_scalar_map_orderfields2(this:
                                                  *const root::octave_scalar_map,
                                              other:
                                                  *const root::octave_scalar_map,
                                              perm:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map8contentsERKSs"]
        pub fn octave_scalar_map_contents(this:
                                              *const root::octave_scalar_map,
                                          k: *const root::std::string)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map8contentsERKSs"]
        pub fn octave_scalar_map_contents1(this: *mut root::octave_scalar_map,
                                           k: *const root::std::string)
         -> *mut root::octave_value;
    }
    impl octave_scalar_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string)
         -> root::octave_value {
            octave_scalar_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(&mut self, key: *const root::std::string,
                               val: *const root::octave_value) {
            octave_scalar_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_scalar_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_scalar_map {
            octave_scalar_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(&self,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_scalar_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(&self,
                                   other: *const root::octave_scalar_map,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_scalar_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string)
         -> root::octave_value {
            octave_scalar_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string)
         -> *mut root::octave_value {
            octave_scalar_map_contents1(self, k)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_stream([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_function {
        pub _base: root::octave_base_value,
        pub relative: bool,
        pub locked: bool,
        pub private_function: bool,
        pub xdispatch_class: root::std::string,
        pub xpackage_name: root::std::string,
        pub my_name: root::std::string,
        pub my_dir_name: root::std::string,
        pub doc: root::std::string,
    }
    #[test]
    fn bindgen_test_layout_octave_function() {
        assert_eq!(::std::mem::size_of::<octave_function>() , 56usize , concat
                   ! ( "Size of: " , stringify ! ( octave_function ) ));
        assert_eq! (::std::mem::align_of::<octave_function>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . relative as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( relative ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . locked as *
                    const _ as usize } , 13usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( locked ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) .
                    private_function as * const _ as usize } , 14usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( private_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . xdispatch_class
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( xdispatch_class ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . xpackage_name
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( xpackage_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . my_name as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( my_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . my_dir_name as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( my_dir_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . doc as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( doc ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_function([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_handle([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_inline([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value_list {
        pub data: root::Array<root::octave_value>,
        pub names: root::string_vector,
    }
    #[test]
    fn bindgen_test_layout_octave_value_list() {
        assert_eq!(::std::mem::size_of::<octave_value_list>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_value_list )
                   ));
        assert_eq! (::std::mem::align_of::<octave_value_list>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_value_list ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_list ) ) . data as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value_list )
                    , "::" , stringify ! ( data ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_list ) ) . names as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value_list )
                    , "::" , stringify ! ( names ) ));
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list7prependERK12octave_value"]
        pub fn octave_value_list_prepend(this: *mut root::octave_value_list,
                                         val: *const root::octave_value)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list6appendERK12octave_value"]
        pub fn octave_value_list_append(this: *mut root::octave_value_list,
                                        val: *const root::octave_value)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list6appendERKS_"]
        pub fn octave_value_list_append1(this: *mut root::octave_value_list,
                                         lst: *const root::octave_value_list)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list7reverseEv"]
        pub fn octave_value_list_reverse(this: *mut root::octave_value_list)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list6spliceEiiRKS_"]
        pub fn octave_value_list_splice(this: *const root::octave_value_list,
                                        offset: root::octave_idx_type,
                                        len: root::octave_idx_type,
                                        lst: *const root::octave_value_list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list13all_strings_pEv"]
        pub fn octave_value_list_all_strings_p(this:
                                                   *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list11all_scalarsEv"]
        pub fn octave_value_list_all_scalars(this:
                                                 *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list8any_cellEv"]
        pub fn octave_value_list_any_cell(this:
                                              *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list15has_magic_colonEv"]
        pub fn octave_value_list_has_magic_colon(this:
                                                     *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list9make_argvERKSs"]
        pub fn octave_value_list_make_argv(this:
                                               *const root::octave_value_list,
                                           arg1: *const root::std::string)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list20make_storable_valuesEv"]
        pub fn octave_value_list_make_storable_values(this:
                                                          *mut root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_listC1ERKSt4listIS_SaIS_EE"]
        pub fn octave_value_list_octave_value_list(this:
                                                       *mut root::octave_value_list,
                                                   arg1:
                                                       *const root::std::list);
    }
    impl octave_value_list {
        #[inline]
        pub unsafe fn prepend(&mut self, val: *const root::octave_value)
         -> *mut root::octave_value_list {
            octave_value_list_prepend(self, val)
        }
        #[inline]
        pub unsafe fn append(&mut self, val: *const root::octave_value)
         -> *mut root::octave_value_list {
            octave_value_list_append(self, val)
        }
        #[inline]
        pub unsafe fn append1(&mut self, lst: *const root::octave_value_list)
         -> *mut root::octave_value_list {
            octave_value_list_append1(self, lst)
        }
        #[inline]
        pub unsafe fn reverse(&mut self) -> *mut root::octave_value_list {
            octave_value_list_reverse(self)
        }
        #[inline]
        pub unsafe fn splice(&self, offset: root::octave_idx_type,
                             len: root::octave_idx_type,
                             lst: *const root::octave_value_list)
         -> root::octave_value_list {
            octave_value_list_splice(self, offset, len, lst)
        }
        #[inline]
        pub unsafe fn all_strings_p(&self) -> bool {
            octave_value_list_all_strings_p(self)
        }
        #[inline]
        pub unsafe fn all_scalars(&self) -> bool {
            octave_value_list_all_scalars(self)
        }
        #[inline]
        pub unsafe fn any_cell(&self) -> bool {
            octave_value_list_any_cell(self)
        }
        #[inline]
        pub unsafe fn has_magic_colon(&self) -> bool {
            octave_value_list_has_magic_colon(self)
        }
        #[inline]
        pub unsafe fn make_argv(&self, arg1: *const root::std::string)
         -> root::string_vector {
            octave_value_list_make_argv(self, arg1)
        }
        #[inline]
        pub unsafe fn make_storable_values(&mut self) {
            octave_value_list_make_storable_values(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_list_octave_value_list(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_lvalue([u8; 0]);
    pub type octave_hdf5_id = i64;
    pub type octave_hdf5_err = ::std::os::raw::c_int;
    #[repr(C)]
    pub struct octave_value__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value {
        pub vtable_: *const octave_value__bindgen_vtable,
        pub rep: *mut root::octave_base_value,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_unary_op {
        op_not = 0,
        op_uplus = 1,
        op_uminus = 2,
        op_transpose = 3,
        op_hermitian = 4,
        op_incr = 5,
        op_decr = 6,
        num_unary_ops = 7,
        unknown_unary_op = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_binary_op {
        op_add = 0,
        op_sub = 1,
        op_mul = 2,
        op_div = 3,
        op_pow = 4,
        op_ldiv = 5,
        op_lt = 6,
        op_le = 7,
        op_eq = 8,
        op_ge = 9,
        op_gt = 10,
        op_ne = 11,
        op_el_mul = 12,
        op_el_div = 13,
        op_el_pow = 14,
        op_el_ldiv = 15,
        op_el_and = 16,
        op_el_or = 17,
        op_struct_ref = 18,
        num_binary_ops = 19,
        unknown_binary_op = 20,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_compound_binary_op {
        op_trans_mul = 0,
        op_mul_trans = 1,
        op_herm_mul = 2,
        op_mul_herm = 3,
        op_trans_ldiv = 4,
        op_herm_ldiv = 5,
        op_el_not_and = 6,
        op_el_not_or = 7,
        op_el_and_not = 8,
        op_el_or_not = 9,
        num_compound_binary_ops = 10,
        unknown_compound_binary_op = 11,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_assign_op {
        op_asn_eq = 0,
        op_add_eq = 1,
        op_sub_eq = 2,
        op_mul_eq = 3,
        op_div_eq = 4,
        op_ldiv_eq = 5,
        op_pow_eq = 6,
        op_el_mul_eq = 7,
        op_el_div_eq = 8,
        op_el_ldiv_eq = 9,
        op_el_pow_eq = 10,
        op_el_and_eq = 11,
        op_el_or_eq = 12,
        num_assign_ops = 13,
        unknown_assign_op = 14,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_magic_colon { magic_colon_t = 0, }
    #[test]
    fn bindgen_test_layout_octave_value() {
        assert_eq!(::std::mem::size_of::<octave_value>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( octave_value ) ));
        assert_eq! (::std::mem::align_of::<octave_value>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( octave_value ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value ) ) . rep as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value ) ,
                    "::" , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value22assign_op_to_binary_opENS_9assign_opE"]
        pub fn octave_value_assign_op_to_binary_op(arg1:
                                                       root::octave_value_assign_op)
         -> root::octave_value_binary_op;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value22binary_op_to_assign_opENS_9binary_opE"]
        pub fn octave_value_binary_op_to_assign_op(arg1:
                                                       root::octave_value_binary_op)
         -> root::octave_value_assign_op;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value18unary_op_as_stringENS_8unary_opE"]
        pub fn octave_value_unary_op_as_string(arg1:
                                                   root::octave_value_unary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value17unary_op_fcn_nameENS_8unary_opE"]
        pub fn octave_value_unary_op_fcn_name(arg1:
                                                  root::octave_value_unary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19binary_op_as_stringENS_9binary_opE"]
        pub fn octave_value_binary_op_as_string(arg1:
                                                    root::octave_value_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value18binary_op_fcn_nameENS_9binary_opE"]
        pub fn octave_value_binary_op_fcn_name(arg1:
                                                   root::octave_value_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value18binary_op_fcn_nameENS_18compound_binary_opE"]
        pub fn octave_value_binary_op_fcn_name1(arg1:
                                                    root::octave_value_compound_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19assign_op_as_stringENS_9assign_opE"]
        pub fn octave_value_assign_op_as_string(arg1:
                                                    root::octave_value_assign_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value10empty_convERKSsRKS_"]
        pub fn octave_value_empty_conv(type_: *const root::std::string,
                                       rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value5cloneEv"]
        pub fn octave_value_clone(this: *const root::octave_value)
         -> *mut root::octave_base_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value12maybe_mutateEv"]
        pub fn octave_value_maybe_mutate(this: *mut root::octave_value);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value14single_subsrefERKSsRK17octave_value_list"]
        pub fn octave_value_single_subsref(this: *mut root::octave_value,
                                           type_: *const root::std::string,
                                           idx:
                                               *const root::octave_value_list)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value7subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEi"]
        pub fn octave_value_subsref(this: *mut root::octave_value,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list,
                                    nargout: ::std::os::raw::c_int)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value7subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEiPKS2_I13octave_lvalueSaIS8_EE"]
        pub fn octave_value_subsref1(this: *mut root::octave_value,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     nargout: ::std::os::raw::c_int,
                                     lvalue_list: *const root::std::list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref(this: *mut root::octave_value,
                                         type_: *const root::std::string,
                                         idx: *const root::std::list,
                                         skip: usize) -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEiRKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref1(this: *mut root::octave_value,
                                          nargout: ::std::os::raw::c_int,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          skip: usize)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEiRKSsRKSt4listI17octave_value_listSaIS3_EEPKS2_I13octave_lvalueSaIS8_EEy"]
        pub fn octave_value_next_subsref2(this: *mut root::octave_value,
                                          nargout: ::std::os::raw::c_int,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          lvalue_list: *const root::std::list,
                                          skip: usize)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEbRKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref3(this: *mut root::octave_value,
                                          auto_add: bool,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          skip: usize) -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value17do_multi_index_opEiRK17octave_value_list"]
        pub fn octave_value_do_multi_index_op(this: *mut root::octave_value,
                                              nargout: ::std::os::raw::c_int,
                                              idx:
                                                  *const root::octave_value_list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value17do_multi_index_opEiRK17octave_value_listPKSt4listI13octave_lvalueSaIS4_EE"]
        pub fn octave_value_do_multi_index_op1(this: *mut root::octave_value,
                                               nargout: ::std::os::raw::c_int,
                                               idx:
                                                   *const root::octave_value_list,
                                               lvalue_list:
                                                   *const root::std::list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value8subsasgnERKSsRKSt4listI17octave_value_listSaIS3_EERKS_"]
        pub fn octave_value_subsasgn(this: *mut root::octave_value,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value14undef_subsasgnERKSsRKSt4listI17octave_value_listSaIS3_EERKS_"]
        pub fn octave_value_undef_subsasgn(this: *mut root::octave_value,
                                           type_: *const root::std::string,
                                           idx: *const root::std::list,
                                           rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value6assignENS_9assign_opERKSsRKSt4listI17octave_value_listSaIS4_EERKS_"]
        pub fn octave_value_assign(this: *mut root::octave_value,
                                   op: root::octave_value_assign_op,
                                   type_: *const root::std::string,
                                   idx: *const root::std::list,
                                   rhs: *const root::octave_value)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value6assignENS_9assign_opERKS_"]
        pub fn octave_value_assign1(this: *mut root::octave_value,
                                    arg1: root::octave_value_assign_op,
                                    rhs: *const root::octave_value)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value6lengthEv"]
        pub fn octave_value_length(this: *const root::octave_value)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value8is_equalERKS_"]
        pub fn octave_value_is_equal(this: *const root::octave_value,
                                     arg1: *const root::octave_value) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14idx_type_valueEbb"]
        pub fn octave_value_idx_type_value(this: *const root::octave_value,
                                           req_int: bool, frc_str_conv: bool)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10cell_valueEv"]
        pub fn octave_value_cell_value(this: *const root::octave_value)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value9map_valueEv"]
        pub fn octave_value_map_value(this: *const root::octave_value)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16scalar_map_valueEv"]
        pub fn octave_value_scalar_map_value(this: *const root::octave_value)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14function_valueEb"]
        pub fn octave_value_function_value(this: *const root::octave_value,
                                           silent: bool)
         -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19user_function_valueEb"]
        pub fn octave_value_user_function_value(this:
                                                    *const root::octave_value,
                                                silent: bool)
         -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17user_script_valueEb"]
        pub fn octave_value_user_script_value(this: *const root::octave_value,
                                              silent: bool)
         -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15user_code_valueEb"]
        pub fn octave_value_user_code_value(this: *const root::octave_value,
                                            silent: bool)
         -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16fcn_handle_valueEb"]
        pub fn octave_value_fcn_handle_value(this: *const root::octave_value,
                                             silent: bool)
         -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16fcn_inline_valueEb"]
        pub fn octave_value_fcn_inline_value(this: *const root::octave_value,
                                             silent: bool)
         -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10list_valueEv"]
        pub fn octave_value_list_value(this: *const root::octave_value)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19column_vector_valueEbb"]
        pub fn octave_value_column_vector_value(this:
                                                    *const root::octave_value,
                                                frc_str_conv: bool,
                                                frc_vec_conv: bool)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27complex_column_vector_valueEbb"]
        pub fn octave_value_complex_column_vector_value(this:
                                                            *const root::octave_value,
                                                        frc_str_conv: bool,
                                                        frc_vec_conv: bool)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16row_vector_valueEbb"]
        pub fn octave_value_row_vector_value(this: *const root::octave_value,
                                             frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value24complex_row_vector_valueEbb"]
        pub fn octave_value_complex_row_vector_value(this:
                                                         *const root::octave_value,
                                                     frc_str_conv: bool,
                                                     frc_vec_conv: bool)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25float_column_vector_valueEbb"]
        pub fn octave_value_float_column_vector_value(this:
                                                          *const root::octave_value,
                                                      frc_str_conv: bool,
                                                      frc_vec_conv: bool)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value33float_complex_column_vector_valueEbb"]
        pub fn octave_value_float_complex_column_vector_value(this:
                                                                  *const root::octave_value,
                                                              frc_str_conv:
                                                                  bool,
                                                              frc_vec_conv:
                                                                  bool)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value22float_row_vector_valueEbb"]
        pub fn octave_value_float_row_vector_value(this:
                                                       *const root::octave_value,
                                                   frc_str_conv: bool,
                                                   frc_vec_conv: bool)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value30float_complex_row_vector_valueEbb"]
        pub fn octave_value_float_complex_row_vector_value(this:
                                                               *const root::octave_value,
                                                           frc_str_conv: bool,
                                                           frc_vec_conv: bool)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16int_vector_valueEbbb"]
        pub fn octave_value_int_vector_value(this: *const root::octave_value,
                                             req_int: bool,
                                             frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28octave_idx_type_vector_valueEbbb"]
        pub fn octave_value_octave_idx_type_vector_value(this:
                                                             *const root::octave_value,
                                                         req_int: bool,
                                                         frc_str_conv: bool,
                                                         frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12vector_valueEbb"]
        pub fn octave_value_vector_value(this: *const root::octave_value,
                                         frc_str_conv: bool,
                                         frc_vec_conv: bool)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20complex_vector_valueEbb"]
        pub fn octave_value_complex_vector_value(this:
                                                     *const root::octave_value,
                                                 frc_str_conv: bool,
                                                 frc_vec_conv: bool)
         -> root::Array<root::std::complex<f64>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18float_vector_valueEbb"]
        pub fn octave_value_float_vector_value(this:
                                                   *const root::octave_value,
                                               frc_str_conv: bool,
                                               frc_vec_conv: bool)
         -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26float_complex_vector_valueEbb"]
        pub fn octave_value_float_complex_vector_value(this:
                                                           *const root::octave_value,
                                                       frc_str_conv: bool,
                                                       frc_vec_conv: bool)
         -> root::Array<root::std::complex<f32>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xshort_valueEPKcz"]
        pub fn octave_value_xshort_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_short;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xushort_valueEPKcz"]
        pub fn octave_value_xushort_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_ushort;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10xint_valueEPKcz"]
        pub fn octave_value_xint_value(this: *const root::octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xuint_valueEPKcz"]
        pub fn octave_value_xuint_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xnint_valueEPKcz"]
        pub fn octave_value_xnint_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xlong_valueEPKcz"]
        pub fn octave_value_xlong_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xulong_valueEPKcz"]
        pub fn octave_value_xulong_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xint64_valueEPKcz"]
        pub fn octave_value_xint64_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> i64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xuint64_valueEPKcz"]
        pub fn octave_value_xuint64_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> u64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15xidx_type_valueEPKcz"]
        pub fn octave_value_xidx_type_value(this: *const root::octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xdouble_valueEPKcz"]
        pub fn octave_value_xdouble_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xfloat_valueEPKcz"]
        pub fn octave_value_xfloat_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xscalar_valueEPKcz"]
        pub fn octave_value_xscalar_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_scalar_valueEPKcz"]
        pub fn octave_value_xfloat_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xmatrix_valueEPKcz"]
        pub fn octave_value_xmatrix_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_matrix_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xarray_valueEPKcz"]
        pub fn octave_value_xarray_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xfloat_array_valueEPKcz"]
        pub fn octave_value_xfloat_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14xcomplex_valueEPKcz"]
        pub fn octave_value_xcomplex_value(this: *const root::octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xfloat_complex_valueEPKcz"]
        pub fn octave_value_xfloat_complex_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value21xcomplex_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_matrix_value(this:
                                                      *const root::octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27xfloat_complex_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_matrix_value(this:
                                                            *const root::octave_value,
                                                        fmt:
                                                            *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xcomplex_array_valueEPKcz"]
        pub fn octave_value_xcomplex_array_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xfloat_complex_array_valueEPKcz"]
        pub fn octave_value_xfloat_complex_array_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xbool_valueEPKcz"]
        pub fn octave_value_xbool_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xbool_matrix_valueEPKcz"]
        pub fn octave_value_xbool_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xbool_array_valueEPKcz"]
        pub fn octave_value_xbool_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xchar_matrix_valueEPKcz"]
        pub fn octave_value_xchar_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xchar_array_valueEPKcz"]
        pub fn octave_value_xchar_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xsparse_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_matrix_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28xsparse_complex_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_complex_matrix_value(this:
                                                             *const root::octave_value,
                                                         fmt:
                                                             *const ::std::os::raw::c_char, ...)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25xsparse_bool_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_bool_matrix_value(this:
                                                          *const root::octave_value,
                                                      fmt:
                                                          *const ::std::os::raw::c_char, ...)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xdiag_matrix_valueEPKcz"]
        pub fn octave_value_xdiag_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value24xfloat_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_diag_matrix_value(this:
                                                         *const root::octave_value,
                                                     fmt:
                                                         *const ::std::os::raw::c_char, ...)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xcomplex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_diag_matrix_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value32xfloat_complex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_diag_matrix_value(this:
                                                                 *const root::octave_value,
                                                             fmt:
                                                                 *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xperm_matrix_valueEPKcz"]
        pub fn octave_value_xperm_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint8_scalar_valueEPKcz"]
        pub fn octave_value_xint8_scalar_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::octave_int8;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint16_scalar_valueEPKcz"]
        pub fn octave_value_xint16_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int16;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint32_scalar_valueEPKcz"]
        pub fn octave_value_xint32_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint64_scalar_valueEPKcz"]
        pub fn octave_value_xint64_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint8_scalar_valueEPKcz"]
        pub fn octave_value_xuint8_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_uint8;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint16_scalar_valueEPKcz"]
        pub fn octave_value_xuint16_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint16;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint32_scalar_valueEPKcz"]
        pub fn octave_value_xuint32_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint64_scalar_valueEPKcz"]
        pub fn octave_value_xuint64_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xint8_array_valueEPKcz"]
        pub fn octave_value_xint8_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::int8NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint16_array_valueEPKcz"]
        pub fn octave_value_xint16_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int16NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint32_array_valueEPKcz"]
        pub fn octave_value_xint32_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int32NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint64_array_valueEPKcz"]
        pub fn octave_value_xint64_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int64NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xuint8_array_valueEPKcz"]
        pub fn octave_value_xuint8_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::uint8NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint16_array_valueEPKcz"]
        pub fn octave_value_xuint16_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint16NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint32_array_valueEPKcz"]
        pub fn octave_value_xuint32_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint32NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint64_array_valueEPKcz"]
        pub fn octave_value_xuint64_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint64NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xstring_valueEPKcz"]
        pub fn octave_value_xstring_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xstring_vector_valueEPKcz"]
        pub fn octave_value_xstring_vector_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xcell_valueEPKcz"]
        pub fn octave_value_xcell_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14xcellstr_valueEPKcz"]
        pub fn octave_value_xcellstr_value(this: *const root::octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xrange_valueEPKcz"]
        pub fn octave_value_xrange_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10xmap_valueEPKcz"]
        pub fn octave_value_xmap_value(this: *const root::octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xscalar_map_valueEPKcz"]
        pub fn octave_value_xscalar_map_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xcolumn_vector_valueEPKcz"]
        pub fn octave_value_xcolumn_vector_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28xcomplex_column_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_column_vector_value(this:
                                                             *const root::octave_value,
                                                         fmt:
                                                             *const ::std::os::raw::c_char, ...)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xrow_vector_valueEPKcz"]
        pub fn octave_value_xrow_vector_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25xcomplex_row_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_row_vector_value(this:
                                                          *const root::octave_value,
                                                      fmt:
                                                          *const ::std::os::raw::c_char, ...)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xfloat_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_column_vector_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value34xfloat_complex_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_column_vector_value(this:
                                                                   *const root::octave_value,
                                                               fmt:
                                                                   *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value23xfloat_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_row_vector_value(this:
                                                        *const root::octave_value,
                                                    fmt:
                                                        *const ::std::os::raw::c_char, ...)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value31xfloat_complex_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_row_vector_value(this:
                                                                *const root::octave_value,
                                                            fmt:
                                                                *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xint_vector_valueEPKcz"]
        pub fn octave_value_xint_vector_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value29xoctave_idx_type_vector_valueEPKcz"]
        pub fn octave_value_xoctave_idx_type_vector_value(this:
                                                              *const root::octave_value,
                                                          fmt:
                                                              *const ::std::os::raw::c_char, ...)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xvector_valueEPKcz"]
        pub fn octave_value_xvector_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value21xcomplex_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_vector_value(this:
                                                      *const root::octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
         -> root::Array<root::std::complex<f64>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_vector_valueEPKcz"]
        pub fn octave_value_xfloat_vector_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27xfloat_complex_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_vector_value(this:
                                                            *const root::octave_value,
                                                        fmt:
                                                            *const ::std::os::raw::c_char, ...)
         -> root::Array<root::std::complex<f32>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15xfunction_valueEPKcz"]
        pub fn octave_value_xfunction_value(this: *const root::octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuser_function_valueEPKcz"]
        pub fn octave_value_xuser_function_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xuser_script_valueEPKcz"]
        pub fn octave_value_xuser_script_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16xuser_code_valueEPKcz"]
        pub fn octave_value_xuser_code_value(this: *const root::octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xfcn_handle_valueEPKcz"]
        pub fn octave_value_xfcn_handle_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xfcn_inline_valueEPKcz"]
        pub fn octave_value_xfcn_inline_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xlist_valueEPKcz"]
        pub fn octave_value_xlist_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14storable_valueEv"]
        pub fn octave_value_storable_value(this: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19make_storable_valueEv"]
        pub fn octave_value_make_storable_value(this:
                                                    *mut root::octave_value);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value21do_non_const_unary_opENS_8unary_opE"]
        pub fn octave_value_do_non_const_unary_op(this:
                                                      *mut root::octave_value,
                                                  op:
                                                      root::octave_value_unary_op)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value21do_non_const_unary_opENS_8unary_opERKSsRKSt4listI17octave_value_listSaIS4_EE"]
        pub fn octave_value_do_non_const_unary_op1(this:
                                                       *mut root::octave_value,
                                                   op:
                                                       root::octave_value_unary_op,
                                                   type_:
                                                       *const root::std::string,
                                                   idx:
                                                       *const root::std::list)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10print_infoERSoRKSs"]
        pub fn octave_value_print_info(this: *const root::octave_value,
                                       os: *mut root::std::ostream,
                                       prefix: *const root::std::string);
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value5writeER13octave_streamiN13oct_data_conv9data_typeEiN6octave9mach_info12float_formatE"]
        pub fn octave_value_write(this: *const root::octave_value,
                                  os: *mut root::octave_stream,
                                  block_size: ::std::os::raw::c_int,
                                  output_type: root::oct_data_conv_data_type,
                                  skip: ::std::os::raw::c_int,
                                  flt_fmt:
                                      root::octave::mach_info_float_format)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Es"]
        pub fn octave_value_octave_value(this: *mut root::octave_value,
                                         i: ::std::os::raw::c_short);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Et"]
        pub fn octave_value_octave_value1(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ushort);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ei"]
        pub fn octave_value_octave_value2(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ej"]
        pub fn octave_value_octave_value3(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1El"]
        pub fn octave_value_octave_value4(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Em"]
        pub fn octave_value_octave_value5(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ulong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ex"]
        pub fn octave_value_octave_value6(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_longlong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ey"]
        pub fn octave_value_octave_value7(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ulonglong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EN6octave3sys4timeE"]
        pub fn octave_value_octave_value8(this: *mut root::octave_value,
                                          t: root::octave::sys::time);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ed"]
        pub fn octave_value_octave_value9(this: *mut root::octave_value,
                                          d: f64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ef"]
        pub fn octave_value_octave_value10(this: *mut root::octave_value,
                                           d: f32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIS_Eb"]
        pub fn octave_value_octave_value11(this: *mut root::octave_value,
                                           a:
                                               *const root::Array<root::octave_value>,
                                           is_cs_list: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK4Cellb"]
        pub fn octave_value_octave_value12(this: *mut root::octave_value,
                                           c: *const root::Cell,
                                           is_cs_list: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6MatrixRK10MatrixType"]
        pub fn octave_value_octave_value13(this: *mut root::octave_value,
                                           m: *const root::Matrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11FloatMatrixRK10MatrixType"]
        pub fn octave_value_octave_value14(this: *mut root::octave_value,
                                           m: *const root::FloatMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK7NDArray"]
        pub fn octave_value_octave_value15(this: *mut root::octave_value,
                                           nda: *const root::NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12FloatNDArray"]
        pub fn octave_value_octave_value16(this: *mut root::octave_value,
                                           nda: *const root::FloatNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIdE"]
        pub fn octave_value_octave_value17(this: *mut root::octave_value,
                                           m: *const root::Array<f64>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIfE"]
        pub fn octave_value_octave_value18(this: *mut root::octave_value,
                                           m: *const root::Array<f32>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagMatrix"]
        pub fn octave_value_octave_value19(this: *mut root::octave_value,
                                           d: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2IdE"]
        pub fn octave_value_octave_value20(this: *mut root::octave_value,
                                           d: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2IfE"]
        pub fn octave_value_octave_value21(this: *mut root::octave_value,
                                           d: *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn octave_value_octave_value22(this: *mut root::octave_value,
                                           d:
                                               *const root::DiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn octave_value_octave_value23(this: *mut root::octave_value,
                                           d:
                                               *const root::DiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK15FloatDiagMatrix"]
        pub fn octave_value_octave_value24(this: *mut root::octave_value,
                                           d: *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK9RowVector"]
        pub fn octave_value_octave_value25(this: *mut root::octave_value,
                                           v: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK14FloatRowVector"]
        pub fn octave_value_octave_value26(this: *mut root::octave_value,
                                           v: *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12ColumnVector"]
        pub fn octave_value_octave_value27(this: *mut root::octave_value,
                                           v: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17FloatColumnVector"]
        pub fn octave_value_octave_value28(this: *mut root::octave_value,
                                           v: *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSt7complexIdE"]
        pub fn octave_value_octave_value29(this: *mut root::octave_value,
                                           C: *const root::Complex);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSt7complexIfE"]
        pub fn octave_value_octave_value30(this: *mut root::octave_value,
                                           C: *const root::FloatComplex);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK13ComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value31(this: *mut root::octave_value,
                                           m: *const root::ComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK18FloatComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value32(this: *mut root::octave_value,
                                           m: *const root::FloatComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK14ComplexNDArray"]
        pub fn octave_value_octave_value33(this: *mut root::octave_value,
                                           cnda: *const root::ComplexNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK19FloatComplexNDArray"]
        pub fn octave_value_octave_value34(this: *mut root::octave_value,
                                           cnda:
                                               *const root::FloatComplexNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISt7complexIdEE"]
        pub fn octave_value_octave_value35(this: *mut root::octave_value,
                                           m:
                                               *const root::Array<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISt7complexIfEE"]
        pub fn octave_value_octave_value36(this: *mut root::octave_value,
                                           m:
                                               *const root::Array<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17ComplexDiagMatrix"]
        pub fn octave_value_octave_value37(this: *mut root::octave_value,
                                           d: *const root::ComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK22FloatComplexDiagMatrix"]
        pub fn octave_value_octave_value38(this: *mut root::octave_value,
                                           d:
                                               *const root::FloatComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK16ComplexRowVector"]
        pub fn octave_value_octave_value39(this: *mut root::octave_value,
                                           v: *const root::ComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK21FloatComplexRowVector"]
        pub fn octave_value_octave_value40(this: *mut root::octave_value,
                                           v:
                                               *const root::FloatComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK19ComplexColumnVector"]
        pub fn octave_value_octave_value41(this: *mut root::octave_value,
                                           v:
                                               *const root::ComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK24FloatComplexColumnVector"]
        pub fn octave_value_octave_value42(this: *mut root::octave_value,
                                           v:
                                               *const root::FloatComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10PermMatrix"]
        pub fn octave_value_octave_value43(this: *mut root::octave_value,
                                           p: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Eb"]
        pub fn octave_value_octave_value44(this: *mut root::octave_value,
                                           b: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10boolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value45(this: *mut root::octave_value,
                                           bm: *const root::boolMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11boolNDArray"]
        pub fn octave_value_octave_value46(this: *mut root::octave_value,
                                           bnda: *const root::boolNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIbE"]
        pub fn octave_value_octave_value47(this: *mut root::octave_value,
                                           bnda: *const root::Array<bool>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ecc"]
        pub fn octave_value_octave_value48(this: *mut root::octave_value,
                                           c: ::std::os::raw::c_char,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EPKcc"]
        pub fn octave_value_octave_value49(this: *mut root::octave_value,
                                           s: *const ::std::os::raw::c_char,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSsc"]
        pub fn octave_value_octave_value50(this: *mut root::octave_value,
                                           s: *const root::std::string,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK13string_vectorc"]
        pub fn octave_value_octave_value51(this: *mut root::octave_value,
                                           s: *const root::string_vector,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10charMatrixc"]
        pub fn octave_value_octave_value52(this: *mut root::octave_value,
                                           chm: *const root::charMatrix,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11charNDArrayc"]
        pub fn octave_value_octave_value53(this: *mut root::octave_value,
                                           chnda: *const root::charNDArray,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIcEc"]
        pub fn octave_value_octave_value54(this: *mut root::octave_value,
                                           chnda:
                                               *const root::Array<::std::os::raw::c_char>,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10charMatrixbc"]
        pub fn octave_value_octave_value55(this: *mut root::octave_value,
                                           chm: *const root::charMatrix,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11charNDArraybc"]
        pub fn octave_value_octave_value56(this: *mut root::octave_value,
                                           chnda: *const root::charNDArray,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIcEbc"]
        pub fn octave_value_octave_value57(this: *mut root::octave_value,
                                           chnda:
                                               *const root::Array<::std::os::raw::c_char>,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12SparseMatrixRK10MatrixType"]
        pub fn octave_value_octave_value58(this: *mut root::octave_value,
                                           m: *const root::SparseMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6SparseIdERK10MatrixType"]
        pub fn octave_value_octave_value59(this: *mut root::octave_value,
                                           m: *const root::Sparse<f64>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK19SparseComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value60(this: *mut root::octave_value,
                                           m:
                                               *const root::SparseComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK6SparseISt7complexIdEERK10MatrixType"]
        pub fn octave_value_octave_value61(this: *mut root::octave_value,
                                           m:
                                               *const root::Sparse<root::std::complex<f64>>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK16SparseBoolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value62(this: *mut root::octave_value,
                                           bm: *const root::SparseBoolMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6SparseIbERK10MatrixType"]
        pub fn octave_value_octave_value63(this: *mut root::octave_value,
                                           m: *const root::Sparse<bool>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIaE"]
        pub fn octave_value_octave_value64(this: *mut root::octave_value,
                                           i: *const root::octave_int8);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIsE"]
        pub fn octave_value_octave_value65(this: *mut root::octave_value,
                                           i: *const root::octave_int16);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIiE"]
        pub fn octave_value_octave_value66(this: *mut root::octave_value,
                                           i: *const root::octave_int32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIxE"]
        pub fn octave_value_octave_value67(this: *mut root::octave_value,
                                           i: *const root::octave_int64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIhE"]
        pub fn octave_value_octave_value68(this: *mut root::octave_value,
                                           i: *const root::octave_uint8);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intItE"]
        pub fn octave_value_octave_value69(this: *mut root::octave_value,
                                           i: *const root::octave_uint16);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIjE"]
        pub fn octave_value_octave_value70(this: *mut root::octave_value,
                                           i: *const root::octave_uint32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIyE"]
        pub fn octave_value_octave_value71(this: *mut root::octave_value,
                                           i: *const root::octave_uint64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value72(this: *mut root::octave_value,
                                           inda: *const root::int8NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value73(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_schar>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value74(this: *mut root::octave_value,
                                           inda: *const root::int16NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value75(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_short>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value76(this: *mut root::octave_value,
                                           inda: *const root::int32NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value77(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_int>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIxEE"]
        pub fn octave_value_octave_value78(this: *mut root::octave_value,
                                           inda: *const root::int64NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIxEE"]
        pub fn octave_value_octave_value79(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_longlong>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value80(this: *mut root::octave_value,
                                           inda: *const root::uint8NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value81(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_uchar>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intItEE"]
        pub fn octave_value_octave_value82(this: *mut root::octave_value,
                                           inda: *const root::uint16NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intItEE"]
        pub fn octave_value_octave_value83(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_ushort>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value84(this: *mut root::octave_value,
                                           inda: *const root::uint32NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value85(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_uint>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIyEE"]
        pub fn octave_value_octave_value86(this: *mut root::octave_value,
                                           inda: *const root::uint64NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIyEE"]
        pub fn octave_value_octave_value87(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_ulonglong>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIiEbb"]
        pub fn octave_value_octave_value88(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<::std::os::raw::c_int>,
                                           zero_based: bool,
                                           cache_index: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISsE"]
        pub fn octave_value_octave_value89(this: *mut root::octave_value,
                                           cellstr:
                                               *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                                          root::std::allocator>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10idx_vectorb"]
        pub fn octave_value_octave_value90(this: *mut root::octave_value,
                                           idx: *const root::idx_vector,
                                           lazy: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Eddd"]
        pub fn octave_value_octave_value91(this: *mut root::octave_value,
                                           base: f64, limit: f64, inc: f64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5Rangeb"]
        pub fn octave_value_octave_value92(this: *mut root::octave_value,
                                           r: *const root::Range,
                                           force_range: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_map"]
        pub fn octave_value_octave_value93(this: *mut root::octave_value,
                                           m: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17octave_scalar_map"]
        pub fn octave_value_octave_value94(this: *mut root::octave_value,
                                           m: *const root::octave_scalar_map);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK10octave_mapRKSsRKSt4listISsSaISsEE"]
        pub fn octave_value_octave_value95(this: *mut root::octave_value,
                                           m: *const root::octave_map,
                                           id: *const root::std::string,
                                           plist: *const root::std::list);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK17octave_scalar_mapRKSsRKSt4listISsSaISsEE"]
        pub fn octave_value_octave_value96(this: *mut root::octave_value,
                                           m: *const root::octave_scalar_map,
                                           id: *const root::std::string,
                                           plist: *const root::std::list);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17octave_value_listb"]
        pub fn octave_value_octave_value97(this: *mut root::octave_value,
                                           m: *const root::octave_value_list,
                                           arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ENS_11magic_colonE"]
        pub fn octave_value_octave_value98(this: *mut root::octave_value,
                                           arg1:
                                               root::octave_value_magic_colon);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EP17octave_base_valueb"]
        pub fn octave_value_octave_value99(this: *mut root::octave_value,
                                           new_rep:
                                               *mut root::octave_base_value,
                                           borrow: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EP17octave_base_valuei"]
        pub fn octave_value_octave_value100(this: *mut root::octave_value,
                                            new_rep:
                                                *mut root::octave_base_value,
                                            xcount: ::std::os::raw::c_int);
    }
    impl octave_value {
        #[inline]
        pub unsafe fn assign_op_to_binary_op(arg1:
                                                 root::octave_value_assign_op)
         -> root::octave_value_binary_op {
            octave_value_assign_op_to_binary_op(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_to_assign_op(arg1:
                                                 root::octave_value_binary_op)
         -> root::octave_value_assign_op {
            octave_value_binary_op_to_assign_op(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_as_string(arg1: root::octave_value_unary_op)
         -> root::std::string {
            octave_value_unary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_fcn_name(arg1: root::octave_value_unary_op)
         -> root::std::string {
            octave_value_unary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_as_string(arg1: root::octave_value_binary_op)
         -> root::std::string {
            octave_value_binary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name(arg1: root::octave_value_binary_op)
         -> root::std::string {
            octave_value_binary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name1(arg1:
                                              root::octave_value_compound_binary_op)
         -> root::std::string {
            octave_value_binary_op_fcn_name1(arg1)
        }
        #[inline]
        pub unsafe fn assign_op_as_string(arg1: root::octave_value_assign_op)
         -> root::std::string {
            octave_value_assign_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn empty_conv(type_: *const root::std::string,
                                 rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_empty_conv(type_, rhs)
        }
        #[inline]
        pub unsafe fn clone(&self) -> *mut root::octave_base_value {
            octave_value_clone(self)
        }
        #[inline]
        pub unsafe fn maybe_mutate(&mut self) {
            octave_value_maybe_mutate(self)
        }
        #[inline]
        pub unsafe fn single_subsref(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::octave_value_list)
         -> root::octave_value {
            octave_value_single_subsref(self, type_, idx)
        }
        #[inline]
        pub unsafe fn subsref(&mut self, type_: *const root::std::string,
                              idx: *const root::std::list,
                              nargout: ::std::os::raw::c_int)
         -> root::octave_value_list {
            octave_value_subsref(self, type_, idx, nargout)
        }
        #[inline]
        pub unsafe fn subsref1(&mut self, type_: *const root::std::string,
                               idx: *const root::std::list,
                               nargout: ::std::os::raw::c_int,
                               lvalue_list: *const root::std::list)
         -> root::octave_value_list {
            octave_value_subsref1(self, type_, idx, nargout, lvalue_list)
        }
        #[inline]
        pub unsafe fn next_subsref(&mut self, type_: *const root::std::string,
                                   idx: *const root::std::list, skip: usize)
         -> root::octave_value {
            octave_value_next_subsref(self, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref1(&mut self, nargout: ::std::os::raw::c_int,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list, skip: usize)
         -> root::octave_value_list {
            octave_value_next_subsref1(self, nargout, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref2(&mut self, nargout: ::std::os::raw::c_int,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list,
                                    lvalue_list: *const root::std::list,
                                    skip: usize) -> root::octave_value_list {
            octave_value_next_subsref2(self, nargout, type_, idx, lvalue_list,
                                       skip)
        }
        #[inline]
        pub unsafe fn next_subsref3(&mut self, auto_add: bool,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list, skip: usize)
         -> root::octave_value {
            octave_value_next_subsref3(self, auto_add, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn do_multi_index_op(&mut self,
                                        nargout: ::std::os::raw::c_int,
                                        idx: *const root::octave_value_list)
         -> root::octave_value_list {
            octave_value_do_multi_index_op(self, nargout, idx)
        }
        #[inline]
        pub unsafe fn do_multi_index_op1(&mut self,
                                         nargout: ::std::os::raw::c_int,
                                         idx: *const root::octave_value_list,
                                         lvalue_list: *const root::std::list)
         -> root::octave_value_list {
            octave_value_do_multi_index_op1(self, nargout, idx, lvalue_list)
        }
        #[inline]
        pub unsafe fn subsasgn(&mut self, type_: *const root::std::string,
                               idx: *const root::std::list,
                               rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn undef_subsasgn(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_undef_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign(&mut self, op: root::octave_value_assign_op,
                             type_: *const root::std::string,
                             idx: *const root::std::list,
                             rhs: *const root::octave_value)
         -> *mut root::octave_value {
            octave_value_assign(self, op, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign1(&mut self, arg1: root::octave_value_assign_op,
                              rhs: *const root::octave_value)
         -> *mut root::octave_value {
            octave_value_assign1(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn length(&self) -> root::octave_idx_type {
            octave_value_length(self)
        }
        #[inline]
        pub unsafe fn is_equal(&self, arg1: *const root::octave_value)
         -> bool {
            octave_value_is_equal(self, arg1)
        }
        #[inline]
        pub unsafe fn idx_type_value(&self, req_int: bool, frc_str_conv: bool)
         -> root::octave_idx_type {
            octave_value_idx_type_value(self, req_int, frc_str_conv)
        }
        #[inline]
        pub unsafe fn cell_value(&self) -> root::Cell {
            octave_value_cell_value(self)
        }
        #[inline]
        pub unsafe fn map_value(&self) -> root::octave_map {
            octave_value_map_value(self)
        }
        #[inline]
        pub unsafe fn scalar_map_value(&self) -> root::octave_scalar_map {
            octave_value_scalar_map_value(self)
        }
        #[inline]
        pub unsafe fn function_value(&self, silent: bool)
         -> *mut root::octave_function {
            octave_value_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_function_value(&self, silent: bool)
         -> *mut root::octave_user_function {
            octave_value_user_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_script_value(&self, silent: bool)
         -> *mut root::octave_user_script {
            octave_value_user_script_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_code_value(&self, silent: bool)
         -> *mut root::octave_user_code {
            octave_value_user_code_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_handle_value(&self, silent: bool)
         -> *mut root::octave_fcn_handle {
            octave_value_fcn_handle_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_inline_value(&self, silent: bool)
         -> *mut root::octave_fcn_inline {
            octave_value_fcn_inline_value(self, silent)
        }
        #[inline]
        pub unsafe fn list_value(&self) -> root::octave_value_list {
            octave_value_list_value(self)
        }
        #[inline]
        pub unsafe fn column_vector_value(&self, frc_str_conv: bool,
                                          frc_vec_conv: bool)
         -> root::ColumnVector {
            octave_value_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_column_vector_value(&self, frc_str_conv: bool,
                                                  frc_vec_conv: bool)
         -> root::ComplexColumnVector {
            octave_value_complex_column_vector_value(self, frc_str_conv,
                                                     frc_vec_conv)
        }
        #[inline]
        pub unsafe fn row_vector_value(&self, frc_str_conv: bool,
                                       frc_vec_conv: bool)
         -> root::RowVector {
            octave_value_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_row_vector_value(&self, frc_str_conv: bool,
                                               frc_vec_conv: bool)
         -> root::ComplexRowVector {
            octave_value_complex_row_vector_value(self, frc_str_conv,
                                                  frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_column_vector_value(&self, frc_str_conv: bool,
                                                frc_vec_conv: bool)
         -> root::FloatColumnVector {
            octave_value_float_column_vector_value(self, frc_str_conv,
                                                   frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_column_vector_value(&self,
                                                        frc_str_conv: bool,
                                                        frc_vec_conv: bool)
         -> root::FloatComplexColumnVector {
            octave_value_float_complex_column_vector_value(self, frc_str_conv,
                                                           frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_row_vector_value(&self, frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::FloatRowVector {
            octave_value_float_row_vector_value(self, frc_str_conv,
                                                frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_row_vector_value(&self,
                                                     frc_str_conv: bool,
                                                     frc_vec_conv: bool)
         -> root::FloatComplexRowVector {
            octave_value_float_complex_row_vector_value(self, frc_str_conv,
                                                        frc_vec_conv)
        }
        #[inline]
        pub unsafe fn int_vector_value(&self, req_int: bool,
                                       frc_str_conv: bool, frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int> {
            octave_value_int_vector_value(self, req_int, frc_str_conv,
                                          frc_vec_conv)
        }
        #[inline]
        pub unsafe fn octave_idx_type_vector_value(&self, req_int: bool,
                                                   frc_str_conv: bool,
                                                   frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int> {
            octave_value_octave_idx_type_vector_value(self, req_int,
                                                      frc_str_conv,
                                                      frc_vec_conv)
        }
        #[inline]
        pub unsafe fn vector_value(&self, frc_str_conv: bool,
                                   frc_vec_conv: bool) -> root::Array<f64> {
            octave_value_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_vector_value(&self, frc_str_conv: bool,
                                           frc_vec_conv: bool)
         -> root::Array<root::std::complex<f64>> {
            octave_value_complex_vector_value(self, frc_str_conv,
                                              frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_vector_value(&self, frc_str_conv: bool,
                                         frc_vec_conv: bool)
         -> root::Array<f32> {
            octave_value_float_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_vector_value(&self, frc_str_conv: bool,
                                                 frc_vec_conv: bool)
         -> root::Array<root::std::complex<f32>> {
            octave_value_float_complex_vector_value(self, frc_str_conv,
                                                    frc_vec_conv)
        }
        #[inline]
        pub unsafe fn storable_value(&self) -> root::octave_value {
            octave_value_storable_value(self)
        }
        #[inline]
        pub unsafe fn make_storable_value(&mut self) {
            octave_value_make_storable_value(self)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op(&mut self,
                                            op: root::octave_value_unary_op)
         -> *mut root::octave_value {
            octave_value_do_non_const_unary_op(self, op)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op1(&mut self,
                                             op: root::octave_value_unary_op,
                                             type_: *const root::std::string,
                                             idx: *const root::std::list)
         -> *mut root::octave_value {
            octave_value_do_non_const_unary_op1(self, op, type_, idx)
        }
        #[inline]
        pub unsafe fn print_info(&self, os: *mut root::std::ostream,
                                 prefix: *const root::std::string) {
            octave_value_print_info(self, os, prefix)
        }
        #[inline]
        pub unsafe fn write(&self, os: *mut root::octave_stream,
                            block_size: ::std::os::raw::c_int,
                            output_type: root::oct_data_conv_data_type,
                            skip: ::std::os::raw::c_int,
                            flt_fmt: root::octave::mach_info_float_format)
         -> ::std::os::raw::c_int {
            octave_value_write(self, os, block_size, output_type, skip,
                               flt_fmt)
        }
        #[inline]
        pub unsafe fn new(i: ::std::os::raw::c_short) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(i: ::std::os::raw::c_ushort) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value1(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(i: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value2(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(i: ::std::os::raw::c_uint) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value3(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(i: ::std::os::raw::c_long) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value4(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(i: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value5(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(i: ::std::os::raw::c_longlong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value6(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(i: ::std::os::raw::c_ulonglong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value7(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(t: root::octave::sys::time) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value8(&mut __bindgen_tmp, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(d: f64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value9(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(d: f32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value10(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::Array<root::octave_value>,
                            is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value11(&mut __bindgen_tmp, a, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(c: *const root::Cell, is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value12(&mut __bindgen_tmp, c, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(m: *const root::Matrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value13(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new14(m: *const root::FloatMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value14(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new15(nda: *const root::NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value15(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new16(nda: *const root::FloatNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value16(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new17(m: *const root::Array<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value17(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new18(m: *const root::Array<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value18(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new19(d: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value19(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new20(d: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value20(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new21(d: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value21(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new22(d:
                                *const root::DiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value22(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new23(d:
                                *const root::DiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value23(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new24(d: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value24(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new25(v: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value25(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new26(v: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value26(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new27(v: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value27(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new28(v: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value28(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new29(C: *const root::Complex) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value29(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new30(C: *const root::FloatComplex) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value30(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new31(m: *const root::ComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value31(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new32(m: *const root::FloatComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value32(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new33(cnda: *const root::ComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value33(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new34(cnda: *const root::FloatComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value34(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new35(m: *const root::Array<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value35(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new36(m: *const root::Array<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value36(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new37(d: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value37(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new38(d: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value38(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new39(v: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value39(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new40(v: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value40(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new41(v: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value41(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new42(v: *const root::FloatComplexColumnVector)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value42(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new43(p: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value43(&mut __bindgen_tmp, p);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new44(b: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value44(&mut __bindgen_tmp, b);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new45(bm: *const root::boolMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value45(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new46(bnda: *const root::boolNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value46(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new47(bnda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value47(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new48(c: ::std::os::raw::c_char,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value48(&mut __bindgen_tmp, c, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new49(s: *const ::std::os::raw::c_char,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value49(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new50(s: *const root::std::string,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value50(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new51(s: *const root::string_vector,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value51(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new52(chm: *const root::charMatrix,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value52(&mut __bindgen_tmp, chm, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new53(chnda: *const root::charNDArray,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value53(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new54(chnda: *const root::Array<::std::os::raw::c_char>,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value54(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new55(chm: *const root::charMatrix, is_string: bool,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value55(&mut __bindgen_tmp, chm, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new56(chnda: *const root::charNDArray, is_string: bool,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value56(&mut __bindgen_tmp, chnda, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new57(chnda: *const root::Array<::std::os::raw::c_char>,
                            is_string: bool, type_: ::std::os::raw::c_char)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value57(&mut __bindgen_tmp, chnda, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new58(m: *const root::SparseMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value58(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new59(m: *const root::Sparse<f64>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value59(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new60(m: *const root::SparseComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value60(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new61(m: *const root::Sparse<root::std::complex<f64>>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value61(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new62(bm: *const root::SparseBoolMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value62(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new63(m: *const root::Sparse<bool>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value63(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new64(i: *const root::octave_int8) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value64(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new65(i: *const root::octave_int16) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value65(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new66(i: *const root::octave_int32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value66(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new67(i: *const root::octave_int64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value67(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new68(i: *const root::octave_uint8) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value68(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new69(i: *const root::octave_uint16) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value69(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new70(i: *const root::octave_uint32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value70(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new71(i: *const root::octave_uint64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value71(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new72(inda: *const root::int8NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value72(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new73(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_schar>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value73(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new74(inda: *const root::int16NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value74(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new75(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_short>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value75(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new76(inda: *const root::int32NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value76(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new77(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_int>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value77(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new78(inda: *const root::int64NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value78(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new79(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_longlong>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value79(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new80(inda: *const root::uint8NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value80(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new81(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_uchar>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value81(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new82(inda: *const root::uint16NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value82(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new83(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_ushort>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value83(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new84(inda: *const root::uint32NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value84(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new85(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_uint>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value85(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new86(inda: *const root::uint64NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value86(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new87(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_ulonglong>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value87(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new88(inda: *const root::Array<::std::os::raw::c_int>,
                            zero_based: bool, cache_index: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value88(&mut __bindgen_tmp, inda, zero_based,
                                        cache_index);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new89(cellstr:
                                *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                           root::std::allocator>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value89(&mut __bindgen_tmp, cellstr);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new90(idx: *const root::idx_vector, lazy: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value90(&mut __bindgen_tmp, idx, lazy);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new91(base: f64, limit: f64, inc: f64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value91(&mut __bindgen_tmp, base, limit, inc);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new92(r: *const root::Range, force_range: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value92(&mut __bindgen_tmp, r, force_range);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new93(m: *const root::octave_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value93(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new94(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value94(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new95(m: *const root::octave_map,
                            id: *const root::std::string,
                            plist: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value95(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new96(m: *const root::octave_scalar_map,
                            id: *const root::std::string,
                            plist: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value96(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new97(m: *const root::octave_value_list, arg1: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value97(&mut __bindgen_tmp, m, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new98(arg1: root::octave_value_magic_colon) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value98(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new99(new_rep: *mut root::octave_base_value,
                            borrow: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value99(&mut __bindgen_tmp, new_rep, borrow);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new100(new_rep: *mut root::octave_base_value,
                             xcount: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value100(&mut __bindgen_tmp, new_rep, xcount);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_script([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_code([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tree_walker([u8; 0]);
    pub const builtin_type_t_btyp_num_types: root::builtin_type_t =
        builtin_type_t::btyp_unknown;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum builtin_type_t {
        btyp_double = 0,
        btyp_float = 1,
        btyp_complex = 2,
        btyp_float_complex = 3,
        btyp_int8 = 4,
        btyp_int16 = 5,
        btyp_int32 = 6,
        btyp_int64 = 7,
        btyp_uint8 = 8,
        btyp_uint16 = 9,
        btyp_uint32 = 10,
        btyp_uint64 = 11,
        btyp_bool = 12,
        btyp_char = 13,
        btyp_struct = 14,
        btyp_cell = 15,
        btyp_func_handle = 16,
        btyp_unknown = 17,
    }
    #[repr(C)]
    pub struct octave_base_value__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_base_value {
        pub vtable_: *const octave_base_value__bindgen_vtable,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    pub type octave_base_value_type_conv_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value)
                                  -> *mut root::octave_base_value>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_base_value_type_conv_info {
        pub _fcn: root::octave_base_value_type_conv_fcn,
        pub _type_id: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_octave_base_value_type_conv_info() {
        assert_eq!(::std::mem::size_of::<octave_base_value_type_conv_info>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   octave_base_value_type_conv_info ) ));
        assert_eq! (::std::mem::align_of::<octave_base_value_type_conv_info>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    octave_base_value_type_conv_info ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value_type_conv_info ) )
                    . _fcn as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_base_value_type_conv_info ) , "::" , stringify ! (
                    _fcn ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value_type_conv_info ) )
                    . _type_id as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_base_value_type_conv_info ) , "::" , stringify ! (
                    _type_id ) ));
    }
    impl Clone for octave_base_value_type_conv_info {
        fn clone(&self) -> Self { *self }
    }
    pub const octave_base_value_unary_mapper_t_num_unary_mappers:
              root::octave_base_value_unary_mapper_t =
        octave_base_value_unary_mapper_t::umap_unknown;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_base_value_unary_mapper_t {
        umap_abs = 0,
        umap_acos = 1,
        umap_acosh = 2,
        umap_angle = 3,
        umap_arg = 4,
        umap_asin = 5,
        umap_asinh = 6,
        umap_atan = 7,
        umap_atanh = 8,
        umap_cbrt = 9,
        umap_ceil = 10,
        umap_conj = 11,
        umap_cos = 12,
        umap_cosh = 13,
        umap_erf = 14,
        umap_erfinv = 15,
        umap_erfcinv = 16,
        umap_erfc = 17,
        umap_erfcx = 18,
        umap_erfi = 19,
        umap_dawson = 20,
        umap_exp = 21,
        umap_expm1 = 22,
        umap_isfinite = 23,
        umap_fix = 24,
        umap_floor = 25,
        umap_gamma = 26,
        umap_imag = 27,
        umap_isinf = 28,
        umap_isna = 29,
        umap_isnan = 30,
        umap_lgamma = 31,
        umap_log = 32,
        umap_log2 = 33,
        umap_log10 = 34,
        umap_log1p = 35,
        umap_real = 36,
        umap_round = 37,
        umap_roundb = 38,
        umap_signum = 39,
        umap_sin = 40,
        umap_sinh = 41,
        umap_sqrt = 42,
        umap_tan = 43,
        umap_tanh = 44,
        umap_xisalnum = 45,
        umap_xisalpha = 46,
        umap_xisascii = 47,
        umap_xiscntrl = 48,
        umap_xisdigit = 49,
        umap_xisgraph = 50,
        umap_xislower = 51,
        umap_xisprint = 52,
        umap_xispunct = 53,
        umap_xisspace = 54,
        umap_xisupper = 55,
        umap_xisxdigit = 56,
        umap_xsignbit = 57,
        umap_xtoascii = 58,
        umap_xtolower = 59,
        umap_xtoupper = 60,
        umap_unknown = 61,
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value23curr_print_indent_levelE"]
        pub static mut octave_base_value_curr_print_indent_level:
                   ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value17beginning_of_lineE"]
        pub static mut octave_base_value_beginning_of_line: bool;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value4t_idE"]
        pub static mut octave_base_value_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value6t_nameE"]
        pub static octave_base_value_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value6c_nameE"]
        pub static octave_base_value_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_base_value() {
        assert_eq!(::std::mem::size_of::<octave_base_value>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_base_value )
                   ));
        assert_eq! (::std::mem::align_of::<octave_base_value>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_base_value ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value ) ) . count as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_base_value )
                    , "::" , stringify ! ( count ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN17octave_base_value14numeric_assignERKSsRKSt4listI17octave_value_listSaIS3_EERK12octave_value"]
        pub fn octave_base_value_numeric_assign(this:
                                                    *mut root::octave_base_value,
                                                type_:
                                                    *const root::std::string,
                                                idx: *const root::std::list,
                                                rhs:
                                                    *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value6indentERSo"]
        pub fn octave_base_value_indent(this: *const root::octave_base_value,
                                        os: *mut root::std::ostream);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value7newlineERSo"]
        pub fn octave_base_value_newline(this: *const root::octave_base_value,
                                         os: *mut root::std::ostream);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value5resetEv"]
        pub fn octave_base_value_reset(this: *const root::octave_base_value);
    }
    extern "C" {
        #[link_name =
              "_ZN17octave_base_value13get_umap_nameENS_14unary_mapper_tE"]
        pub fn octave_base_value_get_umap_name(arg1:
                                                   root::octave_base_value_unary_mapper_t)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value9warn_loadEPKc"]
        pub fn octave_base_value_warn_load(this:
                                               *const root::octave_base_value,
                                           type_:
                                               *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value9warn_saveEPKc"]
        pub fn octave_base_value_warn_save(this:
                                               *const root::octave_base_value,
                                           type_:
                                               *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value13register_typeEv"]
        pub fn octave_base_value_register_type();
    }
    impl octave_base_value {
        #[inline]
        pub unsafe fn numeric_assign(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value {
            octave_base_value_numeric_assign(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn indent(&self, os: *mut root::std::ostream) {
            octave_base_value_indent(self, os)
        }
        #[inline]
        pub unsafe fn newline(&self, os: *mut root::std::ostream) {
            octave_base_value_newline(self, os)
        }
        #[inline]
        pub unsafe fn reset(&self) { octave_base_value_reset(self) }
        #[inline]
        pub unsafe fn get_umap_name(arg1:
                                        root::octave_base_value_unary_mapper_t)
         -> *const ::std::os::raw::c_char {
            octave_base_value_get_umap_name(arg1)
        }
        #[inline]
        pub unsafe fn warn_load(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_load(self, type_)
        }
        #[inline]
        pub unsafe fn warn_save(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_save(self, type_)
        }
        #[inline]
        pub unsafe fn register_type() { octave_base_value_register_type() }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_fields {
        pub rep: *mut root::octave_fields_fields_rep,
    }
    #[repr(C)]
    pub struct octave_fields_fields_rep {
        pub _base: root::std::map,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    #[test]
    fn bindgen_test_layout_octave_fields_fields_rep() {
        assert_eq!(::std::mem::size_of::<octave_fields_fields_rep>() , 56usize
                   , concat ! (
                   "Size of: " , stringify ! ( octave_fields_fields_rep ) ));
        assert_eq! (::std::mem::align_of::<octave_fields_fields_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( octave_fields_fields_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_fields_fields_rep ) ) . count
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_fields_fields_rep ) , "::" , stringify ! ( count )
                    ));
    }
    pub type octave_fields_const_iterator = u64;
    pub type octave_fields_iterator = root::octave_fields_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_fields() {
        assert_eq!(::std::mem::size_of::<octave_fields>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( octave_fields ) ));
        assert_eq! (::std::mem::align_of::<octave_fields>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( octave_fields ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_fields ) ) . rep as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_fields ) ,
                    "::" , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields7isfieldERKSs"]
        pub fn octave_fields_isfield(this: *const root::octave_fields,
                                     name: *const root::std::string) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields8getfieldERKSs"]
        pub fn octave_fields_getfield(this: *const root::octave_fields,
                                      name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields8getfieldERKSs"]
        pub fn octave_fields_getfield1(this: *mut root::octave_fields,
                                       name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields7rmfieldERKSs"]
        pub fn octave_fields_rmfield(this: *mut root::octave_fields,
                                     name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields11orderfieldsER5ArrayIiE"]
        pub fn octave_fields_orderfields(this: *mut root::octave_fields,
                                         perm:
                                             *mut root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields17equal_up_to_orderERKS_Pi"]
        pub fn octave_fields_equal_up_to_order(this:
                                                   *const root::octave_fields,
                                               other:
                                                   *const root::octave_fields,
                                               perm:
                                                   *mut root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields17equal_up_to_orderERKS_R5ArrayIiE"]
        pub fn octave_fields_equal_up_to_order1(this:
                                                    *const root::octave_fields,
                                                other:
                                                    *const root::octave_fields,
                                                perm:
                                                    *mut root::Array<::std::os::raw::c_int>)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields10fieldnamesEv"]
        pub fn octave_fields_fieldnames(this: *const root::octave_fields)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fieldsC1ERK13string_vector"]
        pub fn octave_fields_octave_fields(this: *mut root::octave_fields,
                                           arg1: *const root::string_vector);
    }
    extern "C" {
        #[link_name = "_ZN13octave_fieldsC1EPKPKc"]
        pub fn octave_fields_octave_fields1(this: *mut root::octave_fields,
                                            arg1:
                                                *const *const ::std::os::raw::c_char);
    }
    impl octave_fields {
        #[inline]
        pub unsafe fn isfield(&self, name: *const root::std::string) -> bool {
            octave_fields_isfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield(&self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_getfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield1(&mut self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_getfield1(self, name)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_rmfield(self, name)
        }
        #[inline]
        pub unsafe fn orderfields(&mut self,
                                  perm:
                                      *mut root::Array<::std::os::raw::c_int>) {
            octave_fields_orderfields(self, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order(&self,
                                        other: *const root::octave_fields,
                                        perm: *mut root::octave_idx_type)
         -> bool {
            octave_fields_equal_up_to_order(self, other, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order1(&self,
                                         other: *const root::octave_fields,
                                         perm:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> bool {
            octave_fields_equal_up_to_order1(self, other, perm)
        }
        #[inline]
        pub unsafe fn fieldnames(&self) -> root::string_vector {
            octave_fields_fieldnames(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::string_vector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_fields_octave_fields(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const *const ::std::os::raw::c_char)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_fields_octave_fields1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value_typeinfo {
        pub num_types: ::std::os::raw::c_int,
        pub types: root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                       root::std::allocator>>,
        pub vals: root::Array<root::octave_value>,
        pub unary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub unary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub non_const_unary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub binary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub compound_binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub compound_binary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub cat_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub assign_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub assignany_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub pref_assign_conv: root::Array<::std::os::raw::c_int>,
        pub widening_ops: root::Array<*mut ::std::os::raw::c_void>,
    }
    pub type octave_value_typeinfo_unary_class_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_unary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_non_const_unary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value)>;
    pub type octave_value_typeinfo_binary_class_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value,
                                                   arg2:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_binary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_cat_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_base_value,
                                                   ra_idx:
                                                       *const root::Array<::std::os::raw::c_int>)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_assign_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_value_list,
                                                   arg3:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_assignany_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_value_list,
                                                   arg3:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo11init_tab_szE"]
        pub static octave_value_typeinfo_init_tab_sz: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo8instanceE"]
        pub static mut octave_value_typeinfo_instance:
                   *mut root::octave_value_typeinfo;
    }
    #[test]
    fn bindgen_test_layout_octave_value_typeinfo() {
        assert_eq!(::std::mem::size_of::<octave_value_typeinfo>() , 568usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_value_typeinfo ) ));
        assert_eq! (::std::mem::align_of::<octave_value_typeinfo>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_value_typeinfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . num_types
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( num_types )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . types as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( types ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . vals as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( vals ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    unary_class_ops as * const _ as usize } , 88usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    unary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . unary_ops
                    as * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( unary_ops )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    non_const_unary_ops as * const _ as usize } , 168usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    non_const_unary_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    binary_class_ops as * const _ as usize } , 208usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    binary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    binary_ops as * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( binary_ops
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    compound_binary_class_ops as * const _ as usize } ,
                    288usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    compound_binary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    compound_binary_ops as * const _ as usize } , 328usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    compound_binary_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . cat_ops
                    as * const _ as usize } , 368usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( cat_ops )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    assign_ops as * const _ as usize } , 408usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( assign_ops
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    assignany_ops as * const _ as usize } , 448usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    assignany_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    pref_assign_conv as * const _ as usize } , 488usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    pref_assign_conv ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    widening_ops as * const _ as usize } , 528usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    widening_ops ) ));
    }
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo11instance_okEv"]
        pub fn octave_value_typeinfo_instance_ok() -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo13register_typeERKSsS1_RK12octave_value"]
        pub fn octave_value_typeinfo_register_type(arg1:
                                                       *const root::std::string,
                                                   arg2:
                                                       *const root::std::string,
                                                   arg3:
                                                       *const root::octave_value)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo23register_unary_class_opEN12octave_value8unary_opEPFS0_RKS0_E"]
        pub fn octave_value_typeinfo_register_unary_class_op(arg1:
                                                                 root::octave_value_unary_op,
                                                             arg2:
                                                                 root::octave_value_typeinfo_unary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo17register_unary_opEN12octave_value8unary_opEiPFS0_RK17octave_base_valueE"]
        pub fn octave_value_typeinfo_register_unary_op(arg1:
                                                           root::octave_value_unary_op,
                                                       arg2:
                                                           ::std::os::raw::c_int,
                                                       arg3:
                                                           root::octave_value_typeinfo_unary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo27register_non_const_unary_opEN12octave_value8unary_opEiPFvR17octave_base_valueE"]
        pub fn octave_value_typeinfo_register_non_const_unary_op(arg1:
                                                                     root::octave_value_unary_op,
                                                                 arg2:
                                                                     ::std::os::raw::c_int,
                                                                 arg3:
                                                                     root::octave_value_typeinfo_non_const_unary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value9binary_opEPFS0_RKS0_S3_E"]
        pub fn octave_value_typeinfo_register_binary_class_op(arg1:
                                                                  root::octave_value_binary_op,
                                                              arg2:
                                                                  root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_binary_opEN12octave_value9binary_opEiiPFS0_RK17octave_base_valueS4_E"]
        pub fn octave_value_typeinfo_register_binary_op(arg1:
                                                            root::octave_value_binary_op,
                                                        arg2:
                                                            ::std::os::raw::c_int,
                                                        arg3:
                                                            ::std::os::raw::c_int,
                                                        arg4:
                                                            root::octave_value_typeinfo_binary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value18compound_binary_opEPFS0_RKS0_S3_E"]
        pub fn octave_value_typeinfo_register_binary_class_op1(arg1:
                                                                   root::octave_value_compound_binary_op,
                                                               arg2:
                                                                   root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_binary_opEN12octave_value18compound_binary_opEiiPFS0_RK17octave_base_valueS4_E"]
        pub fn octave_value_typeinfo_register_binary_op1(arg1:
                                                             root::octave_value_compound_binary_op,
                                                         arg2:
                                                             ::std::os::raw::c_int,
                                                         arg3:
                                                             ::std::os::raw::c_int,
                                                         arg4:
                                                             root::octave_value_typeinfo_binary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo15register_cat_opEiiPF12octave_valueR17octave_base_valueRKS1_RK5ArrayIiEE"]
        pub fn octave_value_typeinfo_register_cat_op(arg1:
                                                         ::std::os::raw::c_int,
                                                     arg2:
                                                         ::std::os::raw::c_int,
                                                     arg3:
                                                         root::octave_value_typeinfo_cat_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_assign_opEN12octave_value9assign_opEiiPFS0_R17octave_base_valueRK17octave_value_listRKS2_E"]
        pub fn octave_value_typeinfo_register_assign_op(arg1:
                                                            root::octave_value_assign_op,
                                                        arg2:
                                                            ::std::os::raw::c_int,
                                                        arg3:
                                                            ::std::os::raw::c_int,
                                                        arg4:
                                                            root::octave_value_typeinfo_assign_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo21register_assignany_opEN12octave_value9assign_opEiPFS0_R17octave_base_valueRK17octave_value_listRKS0_E"]
        pub fn octave_value_typeinfo_register_assignany_op(arg1:
                                                               root::octave_value_assign_op,
                                                           arg2:
                                                               ::std::os::raw::c_int,
                                                           arg3:
                                                               root::octave_value_typeinfo_assignany_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo25register_pref_assign_convEiii"]
        pub fn octave_value_typeinfo_register_pref_assign_conv(arg1:
                                                                   ::std::os::raw::c_int,
                                                               arg2:
                                                                   ::std::os::raw::c_int,
                                                               arg3:
                                                                   ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo20register_widening_opEiiPFP17octave_base_valueRKS0_E"]
        pub fn octave_value_typeinfo_register_widening_op(arg1:
                                                              ::std::os::raw::c_int,
                                                          arg2:
                                                              ::std::os::raw::c_int,
                                                          arg3:
                                                              root::octave_base_value_type_conv_fcn)
         -> bool;
    }
    impl octave_value_typeinfo {
        #[inline]
        pub unsafe fn instance_ok() -> bool {
            octave_value_typeinfo_instance_ok()
        }
        #[inline]
        pub unsafe fn register_type(arg1: *const root::std::string,
                                    arg2: *const root::std::string,
                                    arg3: *const root::octave_value)
         -> ::std::os::raw::c_int {
            octave_value_typeinfo_register_type(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_unary_class_op(arg1:
                                                  root::octave_value_unary_op,
                                              arg2:
                                                  root::octave_value_typeinfo_unary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_unary_class_op(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_unary_op(arg1: root::octave_value_unary_op,
                                        arg2: ::std::os::raw::c_int,
                                        arg3:
                                            root::octave_value_typeinfo_unary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_unary_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_non_const_unary_op(arg1:
                                                      root::octave_value_unary_op,
                                                  arg2: ::std::os::raw::c_int,
                                                  arg3:
                                                      root::octave_value_typeinfo_non_const_unary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_non_const_unary_op(arg1, arg2,
                                                              arg3)
        }
        #[inline]
        pub unsafe fn register_binary_class_op(arg1:
                                                   root::octave_value_binary_op,
                                               arg2:
                                                   root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_class_op(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_binary_op(arg1: root::octave_value_binary_op,
                                         arg2: ::std::os::raw::c_int,
                                         arg3: ::std::os::raw::c_int,
                                         arg4:
                                             root::octave_value_typeinfo_binary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_op(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_binary_class_op1(arg1:
                                                    root::octave_value_compound_binary_op,
                                                arg2:
                                                    root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_class_op1(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_binary_op1(arg1:
                                              root::octave_value_compound_binary_op,
                                          arg2: ::std::os::raw::c_int,
                                          arg3: ::std::os::raw::c_int,
                                          arg4:
                                              root::octave_value_typeinfo_binary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_op1(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_cat_op(arg1: ::std::os::raw::c_int,
                                      arg2: ::std::os::raw::c_int,
                                      arg3:
                                          root::octave_value_typeinfo_cat_op_fcn)
         -> bool {
            octave_value_typeinfo_register_cat_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_assign_op(arg1: root::octave_value_assign_op,
                                         arg2: ::std::os::raw::c_int,
                                         arg3: ::std::os::raw::c_int,
                                         arg4:
                                             root::octave_value_typeinfo_assign_op_fcn)
         -> bool {
            octave_value_typeinfo_register_assign_op(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_assignany_op(arg1:
                                                root::octave_value_assign_op,
                                            arg2: ::std::os::raw::c_int,
                                            arg3:
                                                root::octave_value_typeinfo_assignany_op_fcn)
         -> bool {
            octave_value_typeinfo_register_assignany_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_pref_assign_conv(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int,
                                                arg3: ::std::os::raw::c_int)
         -> bool {
            octave_value_typeinfo_register_pref_assign_conv(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_widening_op(arg1: ::std::os::raw::c_int,
                                           arg2: ::std::os::raw::c_int,
                                           arg3:
                                               root::octave_base_value_type_conv_fcn)
         -> bool {
            octave_value_typeinfo_register_widening_op(arg1, arg2, arg3)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct jit_type([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_builtin {
        pub _base: root::octave_function,
        pub f: root::octave_builtin_fcn,
        pub file: root::std::string,
        pub jtype: *mut root::jit_type,
    }
    pub type octave_builtin_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value_list,
                                                   arg2:
                                                       ::std::os::raw::c_int)
                                  -> root::octave_value_list>;
    extern "C" {
        #[link_name = "_ZN14octave_builtin16curr_lvalue_listE"]
        pub static mut octave_builtin_curr_lvalue_list:
                   *const root::std::list;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin4t_idE"]
        pub static mut octave_builtin_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin6t_nameE"]
        pub static octave_builtin_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin6c_nameE"]
        pub static octave_builtin_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_builtin() {
        assert_eq!(::std::mem::size_of::<octave_builtin>() , 80usize , concat
                   ! ( "Size of: " , stringify ! ( octave_builtin ) ));
        assert_eq! (::std::mem::align_of::<octave_builtin>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( octave_builtin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . f as * const _
                    as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( f ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . file as * const
                    _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( file ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . jtype as * const
                    _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( jtype ) ));
    }
    extern "C" {
        #[link_name = "_ZNK14octave_builtin6to_jitEv"]
        pub fn octave_builtin_to_jit(this: *const root::octave_builtin)
         -> *mut root::jit_type;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin9stash_jitER8jit_type"]
        pub fn octave_builtin_stash_jit(this: *mut root::octave_builtin,
                                        type_: *mut root::jit_type);
    }
    extern "C" {
        #[link_name = "_ZNK14octave_builtin8functionEv"]
        pub fn octave_builtin_function(this: *const root::octave_builtin)
         -> root::octave_builtin_fcn;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin13register_typeEv"]
        pub fn octave_builtin_register_type();
    }
    impl octave_builtin {
        #[inline]
        pub unsafe fn to_jit(&self) -> *mut root::jit_type {
            octave_builtin_to_jit(self)
        }
        #[inline]
        pub unsafe fn stash_jit(&mut self, type_: *mut root::jit_type) {
            octave_builtin_stash_jit(self, type_)
        }
        #[inline]
        pub unsafe fn function(&self) -> root::octave_builtin_fcn {
            octave_builtin_function(self)
        }
        #[inline]
        pub unsafe fn register_type() { octave_builtin_register_type() }
    }
    pub type octave_shlib = root::octave::dynamic_library;
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_dld_function {
        pub _base: root::octave_builtin,
        pub sh_lib: root::octave::dynamic_library,
        pub t_checked: root::octave::sys::time,
        pub system_fcn_file: bool,
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function4t_idE"]
        pub static mut octave_dld_function_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function6t_nameE"]
        pub static octave_dld_function_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function6c_nameE"]
        pub static octave_dld_function_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_dld_function() {
        assert_eq!(::std::mem::size_of::<octave_dld_function>() , 112usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_dld_function ) ));
        assert_eq! (::std::mem::align_of::<octave_dld_function>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_dld_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) . sh_lib as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( sh_lib ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) . t_checked
                    as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( t_checked ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) .
                    system_fcn_file as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( system_fcn_file ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_dld_function6createEPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKSsSA_"]
        pub fn octave_dld_function_create(ff: root::octave_builtin_fcn,
                                          shl:
                                              *const root::octave::dynamic_library,
                                          nm: *const root::std::string,
                                          ds: *const root::std::string)
         -> *mut root::octave_dld_function;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function13register_typeEv"]
        pub fn octave_dld_function_register_type();
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_dld_functionC1EPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKSsSA_"]
        pub fn octave_dld_function_octave_dld_function(this:
                                                           *mut root::octave_dld_function,
                                                       ff:
                                                           root::octave_builtin_fcn,
                                                       shl:
                                                           *const root::octave::dynamic_library,
                                                       nm:
                                                           *const root::std::string,
                                                       ds:
                                                           *const root::std::string);
    }
    impl octave_dld_function {
        #[inline]
        pub unsafe fn create(ff: root::octave_builtin_fcn,
                             shl: *const root::octave::dynamic_library,
                             nm: *const root::std::string,
                             ds: *const root::std::string)
         -> *mut root::octave_dld_function {
            octave_dld_function_create(ff, shl, nm, ds)
        }
        #[inline]
        pub unsafe fn register_type() { octave_dld_function_register_type() }
        #[inline]
        pub unsafe fn new(ff: root::octave_builtin_fcn,
                          shl: *const root::octave::dynamic_library,
                          nm: *const root::std::string,
                          ds: *const root::std::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_dld_function_octave_dld_function(&mut __bindgen_tmp, ff,
                                                    shl, nm, ds);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_auto_shlib {
        pub _base: root::octave::dynamic_library,
    }
    #[test]
    fn bindgen_test_layout_octave_auto_shlib() {
        assert_eq!(::std::mem::size_of::<octave_auto_shlib>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_auto_shlib )
                   ));
        assert_eq! (::std::mem::align_of::<octave_auto_shlib>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_auto_shlib ) ));
    }
    pub type octave_dld_fcn_installer =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave::dynamic_library,
                                                   relative: bool) -> bool>;
    pub type octave_dld_fcn_getter =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave::dynamic_library,
                                                   relative: bool)
                                  -> *mut root::octave_function>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_pager_buf {
        pub _base: root::std::stringbuf,
        pub diary_skip: usize,
    }
    #[test]
    fn bindgen_test_layout_octave_pager_buf() {
        assert_eq!(::std::mem::size_of::<octave_pager_buf>() , 88usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_pager_buf )
                   ));
        assert_eq! (::std::mem::align_of::<octave_pager_buf>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_pager_buf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_pager_buf ) ) . diary_skip as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_pager_buf )
                    , "::" , stringify ! ( diary_skip ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN16octave_pager_buf31flush_current_contents_to_diaryEv"]
        pub fn octave_pager_buf_flush_current_contents_to_diary(this:
                                                                    *mut root::octave_pager_buf);
    }
    extern "C" {
        #[link_name = "_ZN16octave_pager_buf14set_diary_skipEv"]
        pub fn octave_pager_buf_set_diary_skip(this:
                                                   *mut root::octave_pager_buf);
    }
    impl octave_pager_buf {
        #[inline]
        pub unsafe fn flush_current_contents_to_diary(&mut self) {
            octave_pager_buf_flush_current_contents_to_diary(self)
        }
        #[inline]
        pub unsafe fn set_diary_skip(&mut self) {
            octave_pager_buf_set_diary_skip(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_pager_stream {
        pub _base: root::std::ostream,
        pub pb: *mut root::octave_pager_buf,
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream8instanceE"]
        pub static mut octave_pager_stream_instance:
                   *mut root::octave_pager_stream;
    }
    #[test]
    fn bindgen_test_layout_octave_pager_stream() {
        assert_eq!(::std::mem::size_of::<octave_pager_stream>() , 280usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_pager_stream ) ));
        assert_eq! (::std::mem::align_of::<octave_pager_stream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_pager_stream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_pager_stream ) ) . pb as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_pager_stream
                    ) , "::" , stringify ! ( pb ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_pager_stream31flush_current_contents_to_diaryEv"]
        pub fn octave_pager_stream_flush_current_contents_to_diary();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream14set_diary_skipEv"]
        pub fn octave_pager_stream_set_diary_skip();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream6streamEv"]
        pub fn octave_pager_stream_stream() -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream5resetEv"]
        pub fn octave_pager_stream_reset();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_streamC1Ev"]
        pub fn octave_pager_stream_octave_pager_stream(this:
                                                           *mut root::octave_pager_stream);
    }
    impl octave_pager_stream {
        #[inline]
        pub unsafe fn flush_current_contents_to_diary() {
            octave_pager_stream_flush_current_contents_to_diary()
        }
        #[inline]
        pub unsafe fn set_diary_skip() {
            octave_pager_stream_set_diary_skip()
        }
        #[inline]
        pub unsafe fn stream() -> *mut root::std::ostream {
            octave_pager_stream_stream()
        }
        #[inline]
        pub unsafe fn reset() { octave_pager_stream_reset() }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_pager_stream_octave_pager_stream(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_diary_buf {
        pub _base: root::std::stringbuf,
    }
    #[test]
    fn bindgen_test_layout_octave_diary_buf() {
        assert_eq!(::std::mem::size_of::<octave_diary_buf>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_diary_buf )
                   ));
        assert_eq! (::std::mem::align_of::<octave_diary_buf>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_diary_buf ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_diary_stream {
        pub _base: root::std::ostream,
        pub db: *mut root::octave_diary_buf,
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream8instanceE"]
        pub static mut octave_diary_stream_instance:
                   *mut root::octave_diary_stream;
    }
    #[test]
    fn bindgen_test_layout_octave_diary_stream() {
        assert_eq!(::std::mem::size_of::<octave_diary_stream>() , 280usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_diary_stream ) ));
        assert_eq! (::std::mem::align_of::<octave_diary_stream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_diary_stream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_diary_stream ) ) . db as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_diary_stream
                    ) , "::" , stringify ! ( db ) ));
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream6streamEv"]
        pub fn octave_diary_stream_stream() -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream5resetEv"]
        pub fn octave_diary_stream_reset();
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_streamC1Ev"]
        pub fn octave_diary_stream_octave_diary_stream(this:
                                                           *mut root::octave_diary_stream);
    }
    impl octave_diary_stream {
        #[inline]
        pub unsafe fn stream() -> *mut root::std::ostream {
            octave_diary_stream_stream()
        }
        #[inline]
        pub unsafe fn reset() { octave_diary_stream_reset() }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_diary_stream_octave_diary_stream(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_integral_constant_instantiation_85743() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_iterator_instantiation_85906() {
        assert_eq!(::std::mem::size_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::iterator ) ));
        assert_eq!(::std::mem::align_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::iterator ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91051() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_schar>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_schar> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_schar>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_schar> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91055() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_short>>()
                   , 2usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_short> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_short>>()
                   , 2usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_short> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91059() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_int>>()
                   , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_int>>()
                   , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91063() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_longlong>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_longlong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_longlong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_longlong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91067() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_uchar>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uchar> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_uchar>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uchar> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91071() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_ushort>>()
                   , 2usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ushort> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_ushort>>()
                   , 2usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ushort> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91075() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_uint>>()
                   , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_uint>>()
                   , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91079() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ulonglong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ulonglong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91134() {
        assert_eq!(::std::mem::size_of::<root::Array<::std::os::raw::c_int>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91149() {
        assert_eq!(::std::mem::size_of::<root::Array<f64>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91217() {
        assert_eq!(::std::mem::size_of::<root::Array<bool>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<bool>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_91222() {
        assert_eq!(::std::mem::size_of::<root::Sparse<bool>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<bool>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91289() {
        assert_eq!(::std::mem::size_of::<root::Array<f32>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_92560() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<f64>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_92565() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<f64>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_93129() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<root::std::complex<f64>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_93133() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<root::std::complex<f64>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_93724() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<f32>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_93729() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<f32>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_94287() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<root::std::complex<f32>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_94291() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<root::std::complex<f32>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MSparse_instantiation_94858() {
        assert_eq!(::std::mem::size_of::<root::MSparse<f64>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MSparse<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MSparse<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MSparse<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_94879() {
        assert_eq!(::std::mem::size_of::<root::Sparse<f64>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MSparse_instantiation_95559() {
        assert_eq!(::std::mem::size_of::<root::MSparse<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MSparse<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MSparse<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MSparse<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_95579() {
        assert_eq!(::std::mem::size_of::<root::Sparse<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_95587() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::complex<f64>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_96321() {
        assert_eq!(::std::mem::size_of::<root::Array<::std::os::raw::c_char>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96345() {
        assert_eq!(::std::mem::size_of::<root::MArray<f64>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96446() {
        assert_eq!(::std::mem::size_of::<root::MArray<root::std::complex<f64>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96536() {
        assert_eq!(::std::mem::size_of::<root::MArray<f32>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96626() {
        assert_eq!(::std::mem::size_of::<root::MArray<root::std::complex<f32>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_96921() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::complex<f32>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_97745() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                          root::std::allocator>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                           root::std::allocator>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_97787() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_list_instantiation_97785() {
        assert_eq!(::std::mem::size_of::<root::std::list>() , 16usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::list ) ));
        assert_eq!(::std::mem::align_of::<root::std::list>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::list ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100267() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_schar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_schar>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_schar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_schar>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100498() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_short>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_short>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_short>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_short>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100729() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_int>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_int>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_int>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_int>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100960() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101191() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101422() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101653() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uint>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uint>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uint>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uint>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101884() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_115325() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_value>>() ,
                   40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_value> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_value>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115550() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115619() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115676() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_list_instantiation_115674() {
        assert_eq!(::std::mem::size_of::<root::std::list>() , 16usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::list ) ));
        assert_eq!(::std::mem::align_of::<root::std::list>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::list ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116195() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_schar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_schar>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_schar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_schar>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116201() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_short>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_short>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_short>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_short>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116207() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_int>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_int>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_int>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_int>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116213() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_longlong>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_longlong>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116219() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uchar>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uchar>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116225() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ushort>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ushort>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116231() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_uint>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uint>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_uint>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uint>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116237() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_less_instantiation_117444() {
        assert_eq!(::std::mem::size_of::<root::std::less>() , 1usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::less ) ));
        assert_eq!(::std::mem::align_of::<root::std::less>() , 1usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::less ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_117448() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      ::std::os::raw::c_int>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_int>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       ::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_int>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_117447() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_map_instantiation_117440() {
        assert_eq!(::std::mem::size_of::<root::std::map>() , 48usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::map ) ));
        assert_eq!(::std::mem::align_of::<root::std::map>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::map ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_118535() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      ::std::os::raw::c_ulonglong>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_ulonglong>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       ::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_ulonglong>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_118547() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_118555() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      *mut root::octave::dynamic_library_dynlib_rep>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                *mut root::octave::dynamic_library_dynlib_rep>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       *mut root::octave::dynamic_library_dynlib_rep>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                *mut root::octave::dynamic_library_dynlib_rep>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_118554() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
}
