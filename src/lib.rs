/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *mut _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *mut _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment =
            root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_string<_CharT, _Alloc> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider<_CharT,
                                                                  _Alloc>,
        }
        pub type basic_string__CharT_alloc_type = [u8; 0usize];
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type<_Alloc> = _Alloc;
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_reference = [u8; 0usize];
        pub type basic_string_const_reference = [u8; 0usize];
        pub type basic_string_pointer = [u8; 0usize];
        pub type basic_string_const_pointer = [u8; 0usize];
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        #[repr(C)]
        pub struct basic_string__Rep_base {
            pub _M_length: root::std::basic_string_size_type,
            pub _M_capacity: root::std::basic_string_size_type,
            pub _M_refcount: root::std::_Atomic_word,
        }
        #[repr(C)]
        pub struct basic_string__Rep {
            pub _base: root::std::basic_string__Rep_base,
        }
        pub type basic_string__Rep__Raw_bytes_alloc = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider<_CharT, _Alloc> {
            pub _base: _Alloc,
            pub _M_p: *mut _CharT,
        }
        #[test]
        fn __bindgen_test_layout_char_traits_instantiation_15707() {
            assert_eq!(::std::mem::size_of::<root::std::char_traits>() ,
                       1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::char_traits ) ));
            assert_eq!(::std::mem::align_of::<root::std::char_traits>() ,
                       1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::char_traits ) ));
        }
        pub type string =
            root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>;
        pub type true_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(::std::mem::size_of::<input_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( input_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<input_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( input_iterator_tag )
                        ));
        }
        impl Clone for input_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(::std::mem::size_of::<output_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( output_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<output_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( output_iterator_tag )
                        ));
        }
        impl Clone for output_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(::std::mem::size_of::<forward_iterator_tag>() , 1usize
                       , concat ! (
                       "Size of: " , stringify ! ( forward_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<forward_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! ( forward_iterator_tag )
                        ));
        }
        impl Clone for forward_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(::std::mem::size_of::<bidirectional_iterator_tag>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( bidirectional_iterator_tag
                       ) ));
            assert_eq! (::std::mem::align_of::<bidirectional_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! (
                        bidirectional_iterator_tag ) ));
        }
        impl Clone for bidirectional_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference =
            root::std::reverse_iterator___traits_type;
        #[repr(C)]
        pub struct istreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::istreambuf_iterator_streambuf_type<_CharT>,
            pub _M_c: root::std::istreambuf_iterator_int_type,
        }
        pub type istreambuf_iterator_char_type<_CharT> = _CharT;
        pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type istreambuf_iterator_int_type = [u8; 0usize];
        pub type istreambuf_iterator_streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type istreambuf_iterator_istream_type<_CharT> =
            root::std::basic_istream<_CharT>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ostreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::ostreambuf_iterator_streambuf_type<_CharT>,
            pub _M_failed: bool,
        }
        pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
        pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type ostreambuf_iterator_streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type ostreambuf_iterator_ostream_type<_CharT> =
            root::std::basic_ostream<_CharT>;
        pub type streamoff = ::std::os::raw::c_longlong;
        pub type streamsize = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
        }
        pub type streampos = root::std::fpos<::std::os::raw::c_int>;
        #[repr(C)]
        pub struct exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct exception {
            pub vtable_: *const exception__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(::std::mem::size_of::<exception>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( exception ) ));
            assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( exception ) ));
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[test]
        fn __bindgen_test_layout_allocator_instantiation_20294() {
            assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize
                       , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::allocator ) ));
            assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize
                       , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::allocator ) ));
        }
        pub type __c_locale = *mut ::std::os::raw::c_int;
        pub type _Atomic_word = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base {
            pub vtable_: *const ios_base__bindgen_vtable,
            pub _M_precision: root::std::streamsize,
            pub _M_width: root::std::streamsize,
            pub _M_flags: root::std::ios_base_fmtflags,
            pub _M_exception: root::std::ios_base_iostate,
            pub _M_streambuf_state: root::std::ios_base_iostate,
            pub _M_callbacks: *mut root::std::ios_base__Callback_list,
            pub _M_word_zero: root::std::ios_base__Words,
            pub _M_local_word: [root::std::ios_base__Words; 8usize],
            pub _M_word_size: ::std::os::raw::c_int,
            pub _M_word: *mut root::std::ios_base__Words,
            pub _M_ios_locale: root::std::locale,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base_failure {
            pub _base: root::std::exception,
            pub _M_msg: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_ios_base_failure() {
            assert_eq!(::std::mem::size_of::<ios_base_failure>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ios_base_failure ) ));
            assert_eq! (::std::mem::align_of::<ios_base_failure>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base_failure ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base_failure ) ) . _M_msg as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base_failure ) , "::" , stringify ! ( _M_msg ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7failureC1ERKSs"]
            pub fn ios_base_failure_failure(this:
                                                *mut root::std::ios_base_failure,
                                            __str: *const root::std::string);
        }
        impl ios_base_failure {
            #[inline]
            pub unsafe fn new(__str: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure(&mut __bindgen_tmp, __str);
                __bindgen_tmp
            }
        }
        pub use self::super::super::root::std::_Ios_Fmtflags as
                ios_base_fmtflags;
        pub use self::super::super::root::std::_Ios_Iostate as
                ios_base_iostate;
        pub use self::super::super::root::std::_Ios_Openmode as
                ios_base_openmode;
        pub use self::super::super::root::std::_Ios_Seekdir as
                ios_base_seekdir;
        pub type ios_base_io_state = ::std::os::raw::c_int;
        pub type ios_base_open_mode = ::std::os::raw::c_int;
        pub type ios_base_seek_dir = ::std::os::raw::c_int;
        pub type ios_base_streampos = root::std::streampos;
        pub type ios_base_streamoff = root::std::streamoff;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ios_base_event {
            erase_event = 0,
            imbue_event = 1,
            copyfmt_event = 2,
        }
        pub type ios_base_event_callback =
            ::std::option::Option<unsafe extern "C" fn(__e:
                                                           root::std::ios_base_event,
                                                       __b:
                                                           *mut root::std::ios_base,
                                                       __i:
                                                           ::std::os::raw::c_int)>;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ios_base__Callback_list {
            pub _M_next: *mut root::std::ios_base__Callback_list,
            pub _M_fn: root::std::ios_base_event_callback,
            pub _M_index: ::std::os::raw::c_int,
            pub _M_refcount: root::std::_Atomic_word,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Callback_list() {
            assert_eq!(::std::mem::size_of::<ios_base__Callback_list>() ,
                       24usize , concat ! (
                       "Size of: " , stringify ! ( ios_base__Callback_list )
                       ));
            assert_eq! (::std::mem::align_of::<ios_base__Callback_list>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ios_base__Callback_list ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_next as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_next ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_fn as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! ( _M_fn
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_index as * const _ as usize } , 16usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_index ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Callback_list ) ) .
                        _M_refcount as * const _ as usize } , 20usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        ios_base__Callback_list ) , "::" , stringify ! (
                        _M_refcount ) ));
        }
        impl Clone for ios_base__Callback_list {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ios_base__Words {
            pub _M_pword: *mut ::std::os::raw::c_void,
            pub _M_iword: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Words() {
            assert_eq!(::std::mem::size_of::<ios_base__Words>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ios_base__Words ) ));
            assert_eq! (::std::mem::align_of::<ios_base__Words>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base__Words ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Words ) ) . _M_pword as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base__Words
                        ) , "::" , stringify ! ( _M_pword ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base__Words ) ) . _M_iword as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base__Words
                        ) , "::" , stringify ! ( _M_iword ) ));
        }
        impl Clone for ios_base__Words {
            fn clone(&self) -> Self { *self }
        }
        pub const ios_base__S_local_word_size:
                  root::std::ios_base__bindgen_ty_1 =
            ios_base__bindgen_ty_1::_S_local_word_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ios_base__bindgen_ty_1 { _S_local_word_size = 8, }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base_Init {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4Init11_S_refcountE"]
            pub static mut ios_base_Init__S_refcount: root::std::_Atomic_word;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
            pub static mut ios_base_Init__S_synced_with_stdio: bool;
        }
        #[test]
        fn bindgen_test_layout_ios_base_Init() {
            assert_eq!(::std::mem::size_of::<ios_base_Init>() , 1usize ,
                       concat ! ( "Size of: " , stringify ! ( ios_base_Init )
                       ));
            assert_eq! (::std::mem::align_of::<ios_base_Init>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ios_base_Init ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4InitC1Ev"]
            pub fn ios_base_Init_Init(this: *mut root::std::ios_base_Init);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4InitD1Ev"]
            pub fn ios_base_Init_Init_destructor(this:
                                                     *mut root::std::ios_base_Init);
        }
        impl ios_base_Init {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_Init_Init(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ios_base_Init_Init_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9boolalphaE"]
            pub static ios_base_boolalpha: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3decE"]
            pub static ios_base_dec: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5fixedE"]
            pub static ios_base_fixed: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3hexE"]
            pub static ios_base_hex: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base8internalE"]
            pub static ios_base_internal: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base4leftE"]
            pub static ios_base_left: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3octE"]
            pub static ios_base_oct: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5rightE"]
            pub static ios_base_right: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base10scientificE"]
            pub static ios_base_scientific: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base8showbaseE"]
            pub static ios_base_showbase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9showpointE"]
            pub static ios_base_showpoint: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7showposE"]
            pub static ios_base_showpos: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6skipwsE"]
            pub static ios_base_skipws: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7unitbufE"]
            pub static ios_base_unitbuf: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9uppercaseE"]
            pub static ios_base_uppercase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base11adjustfieldE"]
            pub static ios_base_adjustfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base9basefieldE"]
            pub static ios_base_basefield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base10floatfieldE"]
            pub static ios_base_floatfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6badbitE"]
            pub static ios_base_badbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6eofbitE"]
            pub static ios_base_eofbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7failbitE"]
            pub static ios_base_failbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7goodbitE"]
            pub static ios_base_goodbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3appE"]
            pub static ios_base_app: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3ateE"]
            pub static ios_base_ate: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6binaryE"]
            pub static ios_base_binary: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base2inE"]
            pub static ios_base_in: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3outE"]
            pub static ios_base_out: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5truncE"]
            pub static ios_base_trunc: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3begE"]
            pub static ios_base_beg: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3curE"]
            pub static ios_base_cur: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base3endE"]
            pub static ios_base_end: root::std::ios_base_seekdir;
        }
        #[test]
        fn bindgen_test_layout_ios_base() {
            assert_eq!(::std::mem::size_of::<ios_base>() , 216usize , concat !
                       ( "Size of: " , stringify ! ( ios_base ) ));
            assert_eq! (::std::mem::align_of::<ios_base>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( ios_base ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_precision as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_precision ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_width as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_width ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_flags as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_flags ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_exception as *
                        const _ as usize } , 28usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_exception ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_streambuf_state
                        as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_streambuf_state ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_callbacks as *
                        const _ as usize } , 40usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_callbacks ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word_zero as *
                        const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word_zero ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_local_word as *
                        const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_local_word ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word_size as *
                        const _ as usize } , 192usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word_size ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_word as * const
                        _ as usize } , 200usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_word ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ios_base ) ) . _M_ios_locale as *
                        const _ as usize } , 208usize , concat ! (
                        "Alignment of field: " , stringify ! ( ios_base ) ,
                        "::" , stringify ! ( _M_ios_locale ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
            pub fn ios_base_register_callback(this: *mut root::std::ios_base,
                                              __fn:
                                                  root::std::ios_base_event_callback,
                                              __index: ::std::os::raw::c_int);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
            pub fn ios_base__M_call_callbacks(this: *mut root::std::ios_base,
                                              __ev:
                                                  root::std::ios_base_event);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base20_M_dispose_callbacksEv"]
            pub fn ios_base__M_dispose_callbacks(this:
                                                     *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base13_M_grow_wordsEib"]
            pub fn ios_base__M_grow_words(this: *mut root::std::ios_base,
                                          __index: ::std::os::raw::c_int,
                                          __iword: bool)
             -> *mut root::std::ios_base__Words;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base7_M_initEv"]
            pub fn ios_base__M_init(this: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base15sync_with_stdioEb"]
            pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base5imbueERKSt6locale"]
            pub fn ios_base_imbue(this: *mut root::std::ios_base,
                                  __loc: *const root::std::locale)
             -> root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_base6xallocEv"]
            pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "_ZNSt8ios_baseC1Ev"]
            pub fn ios_base_ios_base(this: *mut root::std::ios_base);
        }
        impl ios_base {
            #[inline]
            pub unsafe fn register_callback(&mut self,
                                            __fn:
                                                root::std::ios_base_event_callback,
                                            __index: ::std::os::raw::c_int) {
                ios_base_register_callback(self, __fn, __index)
            }
            #[inline]
            pub unsafe fn _M_call_callbacks(&mut self,
                                            __ev: root::std::ios_base_event) {
                ios_base__M_call_callbacks(self, __ev)
            }
            #[inline]
            pub unsafe fn _M_dispose_callbacks(&mut self) {
                ios_base__M_dispose_callbacks(self)
            }
            #[inline]
            pub unsafe fn _M_grow_words(&mut self,
                                        __index: ::std::os::raw::c_int,
                                        __iword: bool)
             -> *mut root::std::ios_base__Words {
                ios_base__M_grow_words(self, __index, __iword)
            }
            #[inline]
            pub unsafe fn _M_init(&mut self) { ios_base__M_init(self) }
            #[inline]
            pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
                ios_base_sync_with_stdio(__sync)
            }
            #[inline]
            pub unsafe fn imbue(&mut self, __loc: *const root::std::locale)
             -> root::std::locale {
                ios_base_imbue(self, __loc)
            }
            #[inline]
            pub unsafe fn xalloc() -> ::std::os::raw::c_int {
                ios_base_xalloc()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ios<_CharT> {
            pub _base: root::std::ios_base,
            pub _M_tie: *mut root::std::basic_ostream<_CharT>,
            pub _M_fill: root::std::basic_ios_char_type<_CharT>,
            pub _M_fill_init: bool,
            pub _M_streambuf: *mut root::std::basic_streambuf<_CharT>,
            pub _M_ctype: *const root::std::basic_ios___ctype_type,
            pub _M_num_put: *const root::std::basic_ios___num_put_type,
            pub _M_num_get: *const root::std::basic_ios___num_get_type,
        }
        pub type basic_ios_char_type<_CharT> = _CharT;
        pub type basic_ios_int_type = [u8; 0usize];
        pub type basic_ios_pos_type = [u8; 0usize];
        pub type basic_ios_off_type = [u8; 0usize];
        pub type basic_ios_traits_type<_Traits> = _Traits;
        pub type basic_ios___ctype_type = root::std::ctype;
        pub type basic_ios___num_put_type = root::std::num_put;
        pub type basic_ios___num_get_type = root::std::num_get;
        #[repr(C)]
        pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_streambuf<_CharT> {
            pub vtable_: *const basic_streambuf__bindgen_vtable,
            pub _M_in_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_buf_locale: root::std::locale,
        }
        pub type basic_streambuf_char_type<_CharT> = _CharT;
        pub type basic_streambuf_traits_type<_Traits> = _Traits;
        pub type basic_streambuf_int_type = [u8; 0usize];
        pub type basic_streambuf_pos_type = [u8; 0usize];
        pub type basic_streambuf_off_type = [u8; 0usize];
        pub type basic_streambuf___streambuf_type =
            root::std::basic_streambuf<root::std::basic_streambuf_char_type<_CharT>>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_istream<_CharT> {
            pub _M_gcount: root::std::streamsize,
        }
        pub type basic_istream_char_type<_CharT> = _CharT;
        pub type basic_istream_int_type = [u8; 0usize];
        pub type basic_istream_pos_type = [u8; 0usize];
        pub type basic_istream_off_type = [u8; 0usize];
        pub type basic_istream_traits_type<_Traits> = _Traits;
        pub type basic_istream___streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type basic_istream___ios_type<_CharT> =
            root::std::basic_ios<_CharT>;
        pub type basic_istream___istream_type<_CharT> =
            root::std::basic_istream<_CharT>;
        pub type basic_istream___num_get_type = root::std::num_get;
        pub type basic_istream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_istream_sentry {
            pub _M_ok: bool,
        }
        pub type basic_istream_sentry_traits_type = _Traits;
        pub type basic_istream_sentry___streambuf_type =
            root::std::basic_streambuf<_CharT>;
        pub type basic_istream_sentry___istream_type =
            root::std::basic_istream<_CharT>;
        pub type basic_istream_sentry___ctype_type =
            root::std::basic_istream___ctype_type;
        pub type basic_istream_sentry___int_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ostream<_CharT> {
        }
        pub type basic_ostream_char_type<_CharT> = _CharT;
        pub type basic_ostream_int_type = [u8; 0usize];
        pub type basic_ostream_pos_type = [u8; 0usize];
        pub type basic_ostream_off_type = [u8; 0usize];
        pub type basic_ostream_traits_type<_Traits> = _Traits;
        pub type basic_ostream___streambuf_type<_CharT> =
            root::std::basic_streambuf<_CharT>;
        pub type basic_ostream___ios_type<_CharT> =
            root::std::basic_ios<_CharT>;
        pub type basic_ostream___ostream_type<_CharT> =
            root::std::basic_ostream<_CharT>;
        pub type basic_ostream___num_put_type = root::std::num_put;
        pub type basic_ostream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ostream_sentry {
            pub _M_ok: bool,
            pub _M_os: *mut root::std::basic_ostream<_CharT>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_stringbuf<_CharT, _Alloc> {
            pub _base: root::std::basic_streambuf<_CharT>,
            pub _M_mode: root::std::ios_base_openmode,
            pub _M_string: root::std::basic_stringbuf___string_type<_Alloc>,
        }
        pub type basic_stringbuf_char_type<_CharT> = _CharT;
        pub type basic_stringbuf_traits_type<_Traits> = _Traits;
        pub type basic_stringbuf_allocator_type<_Alloc> = _Alloc;
        pub type basic_stringbuf_int_type = [u8; 0usize];
        pub type basic_stringbuf_pos_type = [u8; 0usize];
        pub type basic_stringbuf_off_type = [u8; 0usize];
        pub type basic_stringbuf___streambuf_type =
            root::std::basic_streambuf<root::std::basic_stringbuf_char_type<_CharT>>;
        pub type basic_stringbuf___string_type<_Alloc> =
            root::std::basic_string<root::std::basic_stringbuf_char_type<_CharT>,
                                    _Alloc>;
        pub type basic_stringbuf___size_type<_Alloc> =
            root::std::basic_stringbuf___string_type<_Alloc>;
        pub type istream = root::std::basic_istream<::std::os::raw::c_char>;
        pub type ostream = root::std::basic_ostream<::std::os::raw::c_char>;
        pub type stringbuf =
            root::std::basic_stringbuf<::std::os::raw::c_char,
                                       root::std::allocator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale {
            pub _M_impl: *mut root::std::locale__Impl,
        }
        pub type locale_category = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale_facet {
            pub vtable_: *const locale_facet__bindgen_vtable,
            pub _M_refcount: root::std::_Atomic_word,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet11_S_c_localeE"]
            pub static mut locale_facet__S_c_locale: root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet9_S_c_nameE"]
            pub static mut locale_facet__S_c_name:
                       [::std::os::raw::c_char; 2usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet7_S_onceE"]
            pub static mut locale_facet__S_once: root::std::__gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale_facet() {
            assert_eq!(::std::mem::size_of::<locale_facet>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( locale_facet )
                       ));
            assert_eq! (::std::mem::align_of::<locale_facet>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( locale_facet ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale_facet ) ) . _M_refcount as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale_facet )
                        , "::" , stringify ! ( _M_refcount ) ));
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet18_S_create_c_localeERPiPKcS1_"]
            pub fn locale_facet__S_create_c_locale(__cloc:
                                                       *mut root::std::__c_locale,
                                                   __s:
                                                       *const ::std::os::raw::c_char,
                                                   __old:
                                                       root::std::__c_locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet17_S_clone_c_localeERPi"]
            pub fn locale_facet__S_clone_c_locale(__cloc:
                                                      *mut root::std::__c_locale)
             -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet19_S_destroy_c_localeERPi"]
            pub fn locale_facet__S_destroy_c_locale(__cloc:
                                                        *mut root::std::__c_locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet20_S_lc_ctype_c_localeEPiPKc"]
            pub fn locale_facet__S_lc_ctype_c_locale(__cloc:
                                                         root::std::__c_locale,
                                                     __s:
                                                         *const ::std::os::raw::c_char)
             -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet15_S_get_c_localeEv"]
            pub fn locale_facet__S_get_c_locale() -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5facet13_S_get_c_nameEv"]
            pub fn locale_facet__S_get_c_name()
             -> *const ::std::os::raw::c_char;
        }
        impl locale_facet {
            #[inline]
            pub unsafe fn _S_create_c_locale(__cloc:
                                                 *mut root::std::__c_locale,
                                             __s:
                                                 *const ::std::os::raw::c_char,
                                             __old: root::std::__c_locale) {
                locale_facet__S_create_c_locale(__cloc, __s, __old)
            }
            #[inline]
            pub unsafe fn _S_clone_c_locale(__cloc:
                                                *mut root::std::__c_locale)
             -> root::std::__c_locale {
                locale_facet__S_clone_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_destroy_c_locale(__cloc:
                                                  *mut root::std::__c_locale) {
                locale_facet__S_destroy_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_lc_ctype_c_locale(__cloc: root::std::__c_locale,
                                               __s:
                                                   *const ::std::os::raw::c_char)
             -> root::std::__c_locale {
                locale_facet__S_lc_ctype_c_locale(__cloc, __s)
            }
            #[inline]
            pub unsafe fn _S_get_c_locale() -> root::std::__c_locale {
                locale_facet__S_get_c_locale()
            }
            #[inline]
            pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
                locale_facet__S_get_c_name()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct locale_id {
            pub _M_index: usize,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale2id11_S_refcountE"]
            pub static mut locale_id__S_refcount: root::std::_Atomic_word;
        }
        #[test]
        fn bindgen_test_layout_locale_id() {
            assert_eq!(::std::mem::size_of::<locale_id>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( locale_id ) ));
            assert_eq! (::std::mem::align_of::<locale_id>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( locale_id ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale_id ) ) . _M_index as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale_id ) ,
                        "::" , stringify ! ( _M_index ) ));
        }
        extern "C" {
            #[link_name = "_ZNKSt6locale2id5_M_idEv"]
            pub fn locale_id__M_id(this: *const root::std::locale_id)
             -> usize;
        }
        impl Clone for locale_id {
            fn clone(&self) -> Self { *self }
        }
        impl locale_id {
            #[inline]
            pub unsafe fn _M_id(&self) -> usize { locale_id__M_id(self) }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale__Impl {
            pub _M_refcount: root::std::_Atomic_word,
            pub _M_facets: *mut *const root::std::locale_facet,
            pub _M_facets_size: usize,
            pub _M_caches: *mut *const root::std::locale_facet,
            pub _M_names: *mut *mut ::std::os::raw::c_char,
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl11_S_id_ctypeE"]
            pub static mut locale__Impl__S_id_ctype:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl13_S_id_numericE"]
            pub static mut locale__Impl__S_id_numeric:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl13_S_id_collateE"]
            pub static mut locale__Impl__S_id_collate:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl10_S_id_timeE"]
            pub static mut locale__Impl__S_id_time:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl14_S_id_monetaryE"]
            pub static mut locale__Impl__S_id_monetary:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl14_S_id_messagesE"]
            pub static mut locale__Impl__S_id_messages:
                       [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "_ZNSt6locale5_Impl19_S_facet_categoriesE"]
            pub static mut locale__Impl__S_facet_categories:
                       [*const *const root::std::locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale__Impl() {
            assert_eq!(::std::mem::size_of::<locale__Impl>() , 40usize ,
                       concat ! ( "Size of: " , stringify ! ( locale__Impl )
                       ));
            assert_eq! (::std::mem::align_of::<locale__Impl>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( locale__Impl ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_refcount as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_refcount ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_facets as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_facets ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_facets_size
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_facets_size ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_caches as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_caches ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale__Impl ) ) . _M_names as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale__Impl )
                        , "::" , stringify ! ( _M_names ) ));
        }
        pub const locale__S_categories_size: root::std::locale__bindgen_ty_1 =
            locale__bindgen_ty_1::_S_categories_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum locale__bindgen_ty_1 { _S_categories_size = 6, }
        pub const locale_none: root::std::locale_category = 0;
        pub const locale_ctype: root::std::locale_category = 1;
        pub const locale_numeric: root::std::locale_category = 2;
        pub const locale_collate: root::std::locale_category = 4;
        pub const locale_time: root::std::locale_category = 8;
        pub const locale_monetary: root::std::locale_category = 16;
        pub const locale_messages: root::std::locale_category = 32;
        pub const locale_all: root::std::locale_category = 63;
        extern "C" {
            #[link_name = "_ZNSt6locale10_S_classicE"]
            pub static mut locale__S_classic: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale9_S_globalE"]
            pub static mut locale__S_global: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale13_S_categoriesE"]
            pub static locale__S_categories:
                       *const *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale7_S_onceE"]
            pub static mut locale__S_once: root::std::__gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale() {
            assert_eq!(::std::mem::size_of::<locale>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( locale ) ));
            assert_eq! (::std::mem::align_of::<locale>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( locale ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const locale ) ) . _M_impl as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( locale ) , "::"
                        , stringify ! ( _M_impl ) ));
        }
        extern "C" {
            #[link_name = "_ZNKSt6locale4nameEv"]
            pub fn locale_name(this: *const root::std::locale)
             -> root::std::string;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale6globalERKS_"]
            pub fn locale_global(__loc: *const root::std::locale)
             -> root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6locale7classicEv"]
            pub fn locale_classic() -> *const root::std::locale;
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1Ev"]
            pub fn locale_locale(this: *mut root::std::locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_"]
            pub fn locale_locale1(this: *mut root::std::locale,
                                  __other: *const root::std::locale);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1EPKc"]
            pub fn locale_locale2(this: *mut root::std::locale,
                                  __s: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_PKci"]
            pub fn locale_locale3(this: *mut root::std::locale,
                                  __base: *const root::std::locale,
                                  __s: *const ::std::os::raw::c_char,
                                  __cat: root::std::locale_category);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeC1ERKS_S1_i"]
            pub fn locale_locale4(this: *mut root::std::locale,
                                  __base: *const root::std::locale,
                                  __add: *const root::std::locale,
                                  __cat: root::std::locale_category);
        }
        extern "C" {
            #[link_name = "_ZNSt6localeD1Ev"]
            pub fn locale_locale_destructor(this: *mut root::std::locale);
        }
        impl locale {
            #[inline]
            pub unsafe fn name(&self) -> root::std::string {
                locale_name(self)
            }
            #[inline]
            pub unsafe fn global(__loc: *const root::std::locale)
             -> root::std::locale {
                locale_global(__loc)
            }
            #[inline]
            pub unsafe fn classic() -> *const root::std::locale {
                locale_classic()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__other: *const root::std::locale) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale1(&mut __bindgen_tmp, __other);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale2(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(__base: *const root::std::locale,
                               __s: *const ::std::os::raw::c_char,
                               __cat: root::std::locale_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__base: *const root::std::locale,
                               __add: *const root::std::locale,
                               __cat: root::std::locale_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale4(&mut __bindgen_tmp, __base, __add, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                locale_locale_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ctype_base {
            pub _address: u8,
        }
        pub type ctype_base___to_type = *const ::std::os::raw::c_int;
        pub type ctype_base_mask = ::std::os::raw::c_ushort;
        pub const ctype_base_upper: root::std::ctype_base_mask = 1;
        pub const ctype_base_lower: root::std::ctype_base_mask = 2;
        pub const ctype_base_alpha: root::std::ctype_base_mask = 4;
        pub const ctype_base_digit: root::std::ctype_base_mask = 8;
        pub const ctype_base_xdigit: root::std::ctype_base_mask = 16;
        pub const ctype_base_space: root::std::ctype_base_mask = 32;
        pub const ctype_base_print: root::std::ctype_base_mask = 64;
        pub const ctype_base_graph: root::std::ctype_base_mask = 524;
        pub const ctype_base_cntrl: root::std::ctype_base_mask = 256;
        pub const ctype_base_punct: root::std::ctype_base_mask = 512;
        pub const ctype_base_alnum: root::std::ctype_base_mask = 12;
        #[test]
        fn bindgen_test_layout_ctype_base() {
            assert_eq!(::std::mem::size_of::<ctype_base>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( ctype_base ) ));
            assert_eq! (::std::mem::align_of::<ctype_base>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( ctype_base ) ));
        }
        impl Clone for ctype_base {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ctype {
            pub _base: root::std::__ctype_abstract_base,
        }
        pub type ctype_char_type<_CharT> = _CharT;
        pub type ctype_mask = root::std::__ctype_abstract_base;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_get {
            pub _base: root::std::locale_facet,
        }
        pub type num_get_char_type<_CharT> = _CharT;
        pub type num_get_iter_type<_InIter> = _InIter;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_put {
            pub _base: root::std::locale_facet,
        }
        pub type num_put_char_type<_CharT> = _CharT;
        pub type num_put_iter_type<_OutIter> = _OutIter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Select1st {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_basic_string_instantiation_24961() {
            assert_eq!(::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char,
                                              root::std::allocator>>()
                       , 8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_string<::std::os::raw::c_char, root::std::allocator>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char,
                                               root::std::allocator>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::std::basic_string<::std::os::raw::c_char, root::std::allocator>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits___pointer<_Alloc> = _Alloc;
        pub type allocator_traits_pointer<_Alloc> =
            root::std::allocator_traits___pointer<_Alloc>;
        pub type allocator_traits___const_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_pointer<_Alloc> =
            root::std::allocator_traits___const_pointer<_Alloc>;
        pub type allocator_traits___void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_void_pointer<_Alloc> =
            root::std::allocator_traits___void_pointer<_Alloc>;
        pub type allocator_traits___const_void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_void_pointer<_Alloc> =
            root::std::allocator_traits___const_void_pointer<_Alloc>;
        pub type allocator_traits___difference_type<_Alloc> = _Alloc;
        pub type allocator_traits_difference_type<_Alloc> =
            root::std::allocator_traits___difference_type<_Alloc>;
        pub type allocator_traits___size_type<_Alloc> = _Alloc;
        pub type allocator_traits_size_type<_Alloc> =
            root::std::allocator_traits___size_type<_Alloc>;
        pub type allocator_traits___propagate_on_container_copy_assignment<_Alloc>
            = _Alloc;
        pub type allocator_traits_propagate_on_container_copy_assignment<_Alloc>
            =
            root::std::allocator_traits___propagate_on_container_copy_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_move_assignment<_Alloc>
            = _Alloc;
        pub type allocator_traits_propagate_on_container_move_assignment<_Alloc>
            =
            root::std::allocator_traits___propagate_on_container_move_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_swap<_Alloc> =
            _Alloc;
        pub type allocator_traits_propagate_on_container_swap<_Alloc> =
            root::std::allocator_traits___propagate_on_container_swap<_Alloc>;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___allocate_helper {
            pub _address: u8,
        }
        pub type allocator_traits___allocate_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_allocate =
            root::std::allocator_traits___allocate_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct =
            root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___destroy_helper {
            pub _address: u8,
        }
        pub type allocator_traits___destroy_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_destroy =
            root::std::allocator_traits___destroy_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___maxsize_helper {
            pub _address: u8,
        }
        pub type allocator_traits___maxsize_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_max_size =
            root::std::allocator_traits___maxsize_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___select_helper {
            pub _address: u8,
        }
        pub type allocator_traits___select_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_soccc =
            root::std::allocator_traits___select_helper;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type =
            root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Alloc_value_type = [u8; 0usize];
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct _List_node_base {
                pub _M_next: *mut root::std::__detail::_List_node_base,
                pub _M_prev: *mut root::std::__detail::_List_node_base,
            }
            #[test]
            fn bindgen_test_layout__List_node_base() {
                assert_eq!(::std::mem::size_of::<_List_node_base>() , 16usize
                           , concat ! (
                           "Size of: " , stringify ! ( _List_node_base ) ));
                assert_eq! (::std::mem::align_of::<_List_node_base>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( _List_node_base )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const _List_node_base ) ) . _M_next
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            _List_node_base ) , "::" , stringify ! ( _M_next )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const _List_node_base ) ) . _M_prev
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            _List_node_base ) , "::" , stringify ! ( _M_prev )
                            ));
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
                pub fn _List_node_base_swap(__x:
                                                *mut root::std::__detail::_List_node_base,
                                            __y:
                                                *mut root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name =
                      "_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
                pub fn _List_node_base__M_transfer(this:
                                                       *mut root::std::__detail::_List_node_base,
                                                   __first:
                                                       *const root::std::__detail::_List_node_base,
                                                   __last:
                                                       *const root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base10_M_reverseEv"]
                pub fn _List_node_base__M_reverse(this:
                                                      *mut root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
                pub fn _List_node_base__M_hook(this:
                                                   *mut root::std::__detail::_List_node_base,
                                               __position:
                                                   *const root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "_ZNSt8__detail15_List_node_base9_M_unhookEv"]
                pub fn _List_node_base__M_unhook(this:
                                                     *mut root::std::__detail::_List_node_base);
            }
            impl Clone for _List_node_base {
                fn clone(&self) -> Self { *self }
            }
            impl _List_node_base {
                #[inline]
                pub unsafe fn swap(__x:
                                       *mut root::std::__detail::_List_node_base,
                                   __y:
                                       *mut root::std::__detail::_List_node_base) {
                    _List_node_base_swap(__x, __y)
                }
                #[inline]
                pub unsafe fn _M_transfer(&mut self,
                                          __first:
                                              *const root::std::__detail::_List_node_base,
                                          __last:
                                              *const root::std::__detail::_List_node_base) {
                    _List_node_base__M_transfer(self, __first, __last)
                }
                #[inline]
                pub unsafe fn _M_reverse(&mut self) {
                    _List_node_base__M_reverse(self)
                }
                #[inline]
                pub unsafe fn _M_hook(&mut self,
                                      __position:
                                          *const root::std::__detail::_List_node_base) {
                    _List_node_base__M_hook(self, __position)
                }
                #[inline]
                pub unsafe fn _M_unhook(&mut self) {
                    _List_node_base__M_unhook(self)
                }
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Fmtflags {
            _S_boolalpha = 1,
            _S_dec = 2,
            _S_fixed = 4,
            _S_hex = 8,
            _S_internal = 16,
            _S_left = 32,
            _S_oct = 64,
            _S_right = 128,
            _S_scientific = 256,
            _S_showbase = 512,
            _S_showpoint = 1024,
            _S_showpos = 2048,
            _S_skipws = 4096,
            _S_unitbuf = 8192,
            _S_uppercase = 16384,
            _S_adjustfield = 176,
            _S_basefield = 74,
            _S_floatfield = 260,
            _S_ios_fmtflags_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Openmode {
            _S_app = 1,
            _S_ate = 2,
            _S_bin = 4,
            _S_in = 8,
            _S_out = 16,
            _S_trunc = 32,
            _S_ios_openmode_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Iostate {
            _S_goodbit = 0,
            _S_badbit = 1,
            _S_eofbit = 2,
            _S_failbit = 4,
            _S_ios_iostate_end = 65536,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Ios_Seekdir {
            _S_beg = 0,
            _S_cur = 1,
            _S_end = 2,
            _S_ios_seekdir_end = 65536,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __ctype_abstract_base {
            pub _base: root::std::locale_facet,
        }
        pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
        #[test]
        fn __bindgen_test_layout_basic_ostream_instantiation_34197() {
            assert_eq!(::std::mem::size_of::<root::std::basic_ostream<::std::os::raw::c_char>>()
                       , 272usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_ostream<::std::os::raw::c_char> ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_ostream<::std::os::raw::c_char>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::basic_ostream<::std::os::raw::c_char> )
                       ));
        }
        #[test]
        fn __bindgen_test_layout_basic_istream_instantiation_34348() {
            assert_eq!(::std::mem::size_of::<root::std::basic_istream<::std::os::raw::c_char>>()
                       , 280usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_istream<::std::os::raw::c_char> ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_istream<::std::os::raw::c_char>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::basic_istream<::std::os::raw::c_char> )
                       ));
        }
        #[test]
        fn __bindgen_test_layout_basic_stringbuf_instantiation_34475() {
            assert_eq!(::std::mem::size_of::<root::std::basic_stringbuf<::std::os::raw::c_char,
                                                 root::std::allocator>>()
                       , 80usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::basic_stringbuf<::std::os::raw::c_char, root::std::allocator>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::std::basic_stringbuf<::std::os::raw::c_char,
                                                  root::std::allocator>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::std::basic_stringbuf<::std::os::raw::c_char, root::std::allocator>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct complex<_Tp> {
            pub _M_real: _Tp,
            pub _M_imag: _Tp,
        }
        pub type complex_value_type<_Tp> = _Tp;
        #[test]
        fn __bindgen_test_layout_complex_instantiation_34529() {
            assert_eq!(::std::mem::size_of::<root::std::complex<f32>>() ,
                       8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::complex<f32> ) ));
            assert_eq!(::std::mem::align_of::<root::std::complex<f32>>() ,
                       4usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::complex<f32> ) ));
        }
        #[test]
        fn __bindgen_test_layout_complex_instantiation_34533() {
            assert_eq!(::std::mem::size_of::<root::std::complex<f64>>() ,
                       16usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::complex<f64> ) ));
            assert_eq!(::std::mem::align_of::<root::std::complex<f64>>() ,
                       8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::complex<f64> ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_node<_Tp> {
            pub _base: root::std::__detail::_List_node_base,
            pub _M_data: _Tp,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_iterator {
            pub _M_node: *mut root::std::__detail::_List_node_base,
        }
        pub type _List_iterator__Self = root::std::_List_iterator;
        pub type _List_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_iterator_difference_type = isize;
        pub type _List_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _List_iterator_value_type<_Tp> = _Tp;
        pub type _List_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_const_iterator {
            pub _M_node: *const root::std::__detail::_List_node_base,
        }
        pub type _List_const_iterator__Self = root::std::_List_const_iterator;
        pub type _List_const_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_const_iterator_iterator = root::std::_List_iterator;
        pub type _List_const_iterator_difference_type = isize;
        pub type _List_const_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _List_const_iterator_value_type<_Tp> = _Tp;
        pub type _List_const_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_const_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        pub struct _List_base {
            pub _M_impl: root::std::_List_base__List_impl,
        }
        pub type _List_base__Node_alloc_type = [u8; 0usize];
        pub type _List_base__Tp_alloc_type = [u8; 0usize];
        #[repr(C)]
        pub struct _List_base__List_impl {
            pub _M_node: root::std::__detail::_List_node_base,
        }
        pub type _List_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct list {
            pub _base: root::std::_List_base,
        }
        pub type list__Alloc_value_type = [u8; 0usize];
        pub type list__Base = root::std::_List_base;
        pub type list__Tp_alloc_type = root::std::list__Base;
        pub type list__Node_alloc_type = root::std::list__Base;
        pub type list_value_type<_Tp> = _Tp;
        pub type list_pointer = root::std::list__Tp_alloc_type;
        pub type list_const_pointer = root::std::list__Tp_alloc_type;
        pub type list_reference = root::std::list__Tp_alloc_type;
        pub type list_const_reference = root::std::list__Tp_alloc_type;
        pub type list_iterator = root::std::_List_iterator;
        pub type list_const_iterator = root::std::_List_const_iterator;
        pub type list_const_reverse_iterator =
            root::std::reverse_iterator<root::std::list_const_iterator>;
        pub type list_reverse_iterator =
            root::std::reverse_iterator<root::std::list_iterator>;
        pub type list_size_type = usize;
        pub type list_difference_type = isize;
        pub type list_allocator_type<_Alloc> = _Alloc;
        pub type list__Node<_Tp> = root::std::_List_node<_Tp>;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum _Rb_tree_color { _S_red = 0, _S_black = 1, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct _Rb_tree_node_base {
            pub _M_color: root::std::_Rb_tree_color,
            pub _M_parent: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_left: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_right: root::std::_Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr =
            *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr =
            *const root::std::_Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(::std::mem::size_of::<_Rb_tree_node_base>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( _Rb_tree_node_base ) ));
            assert_eq! (::std::mem::align_of::<_Rb_tree_node_base>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( _Rb_tree_node_base )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_color
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_color )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) .
                        _M_parent as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_parent
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_left
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_left )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const _Rb_tree_node_base ) ) . _M_right
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        _Rb_tree_node_base ) , "::" , stringify ! ( _M_right )
                        ));
        }
        impl Clone for _Rb_tree_node_base {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        pub struct _Rb_tree_node {
            pub _base: root::std::_Rb_tree_node_base,
            pub _M_storage: root::__gnu_cxx::__aligned_buffer,
        }
        pub type _Rb_tree_node__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_iterator {
            pub _M_node: root::std::_Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr =
            root::std::_Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: root::std::_Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_const_iterator_iterator =
            root::std::_Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category =
            root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self =
            root::std::_Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr =
            root::std::_Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type =
            *const root::std::_Rb_tree_node;
        #[repr(C)]
        pub struct _Rb_tree<_Compare> {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr =
            *const root::std::_Rb_tree_node_base;
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> =
            *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> =
            *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> =
            *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> =
            *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree__Link_type = *mut root::std::_Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const root::std::_Rb_tree_node;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_const_iterator>;
        #[repr(C)]
        pub struct map {
            pub _M_t: root::std::map__Rep_type,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = root::std::pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        pub type map__Alloc_value_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
        }
        pub type map__Pair_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type map__Rep_type =
            root::std::_Rb_tree<root::std::map_key_compare<_Compare>>;
        pub type map__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type map_pointer = root::std::map__Alloc_traits;
        pub type map_const_pointer = root::std::map__Alloc_traits;
        pub type map_reference = root::std::map__Alloc_traits;
        pub type map_const_reference = root::std::map__Alloc_traits;
        pub type map_iterator = root::std::map__Rep_type;
        pub type map_const_iterator = root::std::map__Rep_type;
        pub type map_size_type = root::std::map__Rep_type;
        pub type map_difference_type = root::std::map__Rep_type;
        pub type map_reverse_iterator = root::std::map__Rep_type;
        pub type map_const_reverse_iterator = root::std::map__Rep_type;
    }
    pub type __time64_t = ::std::os::raw::c_longlong;
    pub type time_t = root::__time64_t;
    pub type octave_idx_type = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct _SETJMP_FLOAT128 {
        pub Part: [::std::os::raw::c_ulonglong; 2usize],
    }
    #[test]
    fn bindgen_test_layout__SETJMP_FLOAT128() {
        assert_eq!(::std::mem::size_of::<_SETJMP_FLOAT128>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( _SETJMP_FLOAT128 )
                   ));
        assert_eq! (::std::mem::align_of::<_SETJMP_FLOAT128>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( _SETJMP_FLOAT128 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const _SETJMP_FLOAT128 ) ) . Part as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( _SETJMP_FLOAT128 )
                    , "::" , stringify ! ( Part ) ));
    }
    impl Clone for _SETJMP_FLOAT128 {
        fn clone(&self) -> Self { *self }
    }
    pub type SETJMP_FLOAT128 = root::_SETJMP_FLOAT128;
    pub type _JBTYPE = root::SETJMP_FLOAT128;
    pub type jmp_buf = [root::_JBTYPE; 16usize];
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer =
            root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *mut _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment =
            root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type =
            root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference =
            *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference =
            *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other =
            root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        pub struct __aligned_buffer {
            pub _M_storage: u8,
        }
    }
    pub type mbstate_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct __gthread_once_t {
        pub done: ::std::os::raw::c_int,
        pub started: ::std::os::raw::c_long,
    }
    #[test]
    fn bindgen_test_layout___gthread_once_t() {
        assert_eq!(::std::mem::size_of::<__gthread_once_t>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( __gthread_once_t ) ));
        assert_eq! (::std::mem::align_of::<__gthread_once_t>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( __gthread_once_t ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __gthread_once_t ) ) . done as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( __gthread_once_t )
                    , "::" , stringify ! ( done ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __gthread_once_t ) ) . started as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( __gthread_once_t )
                    , "::" , stringify ! ( started ) ));
    }
    impl Clone for __gthread_once_t {
        fn clone(&self) -> Self { *self }
    }
    pub type octave_jmp_buf = root::jmp_buf;
    pub mod octave {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct exit_exception {
            pub m_exit_status: ::std::os::raw::c_int,
            pub m_safe_to_return: bool,
        }
        #[test]
        fn bindgen_test_layout_exit_exception() {
            assert_eq!(::std::mem::size_of::<exit_exception>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( exit_exception )
                       ));
            assert_eq! (::std::mem::align_of::<exit_exception>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( exit_exception ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const exit_exception ) ) .
                        m_exit_status as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( exit_exception
                        ) , "::" , stringify ! ( m_exit_status ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const exit_exception ) ) .
                        m_safe_to_return as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( exit_exception
                        ) , "::" , stringify ! ( m_safe_to_return ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct interrupt_exception {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_interrupt_exception() {
            assert_eq!(::std::mem::size_of::<interrupt_exception>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( interrupt_exception ) ));
            assert_eq! (::std::mem::align_of::<interrupt_exception>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( interrupt_exception )
                        ));
        }
        impl Clone for interrupt_exception {
            fn clone(&self) -> Self { *self }
        }
        pub mod sys {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct base_tm__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct base_tm {
                pub vtable_: *const base_tm__bindgen_vtable,
                pub m_usec: ::std::os::raw::c_int,
                pub m_sec: ::std::os::raw::c_int,
                pub m_min: ::std::os::raw::c_int,
                pub m_hour: ::std::os::raw::c_int,
                pub m_mday: ::std::os::raw::c_int,
                pub m_mon: ::std::os::raw::c_int,
                pub m_year: ::std::os::raw::c_int,
                pub m_wday: ::std::os::raw::c_int,
                pub m_yday: ::std::os::raw::c_int,
                pub m_isdst: ::std::os::raw::c_int,
                pub m_gmtoff: ::std::os::raw::c_long,
                pub m_zone: root::std::string,
            }
            #[test]
            fn bindgen_test_layout_base_tm() {
                assert_eq!(::std::mem::size_of::<base_tm>() , 64usize , concat
                           ! ( "Size of: " , stringify ! ( base_tm ) ));
                assert_eq! (::std::mem::align_of::<base_tm>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( base_tm ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_usec as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_usec ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_sec as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_sec ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_min as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_min ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_hour as *
                            const _ as usize } , 20usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_hour ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_mday as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_mday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_mon as *
                            const _ as usize } , 28usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_mon ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_year as *
                            const _ as usize } , 32usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_year ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_wday as *
                            const _ as usize } , 36usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_wday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_yday as *
                            const _ as usize } , 40usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_yday ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_isdst as *
                            const _ as usize } , 44usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_isdst ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_gmtoff as *
                            const _ as usize } , 48usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_gmtoff ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const base_tm ) ) . m_zone as *
                            const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( base_tm ) ,
                            "::" , stringify ! ( m_zone ) ));
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4usecEi"]
                pub fn base_tm_usec(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3secEi"]
                pub fn base_tm_sec(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3minEi"]
                pub fn base_tm_min(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4hourEi"]
                pub fn base_tm_hour(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4mdayEi"]
                pub fn base_tm_mday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm3monEi"]
                pub fn base_tm_mon(this: *mut root::octave::sys::base_tm,
                                   v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4yearEi"]
                pub fn base_tm_year(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4wdayEi"]
                pub fn base_tm_wday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4ydayEi"]
                pub fn base_tm_yday(this: *mut root::octave::sys::base_tm,
                                    v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm5isdstEi"]
                pub fn base_tm_isdst(this: *mut root::octave::sys::base_tm,
                                     v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm6gmtoffEl"]
                pub fn base_tm_gmtoff(this: *mut root::octave::sys::base_tm,
                                      v: ::std::os::raw::c_long)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4zoneERKSs"]
                pub fn base_tm_zone(this: *mut root::octave::sys::base_tm,
                                    s: *const root::std::string)
                 -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "_ZNK6octave3sys7base_tm8strftimeERKSs"]
                pub fn base_tm_strftime(this:
                                            *const root::octave::sys::base_tm,
                                        fmt: *const root::std::string)
                 -> root::std::string;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys7base_tm4initEPv"]
                pub fn base_tm_init(this: *mut root::octave::sys::base_tm,
                                    p: *mut ::std::os::raw::c_void);
            }
            impl base_tm {
                #[inline]
                pub unsafe fn usec(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_usec(self, v)
                }
                #[inline]
                pub unsafe fn sec(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_sec(self, v)
                }
                #[inline]
                pub unsafe fn min(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_min(self, v)
                }
                #[inline]
                pub unsafe fn hour(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_hour(self, v)
                }
                #[inline]
                pub unsafe fn mday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_mday(self, v)
                }
                #[inline]
                pub unsafe fn mon(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_mon(self, v)
                }
                #[inline]
                pub unsafe fn year(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_year(self, v)
                }
                #[inline]
                pub unsafe fn wday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_wday(self, v)
                }
                #[inline]
                pub unsafe fn yday(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_yday(self, v)
                }
                #[inline]
                pub unsafe fn isdst(&mut self, v: ::std::os::raw::c_int)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_isdst(self, v)
                }
                #[inline]
                pub unsafe fn gmtoff(&mut self, v: ::std::os::raw::c_long)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_gmtoff(self, v)
                }
                #[inline]
                pub unsafe fn zone(&mut self, s: *const root::std::string)
                 -> *mut root::octave::sys::base_tm {
                    base_tm_zone(self, s)
                }
                #[inline]
                pub unsafe fn strftime(&self, fmt: *const root::std::string)
                 -> root::std::string {
                    base_tm_strftime(self, fmt)
                }
                #[inline]
                pub unsafe fn init(&mut self,
                                   p: *mut ::std::os::raw::c_void) {
                    base_tm_init(self, p)
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct time {
                pub ot_unix_time: root::time_t,
                pub ot_usec: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_time() {
                assert_eq!(::std::mem::size_of::<time>() , 16usize , concat !
                           ( "Size of: " , stringify ! ( time ) ));
                assert_eq! (::std::mem::align_of::<time>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( time ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const time ) ) . ot_unix_time as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( time ) ,
                            "::" , stringify ! ( ot_unix_time ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const time ) ) . ot_usec as * const
                            _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( time ) ,
                            "::" , stringify ! ( ot_usec ) ));
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4time5stampEv"]
                pub fn time_stamp(this: *mut root::octave::sys::time);
            }
            extern "C" {
                #[link_name = "_ZNK6octave3sys4time5ctimeEv"]
                pub fn time_ctime(this: *const root::octave::sys::time)
                 -> root::std::string;
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4timeC1Ed"]
                pub fn time_time(this: *mut root::octave::sys::time, d: f64);
            }
            extern "C" {
                #[link_name = "_ZN6octave3sys4timeC1ERKNS0_7base_tmE"]
                pub fn time_time1(this: *mut root::octave::sys::time,
                                  tm: *const root::octave::sys::base_tm);
            }
            impl time {
                #[inline]
                pub unsafe fn stamp(&mut self) { time_stamp(self) }
                #[inline]
                pub unsafe fn ctime(&self) -> root::std::string {
                    time_ctime(self)
                }
                #[inline]
                pub unsafe fn new(d: f64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    time_time(&mut __bindgen_tmp, d);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(tm: *const root::octave::sys::base_tm)
                 -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    time_time1(&mut __bindgen_tmp, tm);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct localtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_localtime() {
                assert_eq!(::std::mem::size_of::<localtime>() , 64usize ,
                           concat ! ( "Size of: " , stringify ! ( localtime )
                           ));
                assert_eq! (::std::mem::align_of::<localtime>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( localtime ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct gmtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_gmtime() {
                assert_eq!(::std::mem::size_of::<gmtime>() , 64usize , concat
                           ! ( "Size of: " , stringify ! ( gmtime ) ));
                assert_eq! (::std::mem::align_of::<gmtime>() , 8usize , concat
                            ! ( "Alignment of " , stringify ! ( gmtime ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct strptime {
                pub _base: root::octave::sys::base_tm,
                pub nchars: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_strptime() {
                assert_eq!(::std::mem::size_of::<strptime>() , 72usize ,
                           concat ! ( "Size of: " , stringify ! ( strptime )
                           ));
                assert_eq! (::std::mem::align_of::<strptime>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( strptime ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const strptime ) ) . nchars as *
                            const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( strptime )
                            , "::" , stringify ! ( nchars ) ));
            }
        }
        #[test]
        fn __bindgen_test_layout_map_instantiation_83990() {
            assert_eq!(::std::mem::size_of::<root::std::map>() , 48usize ,
                       concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::std::map ) ));
            assert_eq!(::std::mem::align_of::<root::std::map>() , 8usize ,
                       concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::std::map ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct dynamic_library {
            pub rep: *mut root::octave::dynamic_library_dynlib_rep,
        }
        pub type dynamic_library_name_mangler =
            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                           *const root::std::string)
                                      -> root::std::string>;
        pub type dynamic_library_close_hook =
            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                           *const root::std::string)>;
        #[repr(C)]
        pub struct dynamic_library_dynlib_rep__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct dynamic_library_dynlib_rep {
            pub vtable_: *const dynamic_library_dynlib_rep__bindgen_vtable,
            pub count: root::octave_refcount<::std::os::raw::c_int>,
            pub file: root::std::string,
            pub tm_loaded: root::octave::sys::time,
            pub fcn_names: root::std::map,
        }
        pub type dynamic_library_dynlib_rep_fcn_names_iterator = u8;
        pub type dynamic_library_dynlib_rep_fcn_names_const_iterator = u8;
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep9instancesE"]
            pub static mut dynamic_library_dynlib_rep_instances:
                       root::std::map;
        }
        #[test]
        fn bindgen_test_layout_dynamic_library_dynlib_rep() {
            assert_eq!(::std::mem::size_of::<dynamic_library_dynlib_rep>() ,
                       88usize , concat ! (
                       "Size of: " , stringify ! ( dynamic_library_dynlib_rep
                       ) ));
            assert_eq! (::std::mem::align_of::<dynamic_library_dynlib_rep>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        dynamic_library_dynlib_rep ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        count as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        count ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        file as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        file ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        tm_loaded as * const _ as usize } , 24usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        tm_loaded ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library_dynlib_rep ) ) .
                        fcn_names as * const _ as usize } , 40usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        dynamic_library_dynlib_rep ) , "::" , stringify ! (
                        fcn_names ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZNK6octave15dynamic_library10dynlib_rep14is_out_of_dateEv"]
            pub fn dynamic_library_dynlib_rep_is_out_of_date(this:
                                                                 *const root::octave::dynamic_library_dynlib_rep)
             -> bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12new_instanceERKSs"]
            pub fn dynamic_library_dynlib_rep_new_instance(f:
                                                               *const root::std::string)
             -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12get_instanceERKSsb"]
            pub fn dynamic_library_dynlib_rep_get_instance(f:
                                                               *const root::std::string,
                                                           fake: bool)
             -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep12add_fcn_nameERKSs"]
            pub fn dynamic_library_dynlib_rep_add_fcn_name(this:
                                                               *mut root::octave::dynamic_library_dynlib_rep,
                                                           arg1:
                                                               *const root::std::string);
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep15remove_fcn_nameERKSs"]
            pub fn dynamic_library_dynlib_rep_remove_fcn_name(this:
                                                                  *mut root::octave::dynamic_library_dynlib_rep,
                                                              arg1:
                                                                  *const root::std::string)
             -> bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep13do_close_hookEPFvRKSsE"]
            pub fn dynamic_library_dynlib_rep_do_close_hook(this:
                                                                *mut root::octave::dynamic_library_dynlib_rep,
                                                            cl_hook:
                                                                root::octave::dynamic_library_close_hook);
        }
        extern "C" {
            #[link_name =
                  "_ZN6octave15dynamic_library10dynlib_rep11fake_reloadEv"]
            pub fn dynamic_library_dynlib_rep_fake_reload(this:
                                                              *mut root::octave::dynamic_library_dynlib_rep);
        }
        extern "C" {
            #[link_name = "_ZN6octave15dynamic_library10dynlib_repC1ERKSs"]
            pub fn dynamic_library_dynlib_rep_dynlib_rep(this:
                                                             *mut root::octave::dynamic_library_dynlib_rep,
                                                         f:
                                                             *const root::std::string);
        }
        impl dynamic_library_dynlib_rep {
            #[inline]
            pub unsafe fn is_out_of_date(&self) -> bool {
                dynamic_library_dynlib_rep_is_out_of_date(self)
            }
            #[inline]
            pub unsafe fn new_instance(f: *const root::std::string)
             -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_new_instance(f)
            }
            #[inline]
            pub unsafe fn get_instance(f: *const root::std::string,
                                       fake: bool)
             -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_get_instance(f, fake)
            }
            #[inline]
            pub unsafe fn add_fcn_name(&mut self,
                                       arg1: *const root::std::string) {
                dynamic_library_dynlib_rep_add_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn remove_fcn_name(&mut self,
                                          arg1: *const root::std::string)
             -> bool {
                dynamic_library_dynlib_rep_remove_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn do_close_hook(&mut self,
                                        cl_hook:
                                            root::octave::dynamic_library_close_hook) {
                dynamic_library_dynlib_rep_do_close_hook(self, cl_hook)
            }
            #[inline]
            pub unsafe fn fake_reload(&mut self) {
                dynamic_library_dynlib_rep_fake_reload(self)
            }
            #[inline]
            pub unsafe fn new(f: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                dynamic_library_dynlib_rep_dynlib_rep(&mut __bindgen_tmp, f);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "_ZN6octave15dynamic_library7nil_repE"]
            pub static mut dynamic_library_nil_rep:
                       root::octave::dynamic_library_dynlib_rep;
        }
        #[test]
        fn bindgen_test_layout_dynamic_library() {
            assert_eq!(::std::mem::size_of::<dynamic_library>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( dynamic_library ) ));
            assert_eq! (::std::mem::align_of::<dynamic_library>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( dynamic_library ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const dynamic_library ) ) . rep as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( dynamic_library
                        ) , "::" , stringify ! ( rep ) ));
        }
    }
    pub type octave_execution_exception = root::octave::exit_exception;
    pub type octave_exit_exception = root::octave::exit_exception;
    pub type octave_interrupt_exception = root::octave::interrupt_exception;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_exception {
        octave_no_exception = 0,
        octave_exec_exception = 1,
        octave_alloc_exception = 3,
        octave_quit_exception = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_refcount<T> {
        pub count: root::octave_refcount_count_type<T>,
    }
    pub type octave_refcount_count_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct dim_vector {
        pub rep: *mut root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_dim_vector() {
        assert_eq!(::std::mem::size_of::<dim_vector>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( dim_vector ) ));
        assert_eq! (::std::mem::align_of::<dim_vector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( dim_vector ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const dim_vector ) ) . rep as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( dim_vector ) , "::"
                    , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector19chop_all_singletonsEv"]
        pub fn dim_vector_chop_all_singletons(this: *mut root::dim_vector);
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector7dim_maxEv"]
        pub fn dim_vector_dim_max() -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector3strEc"]
        pub fn dim_vector_str(this: *const root::dim_vector,
                              sep: ::std::os::raw::c_char)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector8num_onesEv"]
        pub fn dim_vector_num_ones(this: *const root::dim_vector)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector10safe_numelEv"]
        pub fn dim_vector_safe_numel(this: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector7squeezeEv"]
        pub fn dim_vector_squeeze(this: *const root::dim_vector)
         -> root::dim_vector;
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector6concatERKS_i"]
        pub fn dim_vector_concat(this: *mut root::dim_vector,
                                 dvb: *const root::dim_vector,
                                 dim: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        #[link_name = "_ZN10dim_vector5hvcatERKS_i"]
        pub fn dim_vector_hvcat(this: *mut root::dim_vector,
                                dvb: *const root::dim_vector,
                                dim: ::std::os::raw::c_int) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10dim_vector5redimEi"]
        pub fn dim_vector_redim(this: *const root::dim_vector,
                                n: ::std::os::raw::c_int) -> root::dim_vector;
    }
    impl dim_vector {
        #[inline]
        pub unsafe fn chop_all_singletons(&mut self) {
            dim_vector_chop_all_singletons(self)
        }
        #[inline]
        pub unsafe fn dim_max() -> root::octave_idx_type {
            dim_vector_dim_max()
        }
        #[inline]
        pub unsafe fn str(&self, sep: ::std::os::raw::c_char)
         -> root::std::string {
            dim_vector_str(self, sep)
        }
        #[inline]
        pub unsafe fn num_ones(&self) -> ::std::os::raw::c_int {
            dim_vector_num_ones(self)
        }
        #[inline]
        pub unsafe fn safe_numel(&self) -> root::octave_idx_type {
            dim_vector_safe_numel(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::dim_vector {
            dim_vector_squeeze(self)
        }
        #[inline]
        pub unsafe fn concat(&mut self, dvb: *const root::dim_vector,
                             dim: ::std::os::raw::c_int) -> bool {
            dim_vector_concat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn hvcat(&mut self, dvb: *const root::dim_vector,
                            dim: ::std::os::raw::c_int) -> bool {
            dim_vector_hvcat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn redim(&self, n: ::std::os::raw::c_int)
         -> root::dim_vector {
            dim_vector_redim(self, n)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int<T> {
        pub ival: T,
    }
    pub type octave_int_val_type<T> = T;
    pub type octave_int8 = root::octave_int<::std::os::raw::c_schar>;
    pub type octave_int16 = root::octave_int<::std::os::raw::c_short>;
    pub type octave_int32 = root::octave_int<::std::os::raw::c_int>;
    pub type octave_int64 = root::octave_int<::std::os::raw::c_longlong>;
    pub type octave_uint8 = root::octave_int<::std::os::raw::c_uchar>;
    pub type octave_uint16 = root::octave_int<::std::os::raw::c_ushort>;
    pub type octave_uint32 = root::octave_int<::std::os::raw::c_uint>;
    pub type octave_uint64 = root::octave_int<::std::os::raw::c_ulonglong>;
    #[repr(C)]
    pub struct Array__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array<T> {
        pub vtable_: *const Array__bindgen_vtable,
        pub dimensions: root::dim_vector,
        pub rep: *mut root::Array_ArrayRep<T>,
        pub slice_data: *mut T,
        pub slice_len: root::octave_idx_type,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array_ArrayRep<T> {
        pub data: *mut T,
        pub len: root::octave_idx_type,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    pub type Array_element_type<T> = T;
    pub type Array_value_type<T> = T;
    pub type Array_size_type = root::octave_idx_type;
    pub type Array_crefT = root::ref_param;
    pub type Array_compare_fcn_type =
        ::std::option::Option<unsafe extern "C" fn(arg1: root::ref_param,
                                                   arg2: root::ref_param)
                                  -> bool>;
    #[repr(C)]
    pub struct Sparse__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse<T> {
        pub vtable_: *const Sparse__bindgen_vtable,
        pub rep: *mut root::Sparse_SparseRep<T>,
        pub dimensions: root::dim_vector,
    }
    pub type Sparse_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse_SparseRep<T> {
        pub d: *mut T,
        pub r: *mut root::octave_idx_type,
        pub c: *mut root::octave_idx_type,
        pub nzmx: root::octave_idx_type,
        pub nrows: root::octave_idx_type,
        pub ncols: root::octave_idx_type,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Range {
        pub rng_base: f64,
        pub rng_limit: f64,
        pub rng_inc: f64,
        pub rng_numel: root::octave_idx_type,
        pub cache: root::Matrix,
    }
    #[test]
    fn bindgen_test_layout_Range() {
        assert_eq!(::std::mem::size_of::<Range>() , 72usize , concat ! (
                   "Size of: " , stringify ! ( Range ) ));
        assert_eq! (::std::mem::align_of::<Range>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Range ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_base as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_limit as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_limit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_inc as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_inc ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . rng_numel as * const _ as
                    usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( rng_numel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Range ) ) . cache as * const _ as
                    usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( Range ) , "::" ,
                    stringify ! ( cache ) ));
    }
    extern "C" {
        #[link_name = "_ZNK5Range21all_elements_are_intsEv"]
        pub fn Range_all_elements_are_ints(this: *const root::Range) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK5Range12matrix_valueEv"]
        pub fn Range_matrix_value(this: *const root::Range) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK5Range3minEv"]
        pub fn Range_min(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range3maxEv"]
        pub fn Range_max(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "_ZN5Range13sort_internalEb"]
        pub fn Range_sort_internal(this: *mut root::Range, ascending: bool);
    }
    extern "C" {
        #[link_name = "_ZN5Range13sort_internalER5ArrayIiEb"]
        pub fn Range_sort_internal1(this: *mut root::Range,
                                    sidx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    ascending: bool);
    }
    extern "C" {
        #[link_name = "_ZNK5Range4diagEi"]
        pub fn Range_diag(this: *const root::Range, k: root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4sortEi8sortmode"]
        pub fn Range_sort(this: *const root::Range,
                          dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4sortER5ArrayIiEi8sortmode"]
        pub fn Range_sort1(this: *const root::Range,
                           sidx: *mut root::Array<::std::os::raw::c_int>,
                           dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK5Range9is_sortedE8sortmode"]
        pub fn Range_is_sorted(this: *const root::Range, mode: root::sortmode)
         -> root::sortmode;
    }
    extern "C" {
        #[link_name = "_ZNK5Range9checkelemEi"]
        pub fn Range_checkelem(this: *const root::Range,
                               i: root::octave_idx_type) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range4elemEi"]
        pub fn Range_elem(this: *const root::Range, i: root::octave_idx_type)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK5Range5indexERK10idx_vector"]
        pub fn Range_index(this: *const root::Range,
                           i: *const root::idx_vector) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZN5Range8set_baseEd"]
        pub fn Range_set_base(this: *mut root::Range, b: f64);
    }
    extern "C" {
        #[link_name = "_ZN5Range9set_limitEd"]
        pub fn Range_set_limit(this: *mut root::Range, l: f64);
    }
    extern "C" {
        #[link_name = "_ZN5Range7set_incEd"]
        pub fn Range_set_inc(this: *mut root::Range, i: f64);
    }
    impl Range {
        #[inline]
        pub unsafe fn all_elements_are_ints(&self) -> bool {
            Range_all_elements_are_ints(self)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            Range_matrix_value(self)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { Range_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { Range_max(self) }
        #[inline]
        pub unsafe fn sort_internal(&mut self, ascending: bool) {
            Range_sort_internal(self, ascending)
        }
        #[inline]
        pub unsafe fn sort_internal1(&mut self,
                                     sidx:
                                         *mut root::Array<::std::os::raw::c_int>,
                                     ascending: bool) {
            Range_sort_internal1(self, sidx, ascending)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Range_diag(self, k)
        }
        #[inline]
        pub unsafe fn sort(&self, dim: root::octave_idx_type,
                           mode: root::sortmode) -> root::Range {
            Range_sort(self, dim, mode)
        }
        #[inline]
        pub unsafe fn sort1(&self,
                            sidx: *mut root::Array<::std::os::raw::c_int>,
                            dim: root::octave_idx_type, mode: root::sortmode)
         -> root::Range {
            Range_sort1(self, sidx, dim, mode)
        }
        #[inline]
        pub unsafe fn is_sorted(&self, mode: root::sortmode)
         -> root::sortmode {
            Range_is_sorted(self, mode)
        }
        #[inline]
        pub unsafe fn checkelem(&self, i: root::octave_idx_type) -> f64 {
            Range_checkelem(self, i)
        }
        #[inline]
        pub unsafe fn elem(&self, i: root::octave_idx_type) -> f64 {
            Range_elem(self, i)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector)
         -> root::Array<f64> {
            Range_index(self, i)
        }
        #[inline]
        pub unsafe fn set_base(&mut self, b: f64) { Range_set_base(self, b) }
        #[inline]
        pub unsafe fn set_limit(&mut self, l: f64) {
            Range_set_limit(self, l)
        }
        #[inline]
        pub unsafe fn set_inc(&mut self, i: f64) { Range_set_inc(self, i) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector {
        pub rep: *mut root::idx_vector_idx_base_rep,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum idx_vector_idx_class_type {
        class_invalid = -1,
        class_colon = 0,
        class_range = 1,
        class_scalar = 2,
        class_vector = 3,
        class_mask = 4,
    }
    #[repr(C)]
    pub struct idx_vector_idx_base_rep__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_base_rep {
        pub vtable_: *const idx_vector_idx_base_rep__bindgen_vtable,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
        pub err: bool,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_base_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_base_rep>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_base_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_base_rep>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_base_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . count
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_base_rep ) , "::" , stringify ! ( count )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_base_rep ) ) . err as
                    * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_base_rep ) , "::" , stringify ! ( err ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_colon_rep {
        pub _base: root::idx_vector_idx_base_rep,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_colon_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_colon_rep>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_colon_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_colon_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_colon_rep )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_colon_repC1Ec"]
        pub fn idx_vector_idx_colon_rep_idx_colon_rep(this:
                                                          *mut root::idx_vector_idx_colon_rep,
                                                      c:
                                                          ::std::os::raw::c_char);
    }
    impl idx_vector_idx_colon_rep {
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_colon_rep_idx_colon_rep(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum idx_vector_direct { DIRECT = 0, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_range_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub start: root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub step: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_range_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_range_rep>() , 32usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_range_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_range_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_range_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . start
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( start )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . len as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( len )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_range_rep ) ) . step
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_range_rep ) , "::" , stringify ! ( step )
                    ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector13idx_range_rep9unconvertEv"]
        pub fn idx_vector_idx_range_rep_unconvert(this:
                                                      *const root::idx_vector_idx_range_rep)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_range_repC1Eiii"]
        pub fn idx_vector_idx_range_rep_idx_range_rep(this:
                                                          *mut root::idx_vector_idx_range_rep,
                                                      _start:
                                                          root::octave_idx_type,
                                                      _limit:
                                                          root::octave_idx_type,
                                                      _step:
                                                          root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector13idx_range_repC1ERK5Range"]
        pub fn idx_vector_idx_range_rep_idx_range_rep1(this:
                                                           *mut root::idx_vector_idx_range_rep,
                                                       arg1:
                                                           *const root::Range);
    }
    impl idx_vector_idx_range_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Range {
            idx_vector_idx_range_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(_start: root::octave_idx_type,
                          _limit: root::octave_idx_type,
                          _step: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep(&mut __bindgen_tmp, _start,
                                                   _limit, _step);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Range) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_scalar_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_scalar_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_scalar_rep>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_scalar_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_scalar_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_scalar_rep
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_scalar_rep ) ) . data
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_scalar_rep ) , "::" , stringify ! ( data )
                    ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14idx_scalar_rep9unconvertEv"]
        pub fn idx_vector_idx_scalar_rep_unconvert(this:
                                                       *const root::idx_vector_idx_scalar_rep)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_scalar_repC1Ei"]
        pub fn idx_vector_idx_scalar_rep_idx_scalar_rep(this:
                                                            *mut root::idx_vector_idx_scalar_rep,
                                                        i:
                                                            root::octave_idx_type);
    }
    impl idx_vector_idx_scalar_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> f64 {
            idx_vector_idx_scalar_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(i: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_scalar_rep_idx_scalar_rep(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_vector_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub aowner: *mut root::Array<::std::os::raw::c_int>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_vector_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_vector_rep>() ,
                   48usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_vector_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_vector_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_vector_rep
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . data
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( data )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . len
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( len )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) . ext
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( ext )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) .
                    aowner as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! ( aowner
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_vector_rep ) ) .
                    orig_dims as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_vector_rep ) , "::" , stringify ! (
                    orig_dims ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14idx_vector_rep9unconvertEv"]
        pub fn idx_vector_idx_vector_rep_unconvert(this:
                                                       *const root::idx_vector_idx_vector_rep)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIiE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep(this:
                                                            *mut root::idx_vector_idx_vector_rep,
                                                        inda:
                                                            *const root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name =
              "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIiEiNS_6directE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep1(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         inda:
                                                             *const root::Array<::std::os::raw::c_int>,
                                                         _ext:
                                                             root::octave_idx_type,
                                                         arg1:
                                                             root::idx_vector_direct);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1Eb"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep2(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK5ArrayIbEi"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep3(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1:
                                                             *const root::Array<bool>,
                                                         arg2:
                                                             root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector14idx_vector_repC1ERK6SparseIbE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep4(this:
                                                             *mut root::idx_vector_idx_vector_rep,
                                                         arg1:
                                                             *const root::Sparse<bool>);
    }
    impl idx_vector_idx_vector_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<f64> {
            idx_vector_idx_vector_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(inda: *const root::Array<::std::os::raw::c_int>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep(&mut __bindgen_tmp,
                                                     inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(inda: *const root::Array<::std::os::raw::c_int>,
                           _ext: root::octave_idx_type,
                           arg1: root::idx_vector_direct) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep1(&mut __bindgen_tmp,
                                                      inda, _ext, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep2(&mut __bindgen_tmp,
                                                      arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(arg1: *const root::Array<bool>,
                           arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep3(&mut __bindgen_tmp,
                                                      arg1, arg2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(arg1: *const root::Sparse<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep4(&mut __bindgen_tmp,
                                                      arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_mask_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const bool,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub lsti: root::octave_idx_type,
        pub lste: root::octave_idx_type,
        pub aowner: *mut root::Array<bool>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_mask_rep() {
        assert_eq!(::std::mem::size_of::<idx_vector_idx_mask_rep>() , 56usize
                   , concat ! (
                   "Size of: " , stringify ! ( idx_vector_idx_mask_rep ) ));
        assert_eq! (::std::mem::align_of::<idx_vector_idx_mask_rep>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( idx_vector_idx_mask_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . data as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( data )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . len as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( len ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . ext as
                    * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( ext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lsti as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( lsti )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . lste as
                    * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( lste )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) . aowner
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( aowner )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector_idx_mask_rep ) ) .
                    orig_dims as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    idx_vector_idx_mask_rep ) , "::" , stringify ! ( orig_dims
                    ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector12idx_mask_rep9unconvertEv"]
        pub fn idx_vector_idx_mask_rep_unconvert(this:
                                                     *const root::idx_vector_idx_mask_rep)
         -> root::Array<bool>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12idx_mask_repC1Eb"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep(this:
                                                        *mut root::idx_vector_idx_mask_rep,
                                                    arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12idx_mask_repC1ERK5ArrayIbEi"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep1(this:
                                                         *mut root::idx_vector_idx_mask_rep,
                                                     arg1:
                                                         *const root::Array<bool>,
                                                     arg2:
                                                         root::octave_idx_type);
    }
    impl idx_vector_idx_mask_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<bool> {
            idx_vector_idx_mask_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Array<bool>,
                           arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep1(&mut __bindgen_tmp, arg1,
                                                  arg2);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector5colonE"]
        pub static idx_vector_colon: root::idx_vector;
    }
    #[test]
    fn bindgen_test_layout_idx_vector() {
        assert_eq!(::std::mem::size_of::<idx_vector>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( idx_vector ) ));
        assert_eq! (::std::mem::align_of::<idx_vector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( idx_vector ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const idx_vector ) ) . rep as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( idx_vector ) , "::"
                    , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector12maybe_reduceEiRKS_i"]
        pub fn idx_vector_maybe_reduce(this: *mut root::idx_vector,
                                       n: root::octave_idx_type,
                                       j: *const root::idx_vector,
                                       nj: root::octave_idx_type) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector13is_cont_rangeEiRiS0_"]
        pub fn idx_vector_is_cont_range(this: *const root::idx_vector,
                                        n: root::octave_idx_type,
                                        l: *mut root::octave_idx_type,
                                        u: *mut root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9incrementEv"]
        pub fn idx_vector_increment(this: *const root::idx_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector10complementEi"]
        pub fn idx_vector_complement(this: *const root::idx_vector,
                                     n: root::octave_idx_type)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector14is_permutationEi"]
        pub fn idx_vector_is_permutation(this: *const root::idx_vector,
                                         n: root::octave_idx_type) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector19inverse_permutationEi"]
        pub fn idx_vector_inverse_permutation(this: *const root::idx_vector,
                                              n: root::octave_idx_type)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9copy_dataEPi"]
        pub fn idx_vector_copy_data(this: *const root::idx_vector,
                                    data: *mut root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector6unmaskEv"]
        pub fn idx_vector_unmask(this: *const root::idx_vector)
         -> root::idx_vector;
    }
    extern "C" {
        #[link_name =
              "_ZNK10idx_vector9unconvertERNS_14idx_class_typeERdR5RangeR5ArrayIdERS5_IbE"]
        pub fn idx_vector_unconvert(this: *const root::idx_vector,
                                    iclass:
                                        *mut root::idx_vector_idx_class_type,
                                    scalar: *mut f64, range: *mut root::Range,
                                    array: *mut root::Array<f64>,
                                    mask: *mut root::Array<bool>);
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector8as_arrayEv"]
        pub fn idx_vector_as_array(this: *const root::idx_vector)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector3rawEv"]
        pub fn idx_vector_raw(this: *mut root::idx_vector)
         -> *const root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector9is_vectorEv"]
        pub fn idx_vector_is_vector(this: *const root::idx_vector) -> bool;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vector6freezeEiPKcb"]
        pub fn idx_vector_freeze(this: *mut root::idx_vector,
                                 z_len: root::octave_idx_type,
                                 tag: *const ::std::os::raw::c_char,
                                 resize_ok: bool) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10idx_vector10ones_countEv"]
        pub fn idx_vector_ones_count(this: *const root::idx_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN10idx_vectorC1ERK5ArrayIbE"]
        pub fn idx_vector_idx_vector(this: *mut root::idx_vector,
                                     nda: *const root::Array<bool>);
    }
    impl idx_vector {
        #[inline]
        pub unsafe fn maybe_reduce(&mut self, n: root::octave_idx_type,
                                   j: *const root::idx_vector,
                                   nj: root::octave_idx_type) -> bool {
            idx_vector_maybe_reduce(self, n, j, nj)
        }
        #[inline]
        pub unsafe fn is_cont_range(&self, n: root::octave_idx_type,
                                    l: *mut root::octave_idx_type,
                                    u: *mut root::octave_idx_type) -> bool {
            idx_vector_is_cont_range(self, n, l, u)
        }
        #[inline]
        pub unsafe fn increment(&self) -> root::octave_idx_type {
            idx_vector_increment(self)
        }
        #[inline]
        pub unsafe fn complement(&self, n: root::octave_idx_type)
         -> root::idx_vector {
            idx_vector_complement(self, n)
        }
        #[inline]
        pub unsafe fn is_permutation(&self, n: root::octave_idx_type)
         -> bool {
            idx_vector_is_permutation(self, n)
        }
        #[inline]
        pub unsafe fn inverse_permutation(&self, n: root::octave_idx_type)
         -> root::idx_vector {
            idx_vector_inverse_permutation(self, n)
        }
        #[inline]
        pub unsafe fn copy_data(&self, data: *mut root::octave_idx_type) {
            idx_vector_copy_data(self, data)
        }
        #[inline]
        pub unsafe fn unmask(&self) -> root::idx_vector {
            idx_vector_unmask(self)
        }
        #[inline]
        pub unsafe fn unconvert(&self,
                                iclass: *mut root::idx_vector_idx_class_type,
                                scalar: *mut f64, range: *mut root::Range,
                                array: *mut root::Array<f64>,
                                mask: *mut root::Array<bool>) {
            idx_vector_unconvert(self, iclass, scalar, range, array, mask)
        }
        #[inline]
        pub unsafe fn as_array(&self) -> root::Array<::std::os::raw::c_int> {
            idx_vector_as_array(self)
        }
        #[inline]
        pub unsafe fn raw(&mut self) -> *const root::octave_idx_type {
            idx_vector_raw(self)
        }
        #[inline]
        pub unsafe fn is_vector(&self) -> bool { idx_vector_is_vector(self) }
        #[inline]
        pub unsafe fn freeze(&mut self, z_len: root::octave_idx_type,
                             tag: *const ::std::os::raw::c_char,
                             resize_ok: bool) -> root::octave_idx_type {
            idx_vector_freeze(self, z_len, tag, resize_ok)
        }
        #[inline]
        pub unsafe fn ones_count(&self) -> root::octave_idx_type {
            idx_vector_ones_count(self)
        }
        #[inline]
        pub unsafe fn new(nda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            idx_vector_idx_vector(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ref_param {
        pub _address: u8,
    }
    pub type ref_param_type = u8;
    pub type Complex = root::std::complex<f64>;
    pub type FloatComplex = root::std::complex<f32>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum sortmode { UNSORTED = 0, ASCENDING = 1, DESCENDING = 2, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_sort<T> {
        pub compare: root::octave_sort_compare_fcn_type,
        pub ms: *mut root::octave_sort_MergeState<T>,
    }
    pub type octave_sort_compare_fcn_type =
        ::std::option::Option<unsafe extern "C" fn(arg1: root::ref_param,
                                                   arg2: root::ref_param)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_sort_s_slice {
        pub base: root::octave_idx_type,
        pub len: root::octave_idx_type,
    }
    #[repr(C)]
    pub struct octave_sort_MergeState<T> {
        pub min_gallop: root::octave_idx_type,
        pub a: *mut T,
        pub ia: *mut root::octave_idx_type,
        pub alloced: root::octave_idx_type,
        pub n: root::octave_idx_type,
        pub pending: [root::octave_sort_s_slice; 85usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PermMatrix {
        pub _base: root::Array<::std::os::raw::c_int>,
    }
    #[test]
    fn bindgen_test_layout_PermMatrix() {
        assert_eq!(::std::mem::size_of::<PermMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( PermMatrix ) ));
        assert_eq! (::std::mem::align_of::<PermMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( PermMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix9checkelemEii"]
        pub fn PermMatrix_checkelem(this: *const root::PermMatrix,
                                    i: root::octave_idx_type,
                                    j: root::octave_idx_type)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix9transposeEv"]
        pub fn PermMatrix_transpose(this: *const root::PermMatrix)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix7inverseEv"]
        pub fn PermMatrix_inverse(this: *const root::PermMatrix)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix11determinantEv"]
        pub fn PermMatrix_determinant(this: *const root::PermMatrix)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK10PermMatrix5powerEi"]
        pub fn PermMatrix_power(this: *const root::PermMatrix,
                                n: root::octave_idx_type) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrix3eyeEi"]
        pub fn PermMatrix_eye(n: root::octave_idx_type) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1Ei"]
        pub fn PermMatrix_PermMatrix(this: *mut root::PermMatrix,
                                     n: root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK5ArrayIiE"]
        pub fn PermMatrix_PermMatrix1(this: *mut root::PermMatrix,
                                      p:
                                          *const root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK5ArrayIiEbb"]
        pub fn PermMatrix_PermMatrix2(this: *mut root::PermMatrix,
                                      p:
                                          *const root::Array<::std::os::raw::c_int>,
                                      colp: bool, check: bool);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK10idx_vector"]
        pub fn PermMatrix_PermMatrix3(this: *mut root::PermMatrix,
                                      idx: *const root::idx_vector);
    }
    extern "C" {
        #[link_name = "_ZN10PermMatrixC1ERK10idx_vectorbi"]
        pub fn PermMatrix_PermMatrix4(this: *mut root::PermMatrix,
                                      idx: *const root::idx_vector,
                                      colp: bool, n: root::octave_idx_type);
    }
    impl PermMatrix {
        #[inline]
        pub unsafe fn checkelem(&self, i: root::octave_idx_type,
                                j: root::octave_idx_type)
         -> root::octave_idx_type {
            PermMatrix_checkelem(self, i, j)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::PermMatrix {
            PermMatrix_transpose(self)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::PermMatrix {
            PermMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::octave_idx_type {
            PermMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn power(&self, n: root::octave_idx_type)
         -> root::PermMatrix {
            PermMatrix_power(self, n)
        }
        #[inline]
        pub unsafe fn eye(n: root::octave_idx_type) -> root::PermMatrix {
            PermMatrix_eye(n)
        }
        #[inline]
        pub unsafe fn new(n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix(&mut __bindgen_tmp, n);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(p: *const root::Array<::std::os::raw::c_int>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix1(&mut __bindgen_tmp, p);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(p: *const root::Array<::std::os::raw::c_int>,
                           colp: bool, check: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix2(&mut __bindgen_tmp, p, colp, check);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(idx: *const root::idx_vector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix3(&mut __bindgen_tmp, idx);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(idx: *const root::idx_vector, colp: bool,
                           n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            PermMatrix_PermMatrix4(&mut __bindgen_tmp, idx, colp, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_local_buffer<T> {
        pub data: *mut T,
    }
    #[repr(C)]
    pub struct octave_chunk_buffer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_chunk_buffer {
        pub vtable_: *const octave_chunk_buffer__bindgen_vtable,
        pub cnk: *mut ::std::os::raw::c_char,
        pub dat: *mut ::std::os::raw::c_char,
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer10chunk_sizeE"]
        pub static octave_chunk_buffer_chunk_size: usize;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer3topE"]
        pub static mut octave_chunk_buffer_top: *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer5chunkE"]
        pub static mut octave_chunk_buffer_chunk: *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer4leftE"]
        pub static mut octave_chunk_buffer_left: usize;
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer6activeE"]
        pub static mut octave_chunk_buffer_active: usize;
    }
    #[test]
    fn bindgen_test_layout_octave_chunk_buffer() {
        assert_eq!(::std::mem::size_of::<octave_chunk_buffer>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_chunk_buffer ) ));
        assert_eq! (::std::mem::align_of::<octave_chunk_buffer>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_chunk_buffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_chunk_buffer ) ) . cnk as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_chunk_buffer
                    ) , "::" , stringify ! ( cnk ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_chunk_buffer ) ) . dat as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_chunk_buffer
                    ) , "::" , stringify ! ( dat ) ));
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_buffer5clearEv"]
        pub fn octave_chunk_buffer_clear();
    }
    extern "C" {
        #[link_name = "_ZN19octave_chunk_bufferC1Ey"]
        pub fn octave_chunk_buffer_octave_chunk_buffer(this:
                                                           *mut root::octave_chunk_buffer,
                                                       size: usize);
    }
    impl octave_chunk_buffer {
        #[inline]
        pub unsafe fn clear() { octave_chunk_buffer_clear() }
        #[inline]
        pub unsafe fn new(size: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_chunk_buffer_octave_chunk_buffer(&mut __bindgen_tmp, size);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35406() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<bool>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<bool>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35410() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35414() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_ushort>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ushort> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_ushort>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ushort> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35418() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_short>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_short> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_short>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_short> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35422() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_int>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35426() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_uint>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35430() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_long>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_long> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_long>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_long> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35434() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<::std::os::raw::c_ulong>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ulong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<::std::os::raw::c_ulong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<::std::os::raw::c_ulong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35438() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<f32>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<f32>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35442() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<f64>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<f64>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35446() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_local_buffer_instantiation_35449() {
        assert_eq!(::std::mem::size_of::<root::octave_local_buffer<root::std::complex<f32>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_local_buffer<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_local_buffer<root::std::complex<f32>> ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_prom {
        pub _address: u8,
    }
    pub type octave_int_cmp_op_prom_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_lt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_lt_ltval: bool = true;
    pub const octave_int_cmp_op_lt_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_lt() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_lt>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_lt ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_lt>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_lt ) ));
    }
    impl Clone for octave_int_cmp_op_lt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_le {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_le_ltval: bool = true;
    pub const octave_int_cmp_op_le_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_le() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_le>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_le ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_le>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_le ) ));
    }
    impl Clone for octave_int_cmp_op_le {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_gt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_gt_ltval: bool = false;
    pub const octave_int_cmp_op_gt_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_gt() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_gt>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_gt ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_gt>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_gt ) ));
    }
    impl Clone for octave_int_cmp_op_gt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ge {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ge_ltval: bool = false;
    pub const octave_int_cmp_op_ge_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ge() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ge>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ge ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ge>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ge ) ));
    }
    impl Clone for octave_int_cmp_op_ge {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_eq {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_eq_ltval: bool = false;
    pub const octave_int_cmp_op_eq_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_eq() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_eq>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_eq ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_eq>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_eq ) ));
    }
    impl Clone for octave_int_cmp_op_eq {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ne {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ne_ltval: bool = true;
    pub const octave_int_cmp_op_ne_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ne() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ne>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ne ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ne>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ne ) ));
    }
    impl Clone for octave_int_cmp_op_ne {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_ct {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ct_ltval: bool = true;
    pub const octave_int_cmp_op_ct_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ct() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_ct>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_ct ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_ct>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_ct ) ));
    }
    impl Clone for octave_int_cmp_op_ct {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_int_cmp_op_cf {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_cf_ltval: bool = false;
    pub const octave_int_cmp_op_cf_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_cf() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op_cf>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_int_cmp_op_cf ) ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op_cf>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op_cf ) ));
    }
    impl Clone for octave_int_cmp_op_cf {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op() {
        assert_eq!(::std::mem::size_of::<octave_int_cmp_op>() , 1usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_int_cmp_op )
                   ));
        assert_eq! (::std::mem::align_of::<octave_int_cmp_op>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_int_cmp_op ) ));
    }
    impl Clone for octave_int_cmp_op {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_base {
        pub _address: u8,
    }
    #[repr(C)]
    pub struct octave_int_arith {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MArray<T> {
        pub _base: root::Array<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MSparse<T> {
        pub _base: root::Sparse<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Matrix {
        pub _base: root::NDArray,
    }
    pub type Matrix_column_vector_type = root::ColumnVector;
    pub type Matrix_row_vector_type = root::RowVector;
    pub type Matrix_real_column_vector_type = root::ColumnVector;
    pub type Matrix_real_row_vector_type = root::RowVector;
    pub type Matrix_real_matrix_type = root::Matrix;
    pub type Matrix_complex_matrix_type = root::ComplexMatrix;
    pub type Matrix_real_diag_matrix_type = root::DiagMatrix;
    pub type Matrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type Matrix_real_elt_type = f64;
    pub type Matrix_complex_elt_type = root::Complex;
    pub type Matrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_Matrix() {
        assert_eq!(::std::mem::size_of::<Matrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( Matrix ) ));
        assert_eq! (::std::mem::align_of::<Matrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Matrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix12is_symmetricEv"]
        pub fn Matrix_is_symmetric(this: *const root::Matrix) -> bool;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERKS_ii"]
        pub fn Matrix_insert(this: *mut root::Matrix, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK9RowVectorii"]
        pub fn Matrix_insert1(this: *mut root::Matrix,
                              a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK12ColumnVectorii"]
        pub fn Matrix_insert2(this: *mut root::Matrix,
                              a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix6insertERK10DiagMatrixii"]
        pub fn Matrix_insert3(this: *mut root::Matrix,
                              a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix4fillEd"]
        pub fn Matrix_fill(this: *mut root::Matrix, val: f64)
         -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZN6Matrix4fillEdiiii"]
        pub fn Matrix_fill1(this: *mut root::Matrix, val: f64,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERKS_"]
        pub fn Matrix_append(this: *const root::Matrix,
                             a: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK9RowVector"]
        pub fn Matrix_append1(this: *const root::Matrix,
                              a: *const root::RowVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK12ColumnVector"]
        pub fn Matrix_append2(this: *const root::Matrix,
                              a: *const root::ColumnVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6appendERK10DiagMatrix"]
        pub fn Matrix_append3(this: *const root::Matrix,
                              a: *const root::DiagMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERKS_"]
        pub fn Matrix_stack(this: *const root::Matrix, a: *const root::Matrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK9RowVector"]
        pub fn Matrix_stack1(this: *const root::Matrix,
                             a: *const root::RowVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK12ColumnVector"]
        pub fn Matrix_stack2(this: *const root::Matrix,
                             a: *const root::ColumnVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5stackERK10DiagMatrix"]
        pub fn Matrix_stack3(this: *const root::Matrix,
                             a: *const root::DiagMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7extractEiiii"]
        pub fn Matrix_extract(this: *const root::Matrix,
                              r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix9extract_nEiiii"]
        pub fn Matrix_extract_n(this: *const root::Matrix,
                                r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3rowEi"]
        pub fn Matrix_row(this: *const root::Matrix, i: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6columnEi"]
        pub fn Matrix_column(this: *const root::Matrix,
                             i: root::octave_idx_type) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseEv"]
        pub fn Matrix_inverse(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseERi"]
        pub fn Matrix_inverse1(this: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseERiRdbb"]
        pub fn Matrix_inverse2(this: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixType"]
        pub fn Matrix_inverse3(this: *const root::Matrix,
                               mattype: *mut root::MatrixType)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixTypeRi"]
        pub fn Matrix_inverse4(this: *const root::Matrix,
                               mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7inverseER10MatrixTypeRiRdbb"]
        pub fn Matrix_inverse5(this: *const root::Matrix,
                               mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix14pseudo_inverseEd"]
        pub fn Matrix_pseudo_inverse(this: *const root::Matrix, tol: f64)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7fourierEv"]
        pub fn Matrix_fourier(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix8ifourierEv"]
        pub fn Matrix_ifourier(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix9fourier2dEv"]
        pub fn Matrix_fourier2d(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10ifourier2dEv"]
        pub fn Matrix_ifourier2d(this: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantEv"]
        pub fn Matrix_determinant(this: *const root::Matrix) -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantERi"]
        pub fn Matrix_determinant1(this: *const root::Matrix,
                                   info: *mut root::octave_idx_type)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantERiRdb"]
        pub fn Matrix_determinant2(this: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix11determinantER10MatrixTypeRiRdb"]
        pub fn Matrix_determinant3(this: *const root::Matrix,
                                   mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5rcondEv"]
        pub fn Matrix_rcond(this: *const root::Matrix) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5rcondER10MatrixType"]
        pub fn Matrix_rcond1(this: *const root::Matrix,
                             mattype: *mut root::MatrixType) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_"]
        pub fn Matrix_solve(this: *const root::Matrix,
                            typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_Ri"]
        pub fn Matrix_solve1(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn Matrix_solve2(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRKS_RiRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve3(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn Matrix_solve4(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn Matrix_solve5(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn Matrix_solve6(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve7(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn Matrix_solve8(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn Matrix_solve9(this: *const root::Matrix,
                             typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn Matrix_solve10(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve11(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn Matrix_solve12(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn Matrix_solve13(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn Matrix_solve14(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve15(this: *const root::Matrix,
                              typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_"]
        pub fn Matrix_solve16(this: *const root::Matrix,
                              b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_Ri"]
        pub fn Matrix_solve17(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_RiRd"]
        pub fn Matrix_solve18(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERKS_RiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve19(this: *const root::Matrix,
                              b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrix"]
        pub fn Matrix_solve20(this: *const root::Matrix,
                              b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrixRi"]
        pub fn Matrix_solve21(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK13ComplexMatrixRiRd"]
        pub fn Matrix_solve22(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK13ComplexMatrixRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve23(this: *const root::Matrix,
                              b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVector"]
        pub fn Matrix_solve24(this: *const root::Matrix,
                              b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVectorRi"]
        pub fn Matrix_solve25(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK12ColumnVectorRiRd"]
        pub fn Matrix_solve26(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve27(this: *const root::Matrix,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVector"]
        pub fn Matrix_solve28(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVectorRi"]
        pub fn Matrix_solve29(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn Matrix_solve30(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK6Matrix5solveERK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve31(this: *const root::Matrix,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_"]
        pub fn Matrix_lssolve(this: *const root::Matrix,
                              b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_Ri"]
        pub fn Matrix_lssolve1(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_RiS2_"]
        pub fn Matrix_lssolve2(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERKS_RiS2_Rd"]
        pub fn Matrix_lssolve3(this: *const root::Matrix,
                               b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrix"]
        pub fn Matrix_lssolve4(this: *const root::Matrix,
                               b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRi"]
        pub fn Matrix_lssolve5(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRiS3_"]
        pub fn Matrix_lssolve6(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK13ComplexMatrixRiS3_Rd"]
        pub fn Matrix_lssolve7(this: *const root::Matrix,
                               b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVector"]
        pub fn Matrix_lssolve8(this: *const root::Matrix,
                               b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRi"]
        pub fn Matrix_lssolve9(this: *const root::Matrix,
                               b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRiS3_"]
        pub fn Matrix_lssolve10(this: *const root::Matrix,
                                b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK12ColumnVectorRiS3_Rd"]
        pub fn Matrix_lssolve11(this: *const root::Matrix,
                                b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVector"]
        pub fn Matrix_lssolve12(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRi"]
        pub fn Matrix_lssolve13(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRiS3_"]
        pub fn Matrix_lssolve14(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7lssolveERK19ComplexColumnVectorRiS3_Rd"]
        pub fn Matrix_lssolve15(this: *const root::Matrix,
                                b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3allEi"]
        pub fn Matrix_all(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3anyEi"]
        pub fn Matrix_any(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7cumprodEi"]
        pub fn Matrix_cumprod(this: *const root::Matrix,
                              dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix6cumsumEi"]
        pub fn Matrix_cumsum(this: *const root::Matrix,
                             dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4prodEi"]
        pub fn Matrix_prod(this: *const root::Matrix,
                           dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3sumEi"]
        pub fn Matrix_sum(this: *const root::Matrix,
                          dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix5sumsqEi"]
        pub fn Matrix_sumsq(this: *const root::Matrix,
                            dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix3absEv"]
        pub fn Matrix_abs(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4diagEi"]
        pub fn Matrix_diag(this: *const root::Matrix,
                           k: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix4diagEii"]
        pub fn Matrix_diag1(this: *const root::Matrix,
                            m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_minEv"]
        pub fn Matrix_row_min(this: *const root::Matrix)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_maxEv"]
        pub fn Matrix_row_max(this: *const root::Matrix)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_minER5ArrayIiE"]
        pub fn Matrix_row_min1(this: *const root::Matrix,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix7row_maxER5ArrayIiE"]
        pub fn Matrix_row_max1(this: *const root::Matrix,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_minEv"]
        pub fn Matrix_column_min(this: *const root::Matrix)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_maxEv"]
        pub fn Matrix_column_max(this: *const root::Matrix)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_minER5ArrayIiE"]
        pub fn Matrix_column_min1(this: *const root::Matrix,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK6Matrix10column_maxER5ArrayIiE"]
        pub fn Matrix_column_max1(this: *const root::Matrix,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK9RowVector"]
        pub fn Matrix_Matrix(this: *mut root::Matrix,
                             rv: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK12ColumnVector"]
        pub fn Matrix_Matrix1(this: *mut root::Matrix,
                              cv: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10DiagMatrix"]
        pub fn Matrix_Matrix2(this: *mut root::Matrix,
                              a: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK11MDiagArray2IdE"]
        pub fn Matrix_Matrix3(this: *mut root::Matrix,
                              a: *const root::MDiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10DiagArray2IdE"]
        pub fn Matrix_Matrix4(this: *mut root::Matrix,
                              a: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10PermMatrix"]
        pub fn Matrix_Matrix5(this: *mut root::Matrix,
                              a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10boolMatrix"]
        pub fn Matrix_Matrix6(this: *mut root::Matrix,
                              a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN6MatrixC1ERK10charMatrix"]
        pub fn Matrix_Matrix7(this: *mut root::Matrix,
                              a: *const root::charMatrix);
    }
    impl Matrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            Matrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::Matrix {
            Matrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type) -> *mut root::Matrix {
            Matrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector)
         -> root::Matrix {
            Matrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector)
         -> root::Matrix {
            Matrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix)
         -> root::Matrix {
            Matrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector)
         -> root::Matrix {
            Matrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector)
         -> root::Matrix {
            Matrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix)
         -> root::Matrix {
            Matrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix {
            Matrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type) -> root::Matrix {
            Matrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            Matrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::Matrix { Matrix_inverse(self) }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix {
            Matrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::Matrix {
            Matrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::Matrix {
            Matrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::Matrix {
            Matrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            Matrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            Matrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            Matrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            Matrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            Matrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::DET {
            Matrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET {
            Matrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::DET {
            Matrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { Matrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            Matrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix {
            Matrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::Matrix {
            Matrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type) -> root::Matrix {
            Matrix_solve3(self, typ, b, info, rcon, sing_handler,
                          singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            Matrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::Matrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            Matrix_solve7(self, typ, b, info, rcon, sing_handler,
                          singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector {
            Matrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector {
            Matrix_solve11(self, typ, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            Matrix_solve15(self, typ, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::Matrix {
            Matrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type) -> root::Matrix {
            Matrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            Matrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            Matrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ColumnVector {
            Matrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ColumnVector {
            Matrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::Matrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            Matrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::Matrix {
            Matrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::Matrix {
            Matrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            Matrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            Matrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            Matrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            Matrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ColumnVector {
            Matrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ColumnVector {
            Matrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            Matrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            Matrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            Matrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            Matrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            Matrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::Matrix {
            Matrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix { Matrix_abs(self) }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Matrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::DiagMatrix {
            Matrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ColumnVector {
            Matrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ColumnVector {
            Matrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector {
            Matrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ColumnVector {
            Matrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::RowVector {
            Matrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::RowVector {
            Matrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector {
            Matrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::RowVector {
            Matrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Matrix_Matrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexMatrix {
        pub _base: root::ComplexNDArray,
    }
    pub type ComplexMatrix_column_vector_type = root::ComplexColumnVector;
    pub type ComplexMatrix_row_vector_type = root::ComplexRowVector;
    pub type ComplexMatrix_real_column_vector_type = root::ColumnVector;
    pub type ComplexMatrix_real_row_vector_type = root::RowVector;
    pub type ComplexMatrix_real_matrix_type = root::Matrix;
    pub type ComplexMatrix_complex_matrix_type = root::ComplexMatrix;
    pub type ComplexMatrix_real_diag_matrix_type = root::DiagMatrix;
    pub type ComplexMatrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type ComplexMatrix_real_elt_type = f64;
    pub type ComplexMatrix_complex_elt_type = root::Complex;
    pub type ComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_ComplexMatrix() {
        assert_eq!(::std::mem::size_of::<ComplexMatrix>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( ComplexMatrix ) ));
        assert_eq! (::std::mem::align_of::<ComplexMatrix>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( ComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix12is_hermitianEv"]
        pub fn ComplexMatrix_is_hermitian(this: *const root::ComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK6Matrixii"]
        pub fn ComplexMatrix_insert(this: *mut root::ComplexMatrix,
                                    a: *const root::Matrix,
                                    r: root::octave_idx_type,
                                    c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK9RowVectorii"]
        pub fn ComplexMatrix_insert1(this: *mut root::ComplexMatrix,
                                     a: *const root::RowVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK12ColumnVectorii"]
        pub fn ComplexMatrix_insert2(this: *mut root::ComplexMatrix,
                                     a: *const root::ColumnVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK10DiagMatrixii"]
        pub fn ComplexMatrix_insert3(this: *mut root::ComplexMatrix,
                                     a: *const root::DiagMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERKS_ii"]
        pub fn ComplexMatrix_insert4(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK16ComplexRowVectorii"]
        pub fn ComplexMatrix_insert5(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexRowVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK19ComplexColumnVectorii"]
        pub fn ComplexMatrix_insert6(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexColumnVector,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix6insertERK17ComplexDiagMatrixii"]
        pub fn ComplexMatrix_insert7(this: *mut root::ComplexMatrix,
                                     a: *const root::ComplexDiagMatrix,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillEd"]
        pub fn ComplexMatrix_fill(this: *mut root::ComplexMatrix, val: f64)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillERKSt7complexIdE"]
        pub fn ComplexMatrix_fill1(this: *mut root::ComplexMatrix,
                                   val: *const root::Complex)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillEdiiii"]
        pub fn ComplexMatrix_fill2(this: *mut root::ComplexMatrix, val: f64,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrix4fillERKSt7complexIdEiiii"]
        pub fn ComplexMatrix_fill3(this: *mut root::ComplexMatrix,
                                   val: *const root::Complex,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK6Matrix"]
        pub fn ComplexMatrix_append(this: *const root::ComplexMatrix,
                                    a: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK9RowVector"]
        pub fn ComplexMatrix_append1(this: *const root::ComplexMatrix,
                                     a: *const root::RowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK12ColumnVector"]
        pub fn ComplexMatrix_append2(this: *const root::ComplexMatrix,
                                     a: *const root::ColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK10DiagMatrix"]
        pub fn ComplexMatrix_append3(this: *const root::ComplexMatrix,
                                     a: *const root::DiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERKS_"]
        pub fn ComplexMatrix_append4(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK16ComplexRowVector"]
        pub fn ComplexMatrix_append5(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexRowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK19ComplexColumnVector"]
        pub fn ComplexMatrix_append6(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6appendERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_append7(this: *const root::ComplexMatrix,
                                     a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK6Matrix"]
        pub fn ComplexMatrix_stack(this: *const root::ComplexMatrix,
                                   a: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK9RowVector"]
        pub fn ComplexMatrix_stack1(this: *const root::ComplexMatrix,
                                    a: *const root::RowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK12ColumnVector"]
        pub fn ComplexMatrix_stack2(this: *const root::ComplexMatrix,
                                    a: *const root::ColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK10DiagMatrix"]
        pub fn ComplexMatrix_stack3(this: *const root::ComplexMatrix,
                                    a: *const root::DiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERKS_"]
        pub fn ComplexMatrix_stack4(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK16ComplexRowVector"]
        pub fn ComplexMatrix_stack5(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexRowVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK19ComplexColumnVector"]
        pub fn ComplexMatrix_stack6(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5stackERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_stack7(this: *const root::ComplexMatrix,
                                    a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7extractEiiii"]
        pub fn ComplexMatrix_extract(this: *const root::ComplexMatrix,
                                     r1: root::octave_idx_type,
                                     c1: root::octave_idx_type,
                                     r2: root::octave_idx_type,
                                     c2: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix9extract_nEiiii"]
        pub fn ComplexMatrix_extract_n(this: *const root::ComplexMatrix,
                                       r1: root::octave_idx_type,
                                       c1: root::octave_idx_type,
                                       nr: root::octave_idx_type,
                                       nc: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3rowEi"]
        pub fn ComplexMatrix_row(this: *const root::ComplexMatrix,
                                 i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6columnEi"]
        pub fn ComplexMatrix_column(this: *const root::ComplexMatrix,
                                    i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseEv"]
        pub fn ComplexMatrix_inverse(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseERi"]
        pub fn ComplexMatrix_inverse1(this: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseERiRdbb"]
        pub fn ComplexMatrix_inverse2(this: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rcon: *mut f64, force: bool,
                                      calc_cond: bool) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixType"]
        pub fn ComplexMatrix_inverse3(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn ComplexMatrix_inverse4(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn ComplexMatrix_inverse5(this: *const root::ComplexMatrix,
                                      mattype: *mut root::MatrixType,
                                      info: *mut root::octave_idx_type,
                                      rcon: *mut f64, force: bool,
                                      calc_cond: bool) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix14pseudo_inverseEd"]
        pub fn ComplexMatrix_pseudo_inverse(this: *const root::ComplexMatrix,
                                            tol: f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7fourierEv"]
        pub fn ComplexMatrix_fourier(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix8ifourierEv"]
        pub fn ComplexMatrix_ifourier(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix9fourier2dEv"]
        pub fn ComplexMatrix_fourier2d(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10ifourier2dEv"]
        pub fn ComplexMatrix_ifourier2d(this: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantEv"]
        pub fn ComplexMatrix_determinant(this: *const root::ComplexMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantERi"]
        pub fn ComplexMatrix_determinant1(this: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantERiRdb"]
        pub fn ComplexMatrix_determinant2(this: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix11determinantER10MatrixTypeRiRdb"]
        pub fn ComplexMatrix_determinant3(this: *const root::ComplexMatrix,
                                          mattype: *mut root::MatrixType,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5rcondEv"]
        pub fn ComplexMatrix_rcond(this: *const root::ComplexMatrix) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5rcondER10MatrixType"]
        pub fn ComplexMatrix_rcond1(this: *const root::ComplexMatrix,
                                    mattype: *mut root::MatrixType) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn ComplexMatrix_solve(this: *const root::ComplexMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn ComplexMatrix_solve1(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn ComplexMatrix_solve2(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve3(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64,
                                    sing_handler:
                                        root::ComplexMatrix_solve_singularity_handler,
                                    singular_fallback: bool,
                                    transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn ComplexMatrix_solve4(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn ComplexMatrix_solve5(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn ComplexMatrix_solve6(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve7(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f64,
                                    sing_handler:
                                        root::ComplexMatrix_solve_singularity_handler,
                                    singular_fallback: bool,
                                    transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn ComplexMatrix_solve8(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn ComplexMatrix_solve9(this: *const root::ComplexMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn ComplexMatrix_solve10(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve11(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve12(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_solve13(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn ComplexMatrix_solve14(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve15(this: *const root::ComplexMatrix,
                                     typ: *mut root::MatrixType,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6Matrix"]
        pub fn ComplexMatrix_solve16(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6MatrixRi"]
        pub fn ComplexMatrix_solve17(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK6MatrixRiRd"]
        pub fn ComplexMatrix_solve18(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK6MatrixRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve19(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_"]
        pub fn ComplexMatrix_solve20(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_Ri"]
        pub fn ComplexMatrix_solve21(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERKS_RiRd"]
        pub fn ComplexMatrix_solve22(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERKS_RiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve23(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexMatrix,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVector"]
        pub fn ComplexMatrix_solve24(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVectorRi"]
        pub fn ComplexMatrix_solve25(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK12ColumnVectorRiRd"]
        pub fn ComplexMatrix_solve26(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK12ColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve27(this: *const root::ComplexMatrix,
                                     b: *const root::ColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve28(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_solve29(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn ComplexMatrix_solve30(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRiRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve31(this: *const root::ComplexMatrix,
                                     b: *const root::ComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rcon: *mut f64,
                                     sing_handler:
                                         root::ComplexMatrix_solve_singularity_handler,
                                     transt: root::blas_trans_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6Matrix"]
        pub fn ComplexMatrix_lssolve(this: *const root::ComplexMatrix,
                                     b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRi"]
        pub fn ComplexMatrix_lssolve1(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRiS3_"]
        pub fn ComplexMatrix_lssolve2(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK6MatrixRiS3_Rd"]
        pub fn ComplexMatrix_lssolve3(this: *const root::ComplexMatrix,
                                      b: *const root::Matrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type,
                                      rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_"]
        pub fn ComplexMatrix_lssolve4(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_Ri"]
        pub fn ComplexMatrix_lssolve5(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_RiS2_"]
        pub fn ComplexMatrix_lssolve6(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERKS_RiS2_Rd"]
        pub fn ComplexMatrix_lssolve7(this: *const root::ComplexMatrix,
                                      b: *const root::ComplexMatrix,
                                      info: *mut root::octave_idx_type,
                                      rank: *mut root::octave_idx_type,
                                      rcon: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVector"]
        pub fn ComplexMatrix_lssolve8(this: *const root::ComplexMatrix,
                                      b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRi"]
        pub fn ComplexMatrix_lssolve9(this: *const root::ComplexMatrix,
                                      b: *const root::ColumnVector,
                                      info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRiS3_"]
        pub fn ComplexMatrix_lssolve10(this: *const root::ComplexMatrix,
                                       b: *const root::ColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRiS3_Rd"]
        pub fn ComplexMatrix_lssolve11(this: *const root::ComplexMatrix,
                                       b: *const root::ColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type,
                                       rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_lssolve12(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRi"]
        pub fn ComplexMatrix_lssolve13(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRiS3_"]
        pub fn ComplexMatrix_lssolve14(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRiS3_Rd"]
        pub fn ComplexMatrix_lssolve15(this: *const root::ComplexMatrix,
                                       b: *const root::ComplexColumnVector,
                                       info: *mut root::octave_idx_type,
                                       rank: *mut root::octave_idx_type,
                                       rcon: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3allEi"]
        pub fn ComplexMatrix_all(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3anyEi"]
        pub fn ComplexMatrix_any(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7cumprodEi"]
        pub fn ComplexMatrix_cumprod(this: *const root::ComplexMatrix,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix6cumsumEi"]
        pub fn ComplexMatrix_cumsum(this: *const root::ComplexMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4prodEi"]
        pub fn ComplexMatrix_prod(this: *const root::ComplexMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3sumEi"]
        pub fn ComplexMatrix_sum(this: *const root::ComplexMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix5sumsqEi"]
        pub fn ComplexMatrix_sumsq(this: *const root::ComplexMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix3absEv"]
        pub fn ComplexMatrix_abs(this: *const root::ComplexMatrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4diagEi"]
        pub fn ComplexMatrix_diag(this: *const root::ComplexMatrix,
                                  k: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix4diagEii"]
        pub fn ComplexMatrix_diag1(this: *const root::ComplexMatrix,
                                   m: root::octave_idx_type,
                                   n: root::octave_idx_type)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix16row_is_real_onlyEi"]
        pub fn ComplexMatrix_row_is_real_only(this:
                                                  *const root::ComplexMatrix,
                                              arg1: root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix19column_is_real_onlyEi"]
        pub fn ComplexMatrix_column_is_real_only(this:
                                                     *const root::ComplexMatrix,
                                                 arg1: root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_minEv"]
        pub fn ComplexMatrix_row_min(this: *const root::ComplexMatrix)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_maxEv"]
        pub fn ComplexMatrix_row_max(this: *const root::ComplexMatrix)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_minER5ArrayIiE"]
        pub fn ComplexMatrix_row_min1(this: *const root::ComplexMatrix,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix7row_maxER5ArrayIiE"]
        pub fn ComplexMatrix_row_max1(this: *const root::ComplexMatrix,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_minEv"]
        pub fn ComplexMatrix_column_min(this: *const root::ComplexMatrix)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_maxEv"]
        pub fn ComplexMatrix_column_max(this: *const root::ComplexMatrix)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_minER5ArrayIiE"]
        pub fn ComplexMatrix_column_min1(this: *const root::ComplexMatrix,
                                         index:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK13ComplexMatrix10column_maxER5ArrayIiE"]
        pub fn ComplexMatrix_column_max1(this: *const root::ComplexMatrix,
                                         index:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK6MatrixS2_"]
        pub fn ComplexMatrix_ComplexMatrix(this: *mut root::ComplexMatrix,
                                           re: *const root::Matrix,
                                           im: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK6Matrix"]
        pub fn ComplexMatrix_ComplexMatrix1(this: *mut root::ComplexMatrix,
                                            a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK9RowVector"]
        pub fn ComplexMatrix_ComplexMatrix2(this: *mut root::ComplexMatrix,
                                            rv: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK12ColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix3(this: *mut root::ComplexMatrix,
                                            cv: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix4(this: *mut root::ComplexMatrix,
                                            a: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK11MDiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix5(this: *mut root::ComplexMatrix,
                                            a: *const root::MDiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix6(this: *mut root::ComplexMatrix,
                                            a: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK16ComplexRowVector"]
        pub fn ComplexMatrix_ComplexMatrix7(this: *mut root::ComplexMatrix,
                                            rv:
                                                *const root::ComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK19ComplexColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix8(this: *mut root::ComplexMatrix,
                                            cv:
                                                *const root::ComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix9(this: *mut root::ComplexMatrix,
                                            a:
                                                *const root::ComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK11MDiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix10(this: *mut root::ComplexMatrix,
                                             a:
                                                 *const root::MDiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix11(this: *mut root::ComplexMatrix,
                                             a:
                                                 *const root::DiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10boolMatrix"]
        pub fn ComplexMatrix_ComplexMatrix12(this: *mut root::ComplexMatrix,
                                             a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN13ComplexMatrixC1ERK10charMatrix"]
        pub fn ComplexMatrix_ComplexMatrix13(this: *mut root::ComplexMatrix,
                                             a: *const root::charMatrix);
    }
    impl ComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            ComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Matrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::RowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::DiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(&mut self, a: *const root::ComplexMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(&mut self, a: *const root::ComplexRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(&mut self, a: *const root::ComplexColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(&mut self, a: *const root::ComplexDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexMatrix {
            ComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(&self, a: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(&self, a: *const root::ComplexRowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(&self, a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(&self, a: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(&self, a: *const root::ComplexRowVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexMatrix {
            ComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(&self, a: *const root::ComplexDiagMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::ComplexMatrix {
            ComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f64, force: bool, calc_cond: bool)
         -> root::ComplexMatrix {
            ComplexMatrix_inverse5(self, mattype, info, rcon, force,
                                   calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::ComplexMatrix {
            ComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDET {
            ComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            ComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            ComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { ComplexMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            ComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            ComplexMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::ComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                                 singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64)
         -> root::ComplexMatrix {
            ComplexMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f64,
                             sing_handler:
                                 root::ComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                                 singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::ColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                  transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                  transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexMatrix {
            ComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f64,
                              sing_handler:
                                  root::ComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::Matrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::ComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f64) -> root::ComplexMatrix {
            ComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::ColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::ColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self, b: *const root::ComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f64) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            ComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            ComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexMatrix {
            ComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix { ComplexMatrix_abs(self) }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::ComplexDiagMatrix {
            ComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            ComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            ComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector {
            ComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexColumnVector {
            ComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector {
            ComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::ComplexRowVector {
            ComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(re: *const root::Matrix, im: *const root::Matrix)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix(&mut __bindgen_tmp, re, im);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix2(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix3(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(rv: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix7(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(cv: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix8(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a:
                                *const root::MDiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a:
                                *const root::DiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexMatrix_ComplexMatrix13(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatMatrix {
        pub _base: root::FloatNDArray,
    }
    pub type FloatMatrix_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatMatrix_complex_matrix_type = root::FloatComplexMatrix;
    pub type FloatMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatMatrix_complex_diag_matrix_type =
        root::FloatComplexDiagMatrix;
    pub type FloatMatrix_real_elt_type = f32;
    pub type FloatMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatMatrix() {
        assert_eq!(::std::mem::size_of::<FloatMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( FloatMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatMatrix>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( FloatMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix12is_symmetricEv"]
        pub fn FloatMatrix_is_symmetric(this: *const root::FloatMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERKS_ii"]
        pub fn FloatMatrix_insert(this: *mut root::FloatMatrix,
                                  a: *const root::FloatMatrix,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK14FloatRowVectorii"]
        pub fn FloatMatrix_insert1(this: *mut root::FloatMatrix,
                                   a: *const root::FloatRowVector,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK17FloatColumnVectorii"]
        pub fn FloatMatrix_insert2(this: *mut root::FloatMatrix,
                                   a: *const root::FloatColumnVector,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix6insertERK15FloatDiagMatrixii"]
        pub fn FloatMatrix_insert3(this: *mut root::FloatMatrix,
                                   a: *const root::FloatDiagMatrix,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix4fillEf"]
        pub fn FloatMatrix_fill(this: *mut root::FloatMatrix, val: f32)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrix4fillEfiiii"]
        pub fn FloatMatrix_fill1(this: *mut root::FloatMatrix, val: f32,
                                 r1: root::octave_idx_type,
                                 c1: root::octave_idx_type,
                                 r2: root::octave_idx_type,
                                 c2: root::octave_idx_type)
         -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERKS_"]
        pub fn FloatMatrix_append(this: *const root::FloatMatrix,
                                  a: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK14FloatRowVector"]
        pub fn FloatMatrix_append1(this: *const root::FloatMatrix,
                                   a: *const root::FloatRowVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK17FloatColumnVector"]
        pub fn FloatMatrix_append2(this: *const root::FloatMatrix,
                                   a: *const root::FloatColumnVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatMatrix_append3(this: *const root::FloatMatrix,
                                   a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERKS_"]
        pub fn FloatMatrix_stack(this: *const root::FloatMatrix,
                                 a: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK14FloatRowVector"]
        pub fn FloatMatrix_stack1(this: *const root::FloatMatrix,
                                  a: *const root::FloatRowVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK17FloatColumnVector"]
        pub fn FloatMatrix_stack2(this: *const root::FloatMatrix,
                                  a: *const root::FloatColumnVector)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatMatrix_stack3(this: *const root::FloatMatrix,
                                  a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7extractEiiii"]
        pub fn FloatMatrix_extract(this: *const root::FloatMatrix,
                                   r1: root::octave_idx_type,
                                   c1: root::octave_idx_type,
                                   r2: root::octave_idx_type,
                                   c2: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix9extract_nEiiii"]
        pub fn FloatMatrix_extract_n(this: *const root::FloatMatrix,
                                     r1: root::octave_idx_type,
                                     c1: root::octave_idx_type,
                                     nr: root::octave_idx_type,
                                     nc: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3rowEi"]
        pub fn FloatMatrix_row(this: *const root::FloatMatrix,
                               i: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6columnEi"]
        pub fn FloatMatrix_column(this: *const root::FloatMatrix,
                                  i: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseEv"]
        pub fn FloatMatrix_inverse(this: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseERi"]
        pub fn FloatMatrix_inverse1(this: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseERiRfbb"]
        pub fn FloatMatrix_inverse2(this: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f32, force: bool,
                                    calc_cond: bool) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixType"]
        pub fn FloatMatrix_inverse3(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixTypeRi"]
        pub fn FloatMatrix_inverse4(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7inverseER10MatrixTypeRiRfbb"]
        pub fn FloatMatrix_inverse5(this: *const root::FloatMatrix,
                                    mattype: *mut root::MatrixType,
                                    info: *mut root::octave_idx_type,
                                    rcon: *mut f32, force: bool,
                                    calc_cond: bool) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix14pseudo_inverseEf"]
        pub fn FloatMatrix_pseudo_inverse(this: *const root::FloatMatrix,
                                          tol: f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7fourierEv"]
        pub fn FloatMatrix_fourier(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix8ifourierEv"]
        pub fn FloatMatrix_ifourier(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix9fourier2dEv"]
        pub fn FloatMatrix_fourier2d(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10ifourier2dEv"]
        pub fn FloatMatrix_ifourier2d(this: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantEv"]
        pub fn FloatMatrix_determinant(this: *const root::FloatMatrix)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantERi"]
        pub fn FloatMatrix_determinant1(this: *const root::FloatMatrix,
                                        info: *mut root::octave_idx_type)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantERiRfb"]
        pub fn FloatMatrix_determinant2(this: *const root::FloatMatrix,
                                        info: *mut root::octave_idx_type,
                                        rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix11determinantER10MatrixTypeRiRfb"]
        pub fn FloatMatrix_determinant3(this: *const root::FloatMatrix,
                                        mattype: *mut root::MatrixType,
                                        info: *mut root::octave_idx_type,
                                        rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5rcondEv"]
        pub fn FloatMatrix_rcond(this: *const root::FloatMatrix) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5rcondER10MatrixType"]
        pub fn FloatMatrix_rcond1(this: *const root::FloatMatrix,
                                  mattype: *mut root::MatrixType) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatMatrix_solve(this: *const root::FloatMatrix,
                                 typ: *mut root::MatrixType,
                                 b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn FloatMatrix_solve1(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RiRf"]
        pub fn FloatMatrix_solve2(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RiRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve3(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32,
                                  sing_handler:
                                      root::FloatMatrix_solve_singularity_handler,
                                  singular_fallback: bool,
                                  transt: root::blas_trans_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve4(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_solve5(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRiRf"]
        pub fn FloatMatrix_solve6(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRiRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve7(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatComplexMatrix,
                                  info: *mut root::octave_idx_type,
                                  rcon: *mut f32,
                                  sing_handler:
                                      root::FloatMatrix_solve_singularity_handler,
                                  singular_fallback: bool,
                                  transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatMatrix_solve8(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRi"]
        pub fn FloatMatrix_solve9(this: *const root::FloatMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::FloatColumnVector,
                                  info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRf"]
        pub fn FloatMatrix_solve10(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve11(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve12(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_solve13(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRf"]
        pub fn FloatMatrix_solve14(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve15(this: *const root::FloatMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_"]
        pub fn FloatMatrix_solve16(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_Ri"]
        pub fn FloatMatrix_solve17(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERKS_RiRf"]
        pub fn FloatMatrix_solve18(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERKS_RiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve19(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve20(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_solve21(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRiRf"]
        pub fn FloatMatrix_solve22(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve23(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVector"]
        pub fn FloatMatrix_solve24(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRi"]
        pub fn FloatMatrix_solve25(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRiRf"]
        pub fn FloatMatrix_solve26(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve27(this: *const root::FloatMatrix,
                                   b: *const root::FloatColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve28(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_solve29(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRiRf"]
        pub fn FloatMatrix_solve30(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve31(this: *const root::FloatMatrix,
                                   b: *const root::FloatComplexColumnVector,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32,
                                   sing_handler:
                                       root::FloatMatrix_solve_singularity_handler,
                                   transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_"]
        pub fn FloatMatrix_lssolve(this: *const root::FloatMatrix,
                                   b: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_Ri"]
        pub fn FloatMatrix_lssolve1(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_RiS2_"]
        pub fn FloatMatrix_lssolve2(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERKS_RiS2_Rf"]
        pub fn FloatMatrix_lssolve3(this: *const root::FloatMatrix,
                                    b: *const root::FloatMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type,
                                    rcon: *mut f32) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_lssolve4(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRi"]
        pub fn FloatMatrix_lssolve5(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRiS3_"]
        pub fn FloatMatrix_lssolve6(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRiS3_Rf"]
        pub fn FloatMatrix_lssolve7(this: *const root::FloatMatrix,
                                    b: *const root::FloatComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rank: *mut root::octave_idx_type,
                                    rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatMatrix_lssolve8(this: *const root::FloatMatrix,
                                    b: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRi"]
        pub fn FloatMatrix_lssolve9(this: *const root::FloatMatrix,
                                    b: *const root::FloatColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRiS3_"]
        pub fn FloatMatrix_lssolve10(this: *const root::FloatMatrix,
                                     b: *const root::FloatColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRiS3_Rf"]
        pub fn FloatMatrix_lssolve11(this: *const root::FloatMatrix,
                                     b: *const root::FloatColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type,
                                     rcon: *mut f32)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_lssolve12(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRi"]
        pub fn FloatMatrix_lssolve13(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRiS3_"]
        pub fn FloatMatrix_lssolve14(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRiS3_Rf"]
        pub fn FloatMatrix_lssolve15(this: *const root::FloatMatrix,
                                     b: *const root::FloatComplexColumnVector,
                                     info: *mut root::octave_idx_type,
                                     rank: *mut root::octave_idx_type,
                                     rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7cumprodEi"]
        pub fn FloatMatrix_cumprod(this: *const root::FloatMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix6cumsumEi"]
        pub fn FloatMatrix_cumsum(this: *const root::FloatMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4prodEi"]
        pub fn FloatMatrix_prod(this: *const root::FloatMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3sumEi"]
        pub fn FloatMatrix_sum(this: *const root::FloatMatrix,
                               dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix5sumsqEi"]
        pub fn FloatMatrix_sumsq(this: *const root::FloatMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix3absEv"]
        pub fn FloatMatrix_abs(this: *const root::FloatMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4diagEi"]
        pub fn FloatMatrix_diag(this: *const root::FloatMatrix,
                                k: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix4diagEii"]
        pub fn FloatMatrix_diag1(this: *const root::FloatMatrix,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_minEv"]
        pub fn FloatMatrix_row_min(this: *const root::FloatMatrix)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_maxEv"]
        pub fn FloatMatrix_row_max(this: *const root::FloatMatrix)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_minER5ArrayIiE"]
        pub fn FloatMatrix_row_min1(this: *const root::FloatMatrix,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix7row_maxER5ArrayIiE"]
        pub fn FloatMatrix_row_max1(this: *const root::FloatMatrix,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_minEv"]
        pub fn FloatMatrix_column_min(this: *const root::FloatMatrix)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_maxEv"]
        pub fn FloatMatrix_column_max(this: *const root::FloatMatrix)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_minER5ArrayIiE"]
        pub fn FloatMatrix_column_min1(this: *const root::FloatMatrix,
                                       index:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK11FloatMatrix10column_maxER5ArrayIiE"]
        pub fn FloatMatrix_column_max1(this: *const root::FloatMatrix,
                                       index:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK14FloatRowVector"]
        pub fn FloatMatrix_FloatMatrix(this: *mut root::FloatMatrix,
                                       rv: *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK17FloatColumnVector"]
        pub fn FloatMatrix_FloatMatrix1(this: *mut root::FloatMatrix,
                                        cv: *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatMatrix_FloatMatrix2(this: *mut root::FloatMatrix,
                                        a: *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix3(this: *mut root::FloatMatrix,
                                        a: *const root::MDiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix4(this: *mut root::FloatMatrix,
                                        a: *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10PermMatrix"]
        pub fn FloatMatrix_FloatMatrix5(this: *mut root::FloatMatrix,
                                        a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10boolMatrix"]
        pub fn FloatMatrix_FloatMatrix6(this: *mut root::FloatMatrix,
                                        a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN11FloatMatrixC1ERK10charMatrix"]
        pub fn FloatMatrix_FloatMatrix7(this: *mut root::FloatMatrix,
                                        a: *const root::charMatrix);
    }
    impl FloatMatrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            FloatMatrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::FloatDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatMatrix {
            FloatMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatMatrix {
            FloatMatrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector)
         -> root::FloatMatrix {
            FloatMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::FloatColumnVector)
         -> root::FloatMatrix {
            FloatMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix {
            FloatMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector)
         -> root::FloatMatrix {
            FloatMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector)
         -> root::FloatMatrix {
            FloatMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatMatrix {
            FloatMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatMatrix {
            FloatMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatMatrix {
            FloatMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::FloatMatrix {
            FloatMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatMatrix {
            FloatMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatMatrix {
            FloatMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::FloatDET {
            FloatMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET {
            FloatMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatDET {
            FloatMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatMatrix {
            FloatMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatMatrix {
            FloatMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                               singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                               singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatMatrix {
            FloatMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatMatrix {
            FloatMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatColumnVector {
            FloatMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix)
         -> root::FloatMatrix {
            FloatMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatMatrix {
            FloatMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::FloatColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32) -> root::FloatColumnVector {
            FloatMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self,
                                b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatMatrix {
            FloatMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatDiagMatrix {
            FloatMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatColumnVector {
            FloatMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatColumnVector {
            FloatMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector {
            FloatMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatColumnVector {
            FloatMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatRowVector {
            FloatMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatRowVector {
            FloatMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector {
            FloatMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatRowVector {
            FloatMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatMatrix_FloatMatrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexMatrix {
        pub _base: root::FloatComplexNDArray,
    }
    pub type FloatComplexMatrix_column_vector_type =
        root::FloatComplexColumnVector;
    pub type FloatComplexMatrix_row_vector_type = root::FloatComplexRowVector;
    pub type FloatComplexMatrix_real_column_vector_type =
        root::FloatColumnVector;
    pub type FloatComplexMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatComplexMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatComplexMatrix_complex_matrix_type =
        root::FloatComplexMatrix;
    pub type FloatComplexMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatComplexMatrix_complex_diag_matrix_type =
        root::FloatComplexDiagMatrix;
    pub type FloatComplexMatrix_real_elt_type = f32;
    pub type FloatComplexMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatComplexMatrix() {
        assert_eq!(::std::mem::size_of::<FloatComplexMatrix>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( FloatComplexMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<FloatComplexMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix12is_hermitianEv"]
        pub fn FloatComplexMatrix_is_hermitian(this:
                                                   *const root::FloatComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK11FloatMatrixii"]
        pub fn FloatComplexMatrix_insert(this: *mut root::FloatComplexMatrix,
                                         a: *const root::FloatMatrix,
                                         r: root::octave_idx_type,
                                         c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK14FloatRowVectorii"]
        pub fn FloatComplexMatrix_insert1(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatRowVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK17FloatColumnVectorii"]
        pub fn FloatComplexMatrix_insert2(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatColumnVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERK15FloatDiagMatrixii"]
        pub fn FloatComplexMatrix_insert3(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatDiagMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix6insertERKS_ii"]
        pub fn FloatComplexMatrix_insert4(this: *mut root::FloatComplexMatrix,
                                          a: *const root::FloatComplexMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK21FloatComplexRowVectorii"]
        pub fn FloatComplexMatrix_insert5(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexRowVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK24FloatComplexColumnVectorii"]
        pub fn FloatComplexMatrix_insert6(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexColumnVector,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrix6insertERK22FloatComplexDiagMatrixii"]
        pub fn FloatComplexMatrix_insert7(this: *mut root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexDiagMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillEf"]
        pub fn FloatComplexMatrix_fill(this: *mut root::FloatComplexMatrix,
                                       val: f32)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexMatrix_fill1(this: *mut root::FloatComplexMatrix,
                                        val: *const root::FloatComplex)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillEfiiii"]
        pub fn FloatComplexMatrix_fill2(this: *mut root::FloatComplexMatrix,
                                        val: f32, r1: root::octave_idx_type,
                                        c1: root::octave_idx_type,
                                        r2: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrix4fillERKSt7complexIfEiiii"]
        pub fn FloatComplexMatrix_fill3(this: *mut root::FloatComplexMatrix,
                                        val: *const root::FloatComplex,
                                        r1: root::octave_idx_type,
                                        c1: root::octave_idx_type,
                                        r2: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK11FloatMatrix"]
        pub fn FloatComplexMatrix_append(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK14FloatRowVector"]
        pub fn FloatComplexMatrix_append1(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_append2(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_append3(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6appendERKS_"]
        pub fn FloatComplexMatrix_append4(this:
                                              *const root::FloatComplexMatrix,
                                          a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_append5(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_append6(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix6appendERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_append7(this:
                                              *const root::FloatComplexMatrix,
                                          a:
                                              *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK11FloatMatrix"]
        pub fn FloatComplexMatrix_stack(this: *const root::FloatComplexMatrix,
                                        a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK14FloatRowVector"]
        pub fn FloatComplexMatrix_stack1(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_stack2(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_stack3(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5stackERKS_"]
        pub fn FloatComplexMatrix_stack4(this:
                                             *const root::FloatComplexMatrix,
                                         a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_stack5(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_stack6(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5stackERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_stack7(this:
                                             *const root::FloatComplexMatrix,
                                         a:
                                             *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7extractEiiii"]
        pub fn FloatComplexMatrix_extract(this:
                                              *const root::FloatComplexMatrix,
                                          r1: root::octave_idx_type,
                                          c1: root::octave_idx_type,
                                          r2: root::octave_idx_type,
                                          c2: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix9extract_nEiiii"]
        pub fn FloatComplexMatrix_extract_n(this:
                                                *const root::FloatComplexMatrix,
                                            r1: root::octave_idx_type,
                                            c1: root::octave_idx_type,
                                            nr: root::octave_idx_type,
                                            nc: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3rowEi"]
        pub fn FloatComplexMatrix_row(this: *const root::FloatComplexMatrix,
                                      i: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6columnEi"]
        pub fn FloatComplexMatrix_column(this:
                                             *const root::FloatComplexMatrix,
                                         i: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseEv"]
        pub fn FloatComplexMatrix_inverse(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseERi"]
        pub fn FloatComplexMatrix_inverse1(this:
                                               *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseERiRfbb"]
        pub fn FloatComplexMatrix_inverse2(this:
                                               *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcon: *mut f32, force: bool,
                                           calc_cond: bool)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixType"]
        pub fn FloatComplexMatrix_inverse3(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn FloatComplexMatrix_inverse4(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRiRfbb"]
        pub fn FloatComplexMatrix_inverse5(this:
                                               *const root::FloatComplexMatrix,
                                           mattype: *mut root::MatrixType,
                                           info: *mut root::octave_idx_type,
                                           rcon: *mut f32, force: bool,
                                           calc_cond: bool)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix14pseudo_inverseEf"]
        pub fn FloatComplexMatrix_pseudo_inverse(this:
                                                     *const root::FloatComplexMatrix,
                                                 tol: f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7fourierEv"]
        pub fn FloatComplexMatrix_fourier(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix8ifourierEv"]
        pub fn FloatComplexMatrix_ifourier(this:
                                               *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix9fourier2dEv"]
        pub fn FloatComplexMatrix_fourier2d(this:
                                                *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10ifourier2dEv"]
        pub fn FloatComplexMatrix_ifourier2d(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantEv"]
        pub fn FloatComplexMatrix_determinant(this:
                                                  *const root::FloatComplexMatrix)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantERi"]
        pub fn FloatComplexMatrix_determinant1(this:
                                                   *const root::FloatComplexMatrix,
                                               info:
                                                   *mut root::octave_idx_type)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix11determinantERiRfb"]
        pub fn FloatComplexMatrix_determinant2(this:
                                                   *const root::FloatComplexMatrix,
                                               info:
                                                   *mut root::octave_idx_type,
                                               rcon: *mut f32,
                                               calc_cond: bool)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix11determinantER10MatrixTypeRiRfb"]
        pub fn FloatComplexMatrix_determinant3(this:
                                                   *const root::FloatComplexMatrix,
                                               mattype: *mut root::MatrixType,
                                               info:
                                                   *mut root::octave_idx_type,
                                               rcon: *mut f32,
                                               calc_cond: bool)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5rcondEv"]
        pub fn FloatComplexMatrix_rcond(this: *const root::FloatComplexMatrix)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5rcondER10MatrixType"]
        pub fn FloatComplexMatrix_rcond1(this:
                                             *const root::FloatComplexMatrix,
                                         mattype: *mut root::MatrixType)
         -> f32;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve(this: *const root::FloatComplexMatrix,
                                        typ: *mut root::MatrixType,
                                        b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_solve1(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRiRf"]
        pub fn FloatComplexMatrix_solve2(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRiRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve3(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32,
                                         sing_handler:
                                             root::FloatComplexMatrix_solve_singularity_handler,
                                         singular_fallback: bool,
                                         transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatComplexMatrix_solve4(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn FloatComplexMatrix_solve5(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RiRf"]
        pub fn FloatComplexMatrix_solve6(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RiRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve7(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatComplexMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcon: *mut f32,
                                         sing_handler:
                                             root::FloatComplexMatrix_solve_singularity_handler,
                                         singular_fallback: bool,
                                         transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve8(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_solve9(this:
                                             *const root::FloatComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::FloatColumnVector,
                                         info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve10(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve11(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve12(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_solve13(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve14(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve15(this:
                                              *const root::FloatComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve16(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_solve17(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRiRf"]
        pub fn FloatComplexMatrix_solve18(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve19(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_"]
        pub fn FloatComplexMatrix_solve20(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_Ri"]
        pub fn FloatComplexMatrix_solve21(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERKS_RiRf"]
        pub fn FloatComplexMatrix_solve22(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERKS_RiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve23(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve24(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_solve25(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve26(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve27(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve28(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_solve29(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRiRf"]
        pub fn FloatComplexMatrix_solve30(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRiRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve31(this:
                                              *const root::FloatComplexMatrix,
                                          b:
                                              *const root::FloatComplexColumnVector,
                                          info: *mut root::octave_idx_type,
                                          rcon: *mut f32,
                                          sing_handler:
                                              root::FloatComplexMatrix_solve_singularity_handler,
                                          transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_lssolve(this:
                                              *const root::FloatComplexMatrix,
                                          b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRi"]
        pub fn FloatComplexMatrix_lssolve1(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRiS3_"]
        pub fn FloatComplexMatrix_lssolve2(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve3(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type,
                                           rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_"]
        pub fn FloatComplexMatrix_lssolve4(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_Ri"]
        pub fn FloatComplexMatrix_lssolve5(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_RiS2_"]
        pub fn FloatComplexMatrix_lssolve6(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7lssolveERKS_RiS2_Rf"]
        pub fn FloatComplexMatrix_lssolve7(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rank: *mut root::octave_idx_type,
                                           rcon: *mut f32)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_lssolve8(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRi"]
        pub fn FloatComplexMatrix_lssolve9(this:
                                               *const root::FloatComplexMatrix,
                                           b: *const root::FloatColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRiS3_"]
        pub fn FloatComplexMatrix_lssolve10(this:
                                                *const root::FloatComplexMatrix,
                                            b: *const root::FloatColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve11(this:
                                                *const root::FloatComplexMatrix,
                                            b: *const root::FloatColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type,
                                            rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_lssolve12(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRi"]
        pub fn FloatComplexMatrix_lssolve13(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRiS3_"]
        pub fn FloatComplexMatrix_lssolve14(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRiS3_Rf"]
        pub fn FloatComplexMatrix_lssolve15(this:
                                                *const root::FloatComplexMatrix,
                                            b:
                                                *const root::FloatComplexColumnVector,
                                            info: *mut root::octave_idx_type,
                                            rank: *mut root::octave_idx_type,
                                            rcon: *mut f32)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3allEi"]
        pub fn FloatComplexMatrix_all(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3anyEi"]
        pub fn FloatComplexMatrix_any(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7cumprodEi"]
        pub fn FloatComplexMatrix_cumprod(this:
                                              *const root::FloatComplexMatrix,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix6cumsumEi"]
        pub fn FloatComplexMatrix_cumsum(this:
                                             *const root::FloatComplexMatrix,
                                         dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4prodEi"]
        pub fn FloatComplexMatrix_prod(this: *const root::FloatComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3sumEi"]
        pub fn FloatComplexMatrix_sum(this: *const root::FloatComplexMatrix,
                                      dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix5sumsqEi"]
        pub fn FloatComplexMatrix_sumsq(this: *const root::FloatComplexMatrix,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix3absEv"]
        pub fn FloatComplexMatrix_abs(this: *const root::FloatComplexMatrix)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4diagEi"]
        pub fn FloatComplexMatrix_diag(this: *const root::FloatComplexMatrix,
                                       k: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix4diagEii"]
        pub fn FloatComplexMatrix_diag1(this: *const root::FloatComplexMatrix,
                                        m: root::octave_idx_type,
                                        n: root::octave_idx_type)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix16row_is_real_onlyEi"]
        pub fn FloatComplexMatrix_row_is_real_only(this:
                                                       *const root::FloatComplexMatrix,
                                                   arg1:
                                                       root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix19column_is_real_onlyEi"]
        pub fn FloatComplexMatrix_column_is_real_only(this:
                                                          *const root::FloatComplexMatrix,
                                                      arg1:
                                                          root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_minEv"]
        pub fn FloatComplexMatrix_row_min(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_maxEv"]
        pub fn FloatComplexMatrix_row_max(this:
                                              *const root::FloatComplexMatrix)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_minER5ArrayIiE"]
        pub fn FloatComplexMatrix_row_min1(this:
                                               *const root::FloatComplexMatrix,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix7row_maxER5ArrayIiE"]
        pub fn FloatComplexMatrix_row_max1(this:
                                               *const root::FloatComplexMatrix,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_minEv"]
        pub fn FloatComplexMatrix_column_min(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_maxEv"]
        pub fn FloatComplexMatrix_column_max(this:
                                                 *const root::FloatComplexMatrix)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_minER5ArrayIiE"]
        pub fn FloatComplexMatrix_column_min1(this:
                                                  *const root::FloatComplexMatrix,
                                              index:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK18FloatComplexMatrix10column_maxER5ArrayIiE"]
        pub fn FloatComplexMatrix_column_max1(this:
                                                  *const root::FloatComplexMatrix,
                                              index:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11FloatMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix(this:
                                                         *mut root::FloatComplexMatrix,
                                                     a:
                                                         *const root::FloatMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK14FloatRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix1(this:
                                                          *mut root::FloatComplexMatrix,
                                                      rv:
                                                          *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix2(this:
                                                          *mut root::FloatComplexMatrix,
                                                      cv:
                                                          *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix3(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix4(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::MDiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix5(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix6(this:
                                                          *mut root::FloatComplexMatrix,
                                                      rv:
                                                          *const root::FloatComplexRowVector);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix7(this:
                                                          *mut root::FloatComplexMatrix,
                                                      cv:
                                                          *const root::FloatComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix8(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::FloatComplexDiagMatrix);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK11MDiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix9(this:
                                                          *mut root::FloatComplexMatrix,
                                                      a:
                                                          *const root::MDiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name =
              "_ZN18FloatComplexMatrixC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix10(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::DiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10boolMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix11(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK10charMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix12(this:
                                                           *mut root::FloatComplexMatrix,
                                                       a:
                                                           *const root::charMatrix);
    }
    extern "C" {
        #[link_name = "_ZN18FloatComplexMatrixC1ERK11FloatMatrixS2_"]
        pub fn FloatComplexMatrix_FloatComplexMatrix13(this:
                                                           *mut root::FloatComplexMatrix,
                                                       re:
                                                           *const root::FloatMatrix,
                                                       im:
                                                           *const root::FloatMatrix);
    }
    impl FloatComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            FloatComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::FloatDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(&mut self, a: *const root::FloatComplexMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(&mut self,
                              a: *const root::FloatComplexRowVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(&mut self,
                              a: *const root::FloatComplexColumnVector,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(&mut self,
                              a: *const root::FloatComplexDiagMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            r1: root::octave_idx_type,
                            c1: root::octave_idx_type,
                            r2: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(&self, a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(&self, a: *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(&self, a: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(&self, a: *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                c1: root::octave_idx_type,
                                nr: root::octave_idx_type,
                                nc: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(&self, info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcon: *mut f32, force: bool, calc_cond: bool)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse5(self, mattype, info, rcon, force,
                                        calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(&self, mattype: *mut root::MatrixType,
                                   info: *mut root::octave_idx_type,
                                   rcon: *mut f32, calc_cond: bool)
         -> root::FloatComplexDET {
            FloatComplexMatrix_determinant3(self, mattype, info, rcon,
                                            calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatComplexMatrix_rcond(self) }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve2(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve3(self, typ, b, info, rcon, sing_handler,
                                      singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve6(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatComplexMatrix,
                             info: *mut root::octave_idx_type, rcon: *mut f32,
                             sing_handler:
                                 root::FloatComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool,
                             transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve7(self, typ, b, info, rcon, sing_handler,
                                      singular_fallback, transt)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::FloatColumnVector,
                             info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve10(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve11(self, typ, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve14(self, typ, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve15(self, typ, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(&self, b: *const root::FloatMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve19(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(&self, b: *const root::FloatComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve23(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::FloatColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve27(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::FloatComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcon: *mut f32,
                              sing_handler:
                                  root::FloatComplexMatrix_solve_singularity_handler,
                              transt: root::blas_trans_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve31(self, b, info, rcon, sing_handler,
                                       transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(&self, b: *const root::FloatMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::FloatComplexMatrix)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(&self, b: *const root::FloatComplexMatrix,
                               info: *mut root::octave_idx_type,
                               rank: *mut root::octave_idx_type,
                               rcon: *mut f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(&self, b: *const root::FloatColumnVector,
                               info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(&self, b: *const root::FloatColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(&self,
                                b: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(&self,
                                b: *const root::FloatComplexColumnVector,
                                info: *mut root::octave_idx_type,
                                rank: *mut root::octave_idx_type,
                                rcon: *mut f32)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            FloatComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolMatrix {
            FloatComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatComplexDiagMatrix {
            FloatComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            FloatComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type)
         -> bool {
            FloatComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(&self,
                               index: *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(&self,
                                  index:
                                      *mut root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix1(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix2(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(rv: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix6(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(cv: *const root::FloatComplexColumnVector)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix7(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(a: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix8(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a:
                               *const root::MDiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a:
                                *const root::DiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(re: *const root::FloatMatrix,
                            im: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix13(&mut __bindgen_tmp, re,
                                                    im);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseMatrix {
        pub _base: root::MSparse<f64>,
    }
    pub type SparseMatrix_dense_matrix_type = root::Matrix;
    pub type SparseMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseMatrix() {
        assert_eq!(::std::mem::size_of::<SparseMatrix>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( SparseMatrix ) ));
        assert_eq! (::std::mem::align_of::<SparseMatrix>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( SparseMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12is_symmetricEv"]
        pub fn SparseMatrix_is_symmetric(this: *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3maxEi"]
        pub fn SparseMatrix_max(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3maxER5ArrayIiEi"]
        pub fn SparseMatrix_max1(this: *const root::SparseMatrix,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3minEi"]
        pub fn SparseMatrix_min(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3minER5ArrayIiEi"]
        pub fn SparseMatrix_min1(this: *const root::SparseMatrix,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6insertERKS_ii"]
        pub fn SparseMatrix_insert(this: *mut root::SparseMatrix,
                                   a: *const root::SparseMatrix,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseMatrix_insert1(this: *mut root::SparseMatrix,
                                    a: *const root::SparseMatrix,
                                    indx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseMatrix_concat(this: *mut root::SparseMatrix,
                                   rb: *const root::SparseMatrix,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN12SparseMatrix6concatERK19SparseComplexMatrixRK5ArrayIiE"]
        pub fn SparseMatrix_concat1(this: *mut root::SparseMatrix,
                                    rb: *const root::SparseComplexMatrix,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3rowEi"]
        pub fn SparseMatrix_row(this: *const root::SparseMatrix,
                                i: root::octave_idx_type) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix6columnEi"]
        pub fn SparseMatrix_column(this: *const root::SparseMatrix,
                                   i: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseEv"]
        pub fn SparseMatrix_inverse(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixType"]
        pub fn SparseMatrix_inverse1(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixTypeRi"]
        pub fn SparseMatrix_inverse2(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType,
                                     info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn SparseMatrix_inverse3(this: *const root::SparseMatrix,
                                     mattype: *mut root::MatrixType,
                                     info: *mut root::octave_idx_type,
                                     rcond: *mut f64, force: bool,
                                     calc_cond: bool) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantEv"]
        pub fn SparseMatrix_determinant(this: *const root::SparseMatrix)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantERi"]
        pub fn SparseMatrix_determinant1(this: *const root::SparseMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix11determinantERiRdb"]
        pub fn SparseMatrix_determinant2(this: *const root::SparseMatrix,
                                         info: *mut root::octave_idx_type,
                                         rcond: *mut f64, calc_cond: bool)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseMatrix_solve(this: *const root::SparseMatrix,
                                  typ: *mut root::MatrixType,
                                  b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn SparseMatrix_solve1(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn SparseMatrix_solve2(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve3(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::Matrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64,
                                   sing_handler:
                                       root::SparseMatrix_solve_singularity_handler,
                                   singular_fallback: bool) -> root::Matrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseMatrix_solve4(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn SparseMatrix_solve5(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn SparseMatrix_solve6(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve7(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::ComplexMatrix,
                                   info: *mut root::octave_idx_type,
                                   rcond: *mut f64,
                                   sing_handler:
                                       root::SparseMatrix_solve_singularity_handler,
                                   singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseMatrix_solve8(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn SparseMatrix_solve9(this: *const root::SparseMatrix,
                                   typ: *mut root::MatrixType,
                                   b: *const root::SparseMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn SparseMatrix_solve10(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb"]
        pub fn SparseMatrix_solve11(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler,
                                    singular_fallback: bool)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve12(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRi"]
        pub fn SparseMatrix_solve13(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRiRd"]
        pub fn SparseMatrix_solve14(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRiRdPFvdEb"]
        pub fn SparseMatrix_solve15(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler,
                                    singular_fallabck: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseMatrix_solve16(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn SparseMatrix_solve17(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn SparseMatrix_solve18(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve19(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseMatrix_solve20(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn SparseMatrix_solve21(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn SparseMatrix_solve22(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve23(this: *const root::SparseMatrix,
                                    typ: *mut root::MatrixType,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6Matrix"]
        pub fn SparseMatrix_solve24(this: *const root::SparseMatrix,
                                    b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRi"]
        pub fn SparseMatrix_solve25(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRiRd"]
        pub fn SparseMatrix_solve26(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK6MatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve27(this: *const root::SparseMatrix,
                                    b: *const root::Matrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrix"]
        pub fn SparseMatrix_solve28(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRi"]
        pub fn SparseMatrix_solve29(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRiRd"]
        pub fn SparseMatrix_solve30(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK13ComplexMatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve31(this: *const root::SparseMatrix,
                                    b: *const root::ComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_"]
        pub fn SparseMatrix_solve32(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_Ri"]
        pub fn SparseMatrix_solve33(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_RiRd"]
        pub fn SparseMatrix_solve34(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERKS_RiRdPFvdE"]
        pub fn SparseMatrix_solve35(this: *const root::SparseMatrix,
                                    b: *const root::SparseMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve36(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRi"]
        pub fn SparseMatrix_solve37(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRiRd"]
        pub fn SparseMatrix_solve38(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRiRdPFvdE"]
        pub fn SparseMatrix_solve39(this: *const root::SparseMatrix,
                                    b: *const root::SparseComplexMatrix,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVector"]
        pub fn SparseMatrix_solve40(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRi"]
        pub fn SparseMatrix_solve41(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRiRd"]
        pub fn SparseMatrix_solve42(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK12ColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve43(this: *const root::SparseMatrix,
                                    b: *const root::ColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseMatrix_solve44(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn SparseMatrix_solve45(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn SparseMatrix_solve46(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseMatrix_solve47(this: *const root::SparseMatrix,
                                    b: *const root::ComplexColumnVector,
                                    info: *mut root::octave_idx_type,
                                    rcond: *mut f64,
                                    sing_handler:
                                        root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix23any_element_is_negativeEb"]
        pub fn SparseMatrix_any_element_is_negative(this:
                                                        *const root::SparseMatrix,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix18any_element_is_nanEv"]
        pub fn SparseMatrix_any_element_is_nan(this:
                                                   *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseMatrix_any_element_is_inf_or_nan(this:
                                                          *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix27any_element_not_one_or_zeroEv"]
        pub fn SparseMatrix_any_element_not_one_or_zero(this:
                                                            *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix21all_elements_are_zeroEv"]
        pub fn SparseMatrix_all_elements_are_zero(this:
                                                      *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK12SparseMatrix34all_elements_are_int_or_inf_or_nanEv"]
        pub fn SparseMatrix_all_elements_are_int_or_inf_or_nan(this:
                                                                   *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12all_integersERdS0_"]
        pub fn SparseMatrix_all_integers(this: *const root::SparseMatrix,
                                         max_val: *mut f64, min_val: *mut f64)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix19too_large_for_floatEv"]
        pub fn SparseMatrix_too_large_for_float(this:
                                                    *const root::SparseMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3allEi"]
        pub fn SparseMatrix_all(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3anyEi"]
        pub fn SparseMatrix_any(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7cumprodEi"]
        pub fn SparseMatrix_cumprod(this: *const root::SparseMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix6cumsumEi"]
        pub fn SparseMatrix_cumsum(this: *const root::SparseMatrix,
                                   dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix4prodEi"]
        pub fn SparseMatrix_prod(this: *const root::SparseMatrix,
                                 dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3sumEi"]
        pub fn SparseMatrix_sum(this: *const root::SparseMatrix,
                                dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix5sumsqEi"]
        pub fn SparseMatrix_sumsq(this: *const root::SparseMatrix,
                                  dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix3absEv"]
        pub fn SparseMatrix_abs(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix4diagEi"]
        pub fn SparseMatrix_diag(this: *const root::SparseMatrix,
                                 k: root::octave_idx_type)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix12matrix_valueEv"]
        pub fn SparseMatrix_matrix_value(this: *const root::SparseMatrix)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7squeezeEv"]
        pub fn SparseMatrix_squeeze(this: *const root::SparseMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7reshapeERK10dim_vector"]
        pub fn SparseMatrix_reshape(this: *const root::SparseMatrix,
                                    new_dims: *const root::dim_vector)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseMatrix_permute(this: *const root::SparseMatrix,
                                    vec:
                                        *const root::Array<::std::os::raw::c_int>,
                                    inv: bool) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12SparseMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseMatrix_ipermute(this: *const root::SparseMatrix,
                                     vec:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseMatrix_SparseMatrix(this: *mut root::SparseMatrix,
                                         a: *const root::SparseBoolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12SparseMatrixC1ERK10DiagMatrix"]
        pub fn SparseMatrix_SparseMatrix1(this: *mut root::SparseMatrix,
                                          a: *const root::DiagMatrix);
    }
    impl SparseMatrix {
        #[inline]
        pub unsafe fn is_symmetric(&self) -> bool {
            SparseMatrix_is_symmetric(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseMatrix {
            SparseMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseMatrix {
            SparseMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix {
            SparseMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::SparseComplexMatrix,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            SparseMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseMatrix {
            SparseMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType)
         -> root::SparseMatrix {
            SparseMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcond: *mut f64, force: bool, calc_cond: bool)
         -> root::SparseMatrix {
            SparseMatrix_inverse3(self, mattype, info, rcond, force,
                                  calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            SparseMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::DET {
            SparseMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcond: *mut f64, calc_cond: bool)
         -> root::DET {
            SparseMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::Matrix {
            SparseMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::Matrix {
            SparseMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::Matrix {
            SparseMatrix_solve2(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::Matrix {
            SparseMatrix_solve3(self, typ, b, info, rcond, sing_handler,
                                singular_fallback)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseMatrix_solve6(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseMatrix_solve7(self, typ, b, info, rcond, sing_handler,
                                singular_fallback)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix)
         -> root::SparseMatrix {
            SparseMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix,
                             info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseMatrix {
            SparseMatrix_solve10(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler,
                              singular_fallback: bool) -> root::SparseMatrix {
            SparseMatrix_solve11(self, typ, b, info, rcond, sing_handler,
                                 singular_fallback)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseMatrix_solve14(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler,
                              singular_fallabck: bool)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve15(self, typ, b, info, rcond, sing_handler,
                                 singular_fallabck)
        }
        #[inline]
        pub unsafe fn solve16(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector)
         -> root::ColumnVector {
            SparseMatrix_solve16(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_solve17(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ColumnVector {
            SparseMatrix_solve18(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector {
            SparseMatrix_solve19(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseMatrix_solve20(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseMatrix_solve21(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseMatrix_solve22(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseMatrix_solve23(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix) -> root::Matrix {
            SparseMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::Matrix {
            SparseMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::Matrix {
            SparseMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::Matrix {
            SparseMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix)
         -> root::SparseMatrix {
            SparseMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseMatrix {
            SparseMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::SparseMatrix {
            SparseMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(&self, b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector)
         -> root::ColumnVector {
            SparseMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ColumnVector {
            SparseMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ColumnVector {
            SparseMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ColumnVector {
            SparseMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            SparseMatrix_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            SparseMatrix_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            SparseMatrix_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            SparseMatrix_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            SparseMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseMatrix {
            SparseMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            SparseMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseMatrix {
            SparseMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseMatrix {
            SparseMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseMatrix {
            SparseMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseMatrix {
            SparseMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseMatrix_SparseMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseMatrix_SparseMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseComplexMatrix {
        pub _base: root::MSparse<root::std::complex<f64>>,
    }
    pub type SparseComplexMatrix_dense_matrix_type = root::ComplexMatrix;
    pub type SparseComplexMatrix_solve_singularity_handler =
        ::std::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseComplexMatrix() {
        assert_eq!(::std::mem::size_of::<SparseComplexMatrix>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( SparseComplexMatrix ) ));
        assert_eq! (::std::mem::align_of::<SparseComplexMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( SparseComplexMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12is_hermitianEv"]
        pub fn SparseComplexMatrix_is_hermitian(this:
                                                    *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3maxEi"]
        pub fn SparseComplexMatrix_max(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3maxER5ArrayIiEi"]
        pub fn SparseComplexMatrix_max1(this:
                                            *const root::SparseComplexMatrix,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3minEi"]
        pub fn SparseComplexMatrix_min(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3minER5ArrayIiEi"]
        pub fn SparseComplexMatrix_min1(this:
                                            *const root::SparseComplexMatrix,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERKS_ii"]
        pub fn SparseComplexMatrix_insert(this:
                                              *mut root::SparseComplexMatrix,
                                          a: *const root::SparseComplexMatrix,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERK12SparseMatrixii"]
        pub fn SparseComplexMatrix_insert1(this:
                                               *mut root::SparseComplexMatrix,
                                           a: *const root::SparseMatrix,
                                           r: root::octave_idx_type,
                                           c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseComplexMatrix_insert2(this:
                                               *mut root::SparseComplexMatrix,
                                           a:
                                               *const root::SparseComplexMatrix,
                                           indx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN19SparseComplexMatrix6insertERK12SparseMatrixRK5ArrayIiE"]
        pub fn SparseComplexMatrix_insert3(this:
                                               *mut root::SparseComplexMatrix,
                                           a: *const root::SparseMatrix,
                                           indx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseComplexMatrix_concat(this:
                                              *mut root::SparseComplexMatrix,
                                          rb:
                                              *const root::SparseComplexMatrix,
                                          ra_idx:
                                              *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN19SparseComplexMatrix6concatERK12SparseMatrixRK5ArrayIiE"]
        pub fn SparseComplexMatrix_concat1(this:
                                               *mut root::SparseComplexMatrix,
                                           rb: *const root::SparseMatrix,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12matrix_valueEv"]
        pub fn SparseComplexMatrix_matrix_value(this:
                                                    *const root::SparseComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix9hermitianEv"]
        pub fn SparseComplexMatrix_hermitian(this:
                                                 *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3rowEi"]
        pub fn SparseComplexMatrix_row(this: *const root::SparseComplexMatrix,
                                       i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix6columnEi"]
        pub fn SparseComplexMatrix_column(this:
                                              *const root::SparseComplexMatrix,
                                          i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseEv"]
        pub fn SparseComplexMatrix_inverse(this:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixType"]
        pub fn SparseComplexMatrix_inverse1(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRi"]
        pub fn SparseComplexMatrix_inverse2(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType,
                                            info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRiRdbb"]
        pub fn SparseComplexMatrix_inverse3(this:
                                                *const root::SparseComplexMatrix,
                                            mattype: *mut root::MatrixType,
                                            info: *mut root::octave_idx_type,
                                            rcond: *mut f64, force: bool,
                                            calc_cond: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantEv"]
        pub fn SparseComplexMatrix_determinant(this:
                                                   *const root::SparseComplexMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantERi"]
        pub fn SparseComplexMatrix_determinant1(this:
                                                    *const root::SparseComplexMatrix,
                                                info:
                                                    *mut root::octave_idx_type)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix11determinantERiRdb"]
        pub fn SparseComplexMatrix_determinant2(this:
                                                    *const root::SparseComplexMatrix,
                                                info:
                                                    *mut root::octave_idx_type,
                                                rcond: *mut f64,
                                                calc_cond: bool)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseComplexMatrix_solve(this:
                                             *const root::SparseComplexMatrix,
                                         typ: *mut root::MatrixType,
                                         b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRi"]
        pub fn SparseComplexMatrix_solve1(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRiRd"]
        pub fn SparseComplexMatrix_solve2(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve3(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::Matrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64,
                                          sing_handler:
                                              root::SparseComplexMatrix_solve_singularity_handler,
                                          singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve4(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRi"]
        pub fn SparseComplexMatrix_solve5(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRd"]
        pub fn SparseComplexMatrix_solve6(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve7(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::ComplexMatrix,
                                          info: *mut root::octave_idx_type,
                                          rcond: *mut f64,
                                          sing_handler:
                                              root::SparseComplexMatrix_solve_singularity_handler,
                                          singular_fallback: bool)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve8(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRi"]
        pub fn SparseComplexMatrix_solve9(this:
                                              *const root::SparseComplexMatrix,
                                          typ: *mut root::MatrixType,
                                          b: *const root::SparseMatrix,
                                          info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRiRd"]
        pub fn SparseComplexMatrix_solve10(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve11(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler,
                                           singular_fallback: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseComplexMatrix_solve12(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_Ri"]
        pub fn SparseComplexMatrix_solve13(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RiRd"]
        pub fn SparseComplexMatrix_solve14(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RiRdPFvdEb"]
        pub fn SparseComplexMatrix_solve15(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler,
                                           singular_fallback: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseComplexMatrix_solve16(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRi"]
        pub fn SparseComplexMatrix_solve17(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve18(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve19(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve20(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRi"]
        pub fn SparseComplexMatrix_solve21(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve22(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve23(this:
                                               *const root::SparseComplexMatrix,
                                           typ: *mut root::MatrixType,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6Matrix"]
        pub fn SparseComplexMatrix_solve24(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRi"]
        pub fn SparseComplexMatrix_solve25(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRiRd"]
        pub fn SparseComplexMatrix_solve26(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK6MatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve27(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::Matrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve28(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRi"]
        pub fn SparseComplexMatrix_solve29(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRiRd"]
        pub fn SparseComplexMatrix_solve30(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve31(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve32(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRi"]
        pub fn SparseComplexMatrix_solve33(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRiRd"]
        pub fn SparseComplexMatrix_solve34(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve35(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::SparseMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_"]
        pub fn SparseComplexMatrix_solve36(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_Ri"]
        pub fn SparseComplexMatrix_solve37(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_RiRd"]
        pub fn SparseComplexMatrix_solve38(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERKS_RiRdPFvdE"]
        pub fn SparseComplexMatrix_solve39(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::SparseComplexMatrix,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVector"]
        pub fn SparseComplexMatrix_solve40(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRi"]
        pub fn SparseComplexMatrix_solve41(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve42(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve43(this:
                                               *const root::SparseComplexMatrix,
                                           b: *const root::ColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve44(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRi"]
        pub fn SparseComplexMatrix_solve45(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRiRd"]
        pub fn SparseComplexMatrix_solve46(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRiRdPFvdE"]
        pub fn SparseComplexMatrix_solve47(this:
                                               *const root::SparseComplexMatrix,
                                           b:
                                               *const root::ComplexColumnVector,
                                           info: *mut root::octave_idx_type,
                                           rcond: *mut f64,
                                           sing_handler:
                                               root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7squeezeEv"]
        pub fn SparseComplexMatrix_squeeze(this:
                                               *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7reshapeERK10dim_vector"]
        pub fn SparseComplexMatrix_reshape(this:
                                               *const root::SparseComplexMatrix,
                                           new_dims: *const root::dim_vector)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseComplexMatrix_permute(this:
                                               *const root::SparseComplexMatrix,
                                           vec:
                                               *const root::Array<::std::os::raw::c_int>,
                                           inv: bool)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseComplexMatrix_ipermute(this:
                                                *const root::SparseComplexMatrix,
                                            vec:
                                                *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix18any_element_is_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_nan(this:
                                                          *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK19SparseComplexMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_inf_or_nan(this:
                                                                 *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix21all_elements_are_realEv"]
        pub fn SparseComplexMatrix_all_elements_are_real(this:
                                                             *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix12all_integersERdS0_"]
        pub fn SparseComplexMatrix_all_integers(this:
                                                    *const root::SparseComplexMatrix,
                                                max_val: *mut f64,
                                                min_val: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix19too_large_for_floatEv"]
        pub fn SparseComplexMatrix_too_large_for_float(this:
                                                           *const root::SparseComplexMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3allEi"]
        pub fn SparseComplexMatrix_all(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3anyEi"]
        pub fn SparseComplexMatrix_any(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix7cumprodEi"]
        pub fn SparseComplexMatrix_cumprod(this:
                                               *const root::SparseComplexMatrix,
                                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix6cumsumEi"]
        pub fn SparseComplexMatrix_cumsum(this:
                                              *const root::SparseComplexMatrix,
                                          dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix4prodEi"]
        pub fn SparseComplexMatrix_prod(this:
                                            *const root::SparseComplexMatrix,
                                        dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3sumEi"]
        pub fn SparseComplexMatrix_sum(this: *const root::SparseComplexMatrix,
                                       dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix5sumsqEi"]
        pub fn SparseComplexMatrix_sumsq(this:
                                             *const root::SparseComplexMatrix,
                                         dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix3absEv"]
        pub fn SparseComplexMatrix_abs(this: *const root::SparseComplexMatrix)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK19SparseComplexMatrix4diagEi"]
        pub fn SparseComplexMatrix_diag(this:
                                            *const root::SparseComplexMatrix,
                                        k: root::octave_idx_type)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK12SparseMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix(this:
                                                           *mut root::SparseComplexMatrix,
                                                       a:
                                                           *const root::SparseMatrix);
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix1(this:
                                                            *mut root::SparseComplexMatrix,
                                                        a:
                                                            *const root::SparseBoolMatrix);
    }
    extern "C" {
        #[link_name = "_ZN19SparseComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix2(this:
                                                            *mut root::SparseComplexMatrix,
                                                        a:
                                                            *const root::ComplexDiagMatrix);
    }
    impl SparseComplexMatrix {
        #[inline]
        pub unsafe fn is_hermitian(&self) -> bool {
            SparseComplexMatrix_is_hermitian(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseComplexMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::SparseComplexMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert2(self, a, indx)
        }
        #[inline]
        pub unsafe fn insert3(&mut self, a: *const root::SparseMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert3(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseComplexMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::SparseMatrix,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::ComplexMatrix {
            SparseComplexMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_hermitian(self)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            SparseComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType,
                               info: *mut root::octave_idx_type,
                               rcond: *mut f64, force: bool, calc_cond: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse3(self, mattype, info, rcond, force,
                                         calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            SparseComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDET {
            SparseComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(&self, info: *mut root::octave_idx_type,
                                   rcond: *mut f64, calc_cond: bool)
         -> root::ComplexDET {
            SparseComplexMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(&self, typ: *mut root::MatrixType,
                            b: *const root::Matrix) -> root::ComplexMatrix {
            SparseComplexMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve2(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(&self, typ: *mut root::MatrixType,
                             b: *const root::Matrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseComplexMatrix_solve3(self, typ, b, info, rcond,
                                       sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve4(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve6(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(&self, typ: *mut root::MatrixType,
                             b: *const root::ComplexMatrix,
                             info: *mut root::octave_idx_type,
                             rcond: *mut f64,
                             sing_handler:
                                 root::SparseComplexMatrix_solve_singularity_handler,
                             singular_fallback: bool) -> root::ComplexMatrix {
            SparseComplexMatrix_solve7(self, typ, b, info, rcond,
                                       sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve8(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(&self, typ: *mut root::MatrixType,
                             b: *const root::SparseMatrix,
                             info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve10(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler,
                              singular_fallback: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve11(self, typ, b, info, rcond,
                                        sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve12(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve14(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(&self, typ: *mut root::MatrixType,
                              b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler,
                              singular_fallback: bool)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve15(self, typ, b, info, rcond,
                                        sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve16(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve16(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve17(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve17(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve18(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve18(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(&self, typ: *mut root::MatrixType,
                              b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve19(self, typ, b, info, rcond,
                                        sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve20(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve21(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve21(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve22(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve22(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(&self, typ: *mut root::MatrixType,
                              b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve23(self, typ, b, info, rcond,
                                        sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(&self, b: *const root::Matrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexMatrix {
            SparseComplexMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(&self, b: *const root::ComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexMatrix {
            SparseComplexMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(&self, b: *const root::SparseMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(&self, b: *const root::SparseComplexMatrix)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(&self, b: *const root::SparseComplexMatrix,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(&self, b: *const root::ColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(&self, b: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(&self, b: *const root::ComplexColumnVector,
                              info: *mut root::octave_idx_type,
                              rcond: *mut f64,
                              sing_handler:
                                  root::SparseComplexMatrix_solve_singularity_handler)
         -> root::ComplexColumnVector {
            SparseComplexMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseComplexMatrix {
            SparseComplexMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            SparseComplexMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            SparseComplexMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseComplexMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseComplexMatrix {
            SparseComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MatrixType {
        pub typ: root::MatrixType_matrix_type,
        pub sp_bandden: f64,
        pub bandden: f64,
        pub upper_band: root::octave_idx_type,
        pub lower_band: root::octave_idx_type,
        pub dense: bool,
        pub full: bool,
        pub nperm: root::octave_idx_type,
        pub perm: *mut root::octave_idx_type,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum MatrixType_matrix_type {
        Unknown = 0,
        Full = 1,
        Diagonal = 2,
        Permuted_Diagonal = 3,
        Upper = 4,
        Lower = 5,
        Permuted_Upper = 6,
        Permuted_Lower = 7,
        Banded = 8,
        Hermitian = 9,
        Banded_Hermitian = 10,
        Tridiagonal = 11,
        Tridiagonal_Hermitian = 12,
        Rectangular = 13,
    }
    #[test]
    fn bindgen_test_layout_MatrixType() {
        assert_eq!(::std::mem::size_of::<MatrixType>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( MatrixType ) ));
        assert_eq! (::std::mem::align_of::<MatrixType>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( MatrixType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . typ as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( typ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . sp_bandden as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( sp_bandden ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . bandden as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( bandden ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . upper_band as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( upper_band ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . lower_band as *
                    const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( lower_band ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . dense as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( dense ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . full as * const _ as
                    usize } , 33usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( full ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . nperm as * const _
                    as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( nperm ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const MatrixType ) ) . perm as * const _ as
                    usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( MatrixType ) , "::"
                    , stringify ! ( perm ) ));
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeEb"]
        pub fn MatrixType_type(this: *mut root::MatrixType, quiet: bool)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK6Matrix"]
        pub fn MatrixType_type1(this: *mut root::MatrixType,
                                a: *const root::Matrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK13ComplexMatrix"]
        pub fn MatrixType_type2(this: *mut root::MatrixType,
                                a: *const root::ComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK11FloatMatrix"]
        pub fn MatrixType_type3(this: *mut root::MatrixType,
                                a: *const root::FloatMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK18FloatComplexMatrix"]
        pub fn MatrixType_type4(this: *mut root::MatrixType,
                                a: *const root::FloatComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK12SparseMatrix"]
        pub fn MatrixType_type5(this: *mut root::MatrixType,
                                a: *const root::SparseMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType4typeERK19SparseComplexMatrix"]
        pub fn MatrixType_type6(this: *mut root::MatrixType,
                                a: *const root::SparseComplexMatrix)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK10MatrixType4infoEv"]
        pub fn MatrixType_info(this: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType17mark_as_symmetricEv"]
        pub fn MatrixType_mark_as_symmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType19mark_as_unsymmetricEv"]
        pub fn MatrixType_mark_as_unsymmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType16mark_as_permutedEiPKi"]
        pub fn MatrixType_mark_as_permuted(this: *mut root::MatrixType,
                                           np: root::octave_idx_type,
                                           p: *const root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixType18mark_as_unpermutedEv"]
        pub fn MatrixType_mark_as_unpermuted(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZNK10MatrixType9transposeEv"]
        pub fn MatrixType_transpose(this: *const root::MatrixType)
         -> root::MatrixType;
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1Ev"]
        pub fn MatrixType_MatrixType(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERKS_"]
        pub fn MatrixType_MatrixType1(this: *mut root::MatrixType,
                                      a: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK6Matrix"]
        pub fn MatrixType_MatrixType2(this: *mut root::MatrixType,
                                      a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK13ComplexMatrix"]
        pub fn MatrixType_MatrixType3(this: *mut root::MatrixType,
                                      a: *const root::ComplexMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK11FloatMatrix"]
        pub fn MatrixType_MatrixType4(this: *mut root::MatrixType,
                                      a: *const root::FloatMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ERK18FloatComplexMatrix"]
        pub fn MatrixType_MatrixType5(this: *mut root::MatrixType,
                                      a: *const root::FloatComplexMatrix);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEb"]
        pub fn MatrixType_MatrixType6(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEiPKib"]
        pub fn MatrixType_MatrixType7(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      np: root::octave_idx_type,
                                      p: *const root::octave_idx_type,
                                      _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeC1ENS_11matrix_typeEiib"]
        pub fn MatrixType_MatrixType8(this: *mut root::MatrixType,
                                      t: root::MatrixType_matrix_type,
                                      ku: root::octave_idx_type,
                                      kl: root::octave_idx_type, _full: bool);
    }
    extern "C" {
        #[link_name = "_ZN10MatrixTypeD1Ev"]
        pub fn MatrixType_MatrixType_destructor(this: *mut root::MatrixType);
    }
    impl MatrixType {
        #[inline]
        pub unsafe fn type_(&mut self, quiet: bool) -> ::std::os::raw::c_int {
            MatrixType_type(self, quiet)
        }
        #[inline]
        pub unsafe fn type1(&mut self, a: *const root::Matrix)
         -> ::std::os::raw::c_int {
            MatrixType_type1(self, a)
        }
        #[inline]
        pub unsafe fn type2(&mut self, a: *const root::ComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type2(self, a)
        }
        #[inline]
        pub unsafe fn type3(&mut self, a: *const root::FloatMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type3(self, a)
        }
        #[inline]
        pub unsafe fn type4(&mut self, a: *const root::FloatComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type4(self, a)
        }
        #[inline]
        pub unsafe fn type5(&mut self, a: *const root::SparseMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type5(self, a)
        }
        #[inline]
        pub unsafe fn type6(&mut self, a: *const root::SparseComplexMatrix)
         -> ::std::os::raw::c_int {
            MatrixType_type6(self, a)
        }
        #[inline]
        pub unsafe fn info(&self) { MatrixType_info(self) }
        #[inline]
        pub unsafe fn mark_as_symmetric(&mut self) {
            MatrixType_mark_as_symmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_unsymmetric(&mut self) {
            MatrixType_mark_as_unsymmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_permuted(&mut self, np: root::octave_idx_type,
                                       p: *const root::octave_idx_type) {
            MatrixType_mark_as_permuted(self, np, p)
        }
        #[inline]
        pub unsafe fn mark_as_unpermuted(&mut self) {
            MatrixType_mark_as_unpermuted(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::MatrixType {
            MatrixType_transpose(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::ComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::FloatComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(t: root::MatrixType_matrix_type, _full: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType6(&mut __bindgen_tmp, t, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(t: root::MatrixType_matrix_type,
                           np: root::octave_idx_type,
                           p: *const root::octave_idx_type, _full: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType7(&mut __bindgen_tmp, t, np, p, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(t: root::MatrixType_matrix_type,
                           ku: root::octave_idx_type,
                           kl: root::octave_idx_type, _full: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            MatrixType_MatrixType8(&mut __bindgen_tmp, t, ku, kl, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            MatrixType_MatrixType_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolMatrix {
        pub _base: root::boolNDArray,
    }
    #[test]
    fn bindgen_test_layout_boolMatrix() {
        assert_eq!(::std::mem::size_of::<boolMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( boolMatrix ) ));
        assert_eq! (::std::mem::align_of::<boolMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( boolMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10boolMatrix6insertERKS_ii"]
        pub fn boolMatrix_insert(this: *mut root::boolMatrix,
                                 a: *const root::boolMatrix,
                                 r: root::octave_idx_type,
                                 c: root::octave_idx_type)
         -> *mut root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10boolMatrix4diagEi"]
        pub fn boolMatrix_diag(this: *const root::boolMatrix,
                               k: root::octave_idx_type) -> root::boolMatrix;
    }
    impl boolMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::boolMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::boolMatrix {
            boolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::boolMatrix {
            boolMatrix_diag(self, k)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charMatrix {
        pub _base: root::charNDArray,
    }
    #[test]
    fn bindgen_test_layout_charMatrix() {
        assert_eq!(::std::mem::size_of::<charMatrix>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( charMatrix ) ));
        assert_eq! (::std::mem::align_of::<charMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( charMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10charMatrix6insertEPKcii"]
        pub fn charMatrix_insert(this: *mut root::charMatrix,
                                 s: *const ::std::os::raw::c_char,
                                 r: root::octave_idx_type,
                                 c: root::octave_idx_type)
         -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10charMatrix6insertERKS_ii"]
        pub fn charMatrix_insert1(this: *mut root::charMatrix,
                                  a: *const root::charMatrix,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10charMatrix13row_as_stringEib"]
        pub fn charMatrix_row_as_string(this: *const root::charMatrix,
                                        arg1: root::octave_idx_type,
                                        strip_ws: bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK10charMatrix7extractEiiii"]
        pub fn charMatrix_extract(this: *const root::charMatrix,
                                  r1: root::octave_idx_type,
                                  c1: root::octave_idx_type,
                                  r2: root::octave_idx_type,
                                  c2: root::octave_idx_type)
         -> root::charMatrix;
    }
    impl charMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, s: *const ::std::os::raw::c_char,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::charMatrix {
            charMatrix_insert(self, s, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::charMatrix,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::charMatrix {
            charMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn row_as_string(&self, arg1: root::octave_idx_type,
                                    strip_ws: bool) -> root::std::string {
            charMatrix_row_as_string(self, arg1, strip_ws)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::charMatrix {
            charMatrix_extract(self, r1, c1, r2, c2)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct NDArray {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_NDArray() {
        assert_eq!(::std::mem::size_of::<NDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( NDArray ) ));
        assert_eq! (::std::mem::align_of::<NDArray>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( NDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray23any_element_is_negativeEb"]
        pub fn NDArray_any_element_is_negative(this: *const root::NDArray,
                                               arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray23any_element_is_positiveEb"]
        pub fn NDArray_any_element_is_positive(this: *const root::NDArray,
                                               arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray18any_element_is_nanEv"]
        pub fn NDArray_any_element_is_nan(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray25any_element_is_inf_or_nanEv"]
        pub fn NDArray_any_element_is_inf_or_nan(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray27any_element_not_one_or_zeroEv"]
        pub fn NDArray_any_element_not_one_or_zero(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray21all_elements_are_zeroEv"]
        pub fn NDArray_all_elements_are_zero(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn NDArray_all_elements_are_int_or_inf_or_nan(this:
                                                              *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray12all_integersERdS0_"]
        pub fn NDArray_all_integers(this: *const root::NDArray,
                                    max_val: *mut f64, min_val: *mut f64)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray12all_integersEv"]
        pub fn NDArray_all_integers1(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray19too_large_for_floatEv"]
        pub fn NDArray_too_large_for_float(this: *const root::NDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3allEi"]
        pub fn NDArray_all(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3anyEi"]
        pub fn NDArray_any(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray7cumprodEi"]
        pub fn NDArray_cumprod(this: *const root::NDArray,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumsumEi"]
        pub fn NDArray_cumsum(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4prodEi"]
        pub fn NDArray_prod(this: *const root::NDArray,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3sumEi"]
        pub fn NDArray_sum(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4xsumEi"]
        pub fn NDArray_xsum(this: *const root::NDArray,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5sumsqEi"]
        pub fn NDArray_sumsq(this: *const root::NDArray,
                             dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERKS_RK5ArrayIiE"]
        pub fn NDArray_concat(this: *mut root::NDArray,
                              rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERK14ComplexNDArrayRK5ArrayIiE"]
        pub fn NDArray_concat1(this: *mut root::NDArray,
                               rb: *const root::ComplexNDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6concatERK11charNDArrayRK5ArrayIiE"]
        pub fn NDArray_concat2(this: *mut root::NDArray,
                               rb: *const root::charNDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3maxEi"]
        pub fn NDArray_max(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3maxER5ArrayIiEi"]
        pub fn NDArray_max1(this: *const root::NDArray,
                            index: *mut root::Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3minEi"]
        pub fn NDArray_min(this: *const root::NDArray,
                           dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3minER5ArrayIiEi"]
        pub fn NDArray_min1(this: *const root::NDArray,
                            index: *mut root::Array<::std::os::raw::c_int>,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cummaxEi"]
        pub fn NDArray_cummax(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cummaxER5ArrayIiEi"]
        pub fn NDArray_cummax1(this: *const root::NDArray,
                               index: *mut root::Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumminEi"]
        pub fn NDArray_cummin(this: *const root::NDArray,
                              dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray6cumminER5ArrayIiEi"]
        pub fn NDArray_cummin1(this: *const root::NDArray,
                               index: *mut root::Array<::std::os::raw::c_int>,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diffEii"]
        pub fn NDArray_diff(this: *const root::NDArray,
                            order: root::octave_idx_type,
                            dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6insertERKS_ii"]
        pub fn NDArray_insert(this: *mut root::NDArray,
                              a: *const root::NDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type) -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArray6insertERKS_RK5ArrayIiE"]
        pub fn NDArray_insert1(this: *mut root::NDArray,
                               a: *const root::NDArray,
                               ra_idx:
                                   *const root::Array<::std::os::raw::c_int>)
         -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray3absEv"]
        pub fn NDArray_abs(this: *const root::NDArray) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5isnanEv"]
        pub fn NDArray_isnan(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray5isinfEv"]
        pub fn NDArray_isinf(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray8isfiniteEv"]
        pub fn NDArray_isfinite(this: *const root::NDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray7fourierEi"]
        pub fn NDArray_fourier(this: *const root::NDArray,
                               dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray8ifourierEi"]
        pub fn NDArray_ifourier(this: *const root::NDArray,
                                dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray9fourier2dEv"]
        pub fn NDArray_fourier2d(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray10ifourier2dEv"]
        pub fn NDArray_ifourier2d(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray9fourierNdEv"]
        pub fn NDArray_fourierNd(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray10ifourierNdEv"]
        pub fn NDArray_ifourierNd(this: *const root::NDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN7NDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn NDArray_increment_index(ra_idx:
                                           *mut root::Array<::std::os::raw::c_int>,
                                       dimensions: *const root::dim_vector,
                                       start_dimension:
                                           ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "_ZN7NDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn NDArray_compute_index(ra_idx:
                                         *mut root::Array<::std::os::raw::c_int>,
                                     dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diagEi"]
        pub fn NDArray_diag(this: *const root::NDArray,
                            k: root::octave_idx_type) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK7NDArray4diagEii"]
        pub fn NDArray_diag1(this: *const root::NDArray,
                             m: root::octave_idx_type,
                             n: root::octave_idx_type) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN7NDArrayC1ERK5ArrayIiEbb"]
        pub fn NDArray_NDArray(this: *mut root::NDArray,
                               a: *const root::Array<::std::os::raw::c_int>,
                               zero_based: bool, negative_to_nan: bool);
    }
    extern "C" {
        #[link_name = "_ZN7NDArrayC1ERK11charNDArray"]
        pub fn NDArray_NDArray1(this: *mut root::NDArray,
                                arg1: *const root::charNDArray);
    }
    impl NDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            NDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            NDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            NDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            NDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            NDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            NDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            NDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            NDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            NDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            NDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            NDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            NDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::NDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::NDArray {
            NDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::ComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            NDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(&mut self, rb: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            NDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            NDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::NDArray {
            NDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::NDArray {
            NDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray { NDArray_abs(self) }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            NDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            NDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            NDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            NDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            NDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            NDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            NDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            NDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            NDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            NDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            NDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::NDArray {
            NDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::NDArray {
            NDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(a: *const root::Array<::std::os::raw::c_int>,
                          zero_based: bool, negative_to_nan: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            NDArray_NDArray(&mut __bindgen_tmp, a, zero_based,
                            negative_to_nan);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            NDArray_NDArray1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexNDArray {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexNDArray() {
        assert_eq!(::std::mem::size_of::<ComplexNDArray>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( ComplexNDArray ) ));
        assert_eq! (::std::mem::align_of::<ComplexNDArray>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( ComplexNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray18any_element_is_nanEv"]
        pub fn ComplexNDArray_any_element_is_nan(this:
                                                     *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn ComplexNDArray_any_element_is_inf_or_nan(this:
                                                            *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray21all_elements_are_realEv"]
        pub fn ComplexNDArray_all_elements_are_real(this:
                                                        *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray12all_integersERdS0_"]
        pub fn ComplexNDArray_all_integers(this: *const root::ComplexNDArray,
                                           max_val: *mut f64,
                                           min_val: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray19too_large_for_floatEv"]
        pub fn ComplexNDArray_too_large_for_float(this:
                                                      *const root::ComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3allEi"]
        pub fn ComplexNDArray_all(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3anyEi"]
        pub fn ComplexNDArray_any(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray7cumprodEi"]
        pub fn ComplexNDArray_cumprod(this: *const root::ComplexNDArray,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumsumEi"]
        pub fn ComplexNDArray_cumsum(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4prodEi"]
        pub fn ComplexNDArray_prod(this: *const root::ComplexNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3sumEi"]
        pub fn ComplexNDArray_sum(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4xsumEi"]
        pub fn ComplexNDArray_xsum(this: *const root::ComplexNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5sumsqEi"]
        pub fn ComplexNDArray_sumsq(this: *const root::ComplexNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6concatERKS_RK5ArrayIiE"]
        pub fn ComplexNDArray_concat(this: *mut root::ComplexNDArray,
                                     rb: *const root::ComplexNDArray,
                                     ra_idx:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6concatERK7NDArrayRK5ArrayIiE"]
        pub fn ComplexNDArray_concat1(this: *mut root::ComplexNDArray,
                                      rb: *const root::NDArray,
                                      ra_idx:
                                          *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3maxEi"]
        pub fn ComplexNDArray_max(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3maxER5ArrayIiEi"]
        pub fn ComplexNDArray_max1(this: *const root::ComplexNDArray,
                                   index:
                                       *mut root::Array<::std::os::raw::c_int>,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3minEi"]
        pub fn ComplexNDArray_min(this: *const root::ComplexNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3minER5ArrayIiEi"]
        pub fn ComplexNDArray_min1(this: *const root::ComplexNDArray,
                                   index:
                                       *mut root::Array<::std::os::raw::c_int>,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cummaxEi"]
        pub fn ComplexNDArray_cummax(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cummaxER5ArrayIiEi"]
        pub fn ComplexNDArray_cummax1(this: *const root::ComplexNDArray,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumminEi"]
        pub fn ComplexNDArray_cummin(this: *const root::ComplexNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray6cumminER5ArrayIiEi"]
        pub fn ComplexNDArray_cummin1(this: *const root::ComplexNDArray,
                                      index:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diffEii"]
        pub fn ComplexNDArray_diff(this: *const root::ComplexNDArray,
                                   order: root::octave_idx_type,
                                   dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERK7NDArrayii"]
        pub fn ComplexNDArray_insert(this: *mut root::ComplexNDArray,
                                     a: *const root::NDArray,
                                     r: root::octave_idx_type,
                                     c: root::octave_idx_type)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERKS_ii"]
        pub fn ComplexNDArray_insert1(this: *mut root::ComplexNDArray,
                                      a: *const root::ComplexNDArray,
                                      r: root::octave_idx_type,
                                      c: root::octave_idx_type)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArray6insertERKS_RK5ArrayIiE"]
        pub fn ComplexNDArray_insert2(this: *mut root::ComplexNDArray,
                                      a: *const root::ComplexNDArray,
                                      ra_idx:
                                          *const root::Array<::std::os::raw::c_int>)
         -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray3absEv"]
        pub fn ComplexNDArray_abs(this: *const root::ComplexNDArray)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5isnanEv"]
        pub fn ComplexNDArray_isnan(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray5isinfEv"]
        pub fn ComplexNDArray_isinf(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray8isfiniteEv"]
        pub fn ComplexNDArray_isfinite(this: *const root::ComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray7fourierEi"]
        pub fn ComplexNDArray_fourier(this: *const root::ComplexNDArray,
                                      dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray8ifourierEi"]
        pub fn ComplexNDArray_ifourier(this: *const root::ComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray9fourier2dEv"]
        pub fn ComplexNDArray_fourier2d(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray10ifourier2dEv"]
        pub fn ComplexNDArray_ifourier2d(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray9fourierNdEv"]
        pub fn ComplexNDArray_fourierNd(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray10ifourierNdEv"]
        pub fn ComplexNDArray_ifourierNd(this: *const root::ComplexNDArray)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN14ComplexNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn ComplexNDArray_increment_index(ra_idx:
                                                  *mut root::Array<::std::os::raw::c_int>,
                                              dimensions:
                                                  *const root::dim_vector,
                                              start_dimension:
                                                  ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN14ComplexNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn ComplexNDArray_compute_index(ra_idx:
                                                *mut root::Array<::std::os::raw::c_int>,
                                            dimensions:
                                                *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diagEi"]
        pub fn ComplexNDArray_diag(this: *const root::ComplexNDArray,
                                   k: root::octave_idx_type)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK14ComplexNDArray4diagEii"]
        pub fn ComplexNDArray_diag1(this: *const root::ComplexNDArray,
                                    m: root::octave_idx_type,
                                    n: root::octave_idx_type)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN14ComplexNDArrayC1ERK11charNDArray"]
        pub fn ComplexNDArray_ComplexNDArray(this: *mut root::ComplexNDArray,
                                             arg1: *const root::charNDArray);
    }
    impl ComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            ComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            ComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64,
                                   min_val: *mut f64) -> bool {
            ComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            ComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            ComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            ComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::ComplexNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            ComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::ComplexNDArray {
            ComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexNDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::ComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::ComplexNDArray {
            ComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray { ComplexNDArray_abs(self) }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            ComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            ComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            ComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            ComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            ComplexNDArray_increment_index(ra_idx, dimensions,
                                           start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            ComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::ComplexNDArray {
            ComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::ComplexNDArray {
            ComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexNDArray_ComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatNDArray {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatNDArray() {
        assert_eq!(::std::mem::size_of::<FloatNDArray>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( FloatNDArray ) ));
        assert_eq! (::std::mem::align_of::<FloatNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( FloatNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray23any_element_is_negativeEb"]
        pub fn FloatNDArray_any_element_is_negative(this:
                                                        *const root::FloatNDArray,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray23any_element_is_positiveEb"]
        pub fn FloatNDArray_any_element_is_positive(this:
                                                        *const root::FloatNDArray,
                                                    arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray18any_element_is_nanEv"]
        pub fn FloatNDArray_any_element_is_nan(this:
                                                   *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatNDArray_any_element_is_inf_or_nan(this:
                                                          *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray27any_element_not_one_or_zeroEv"]
        pub fn FloatNDArray_any_element_not_one_or_zero(this:
                                                            *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray21all_elements_are_zeroEv"]
        pub fn FloatNDArray_all_elements_are_zero(this:
                                                      *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK12FloatNDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn FloatNDArray_all_elements_are_int_or_inf_or_nan(this:
                                                                   *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray12all_integersERfS0_"]
        pub fn FloatNDArray_all_integers(this: *const root::FloatNDArray,
                                         max_val: *mut f32, min_val: *mut f32)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray12all_integersEv"]
        pub fn FloatNDArray_all_integers1(this: *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray19too_large_for_floatEv"]
        pub fn FloatNDArray_too_large_for_float(this:
                                                    *const root::FloatNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3allEi"]
        pub fn FloatNDArray_all(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3anyEi"]
        pub fn FloatNDArray_any(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray7cumprodEi"]
        pub fn FloatNDArray_cumprod(this: *const root::FloatNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumsumEi"]
        pub fn FloatNDArray_cumsum(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4prodEi"]
        pub fn FloatNDArray_prod(this: *const root::FloatNDArray,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5dprodEi"]
        pub fn FloatNDArray_dprod(this: *const root::FloatNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3sumEi"]
        pub fn FloatNDArray_sum(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4dsumEi"]
        pub fn FloatNDArray_dsum(this: *const root::FloatNDArray,
                                 dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5sumsqEi"]
        pub fn FloatNDArray_sumsq(this: *const root::FloatNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6concatERKS_RK5ArrayIiE"]
        pub fn FloatNDArray_concat(this: *mut root::FloatNDArray,
                                   rb: *const root::FloatNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray6concatERK19FloatComplexNDArrayRK5ArrayIiE"]
        pub fn FloatNDArray_concat1(this: *mut root::FloatNDArray,
                                    rb: *const root::FloatComplexNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6concatERK11charNDArrayRK5ArrayIiE"]
        pub fn FloatNDArray_concat2(this: *mut root::FloatNDArray,
                                    rb: *const root::charNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3maxEi"]
        pub fn FloatNDArray_max(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3maxER5ArrayIiEi"]
        pub fn FloatNDArray_max1(this: *const root::FloatNDArray,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3minEi"]
        pub fn FloatNDArray_min(this: *const root::FloatNDArray,
                                dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3minER5ArrayIiEi"]
        pub fn FloatNDArray_min1(this: *const root::FloatNDArray,
                                 index:
                                     *mut root::Array<::std::os::raw::c_int>,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cummaxEi"]
        pub fn FloatNDArray_cummax(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cummaxER5ArrayIiEi"]
        pub fn FloatNDArray_cummax1(this: *const root::FloatNDArray,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumminEi"]
        pub fn FloatNDArray_cummin(this: *const root::FloatNDArray,
                                   dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray6cumminER5ArrayIiEi"]
        pub fn FloatNDArray_cummin1(this: *const root::FloatNDArray,
                                    index:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diffEii"]
        pub fn FloatNDArray_diff(this: *const root::FloatNDArray,
                                 order: root::octave_idx_type,
                                 dim: ::std::os::raw::c_int)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6insertERKS_ii"]
        pub fn FloatNDArray_insert(this: *mut root::FloatNDArray,
                                   a: *const root::FloatNDArray,
                                   r: root::octave_idx_type,
                                   c: root::octave_idx_type)
         -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArray6insertERKS_RK5ArrayIiE"]
        pub fn FloatNDArray_insert1(this: *mut root::FloatNDArray,
                                    a: *const root::FloatNDArray,
                                    ra_idx:
                                        *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray3absEv"]
        pub fn FloatNDArray_abs(this: *const root::FloatNDArray)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5isnanEv"]
        pub fn FloatNDArray_isnan(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray5isinfEv"]
        pub fn FloatNDArray_isinf(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray8isfiniteEv"]
        pub fn FloatNDArray_isfinite(this: *const root::FloatNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray7fourierEi"]
        pub fn FloatNDArray_fourier(this: *const root::FloatNDArray,
                                    dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray8ifourierEi"]
        pub fn FloatNDArray_ifourier(this: *const root::FloatNDArray,
                                     dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray9fourier2dEv"]
        pub fn FloatNDArray_fourier2d(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray10ifourier2dEv"]
        pub fn FloatNDArray_ifourier2d(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray9fourierNdEv"]
        pub fn FloatNDArray_fourierNd(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray10ifourierNdEv"]
        pub fn FloatNDArray_ifourierNd(this: *const root::FloatNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn FloatNDArray_increment_index(ra_idx:
                                                *mut root::Array<::std::os::raw::c_int>,
                                            dimensions:
                                                *const root::dim_vector,
                                            start_dimension:
                                                ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN12FloatNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn FloatNDArray_compute_index(ra_idx:
                                              *mut root::Array<::std::os::raw::c_int>,
                                          dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diagEi"]
        pub fn FloatNDArray_diag(this: *const root::FloatNDArray,
                                 k: root::octave_idx_type)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12FloatNDArray4diagEii"]
        pub fn FloatNDArray_diag1(this: *const root::FloatNDArray,
                                  m: root::octave_idx_type,
                                  n: root::octave_idx_type)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZN12FloatNDArrayC1ERK11charNDArray"]
        pub fn FloatNDArray_FloatNDArray(this: *mut root::FloatNDArray,
                                         arg1: *const root::charNDArray);
    }
    impl FloatNDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            FloatNDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            FloatNDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            FloatNDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32,
                                   min_val: *mut f32) -> bool {
            FloatNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            FloatNDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            FloatNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            FloatNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::FloatNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::FloatNDArray {
            FloatNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::FloatComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(&mut self, rb: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            FloatNDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatNDArray {
            FloatNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatNDArray {
            FloatNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatNDArray {
            FloatNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            FloatNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            FloatNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatNDArray {
            FloatNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::FloatNDArray {
            FloatNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatNDArray_FloatNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexNDArray {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexNDArray() {
        assert_eq!(::std::mem::size_of::<FloatComplexNDArray>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexNDArray ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexNDArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray18any_element_is_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_nan(this:
                                                          *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZNK19FloatComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_inf_or_nan(this:
                                                                 *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray21all_elements_are_realEv"]
        pub fn FloatComplexNDArray_all_elements_are_real(this:
                                                             *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray12all_integersERfS0_"]
        pub fn FloatComplexNDArray_all_integers(this:
                                                    *const root::FloatComplexNDArray,
                                                max_val: *mut f32,
                                                min_val: *mut f32) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray19too_large_for_floatEv"]
        pub fn FloatComplexNDArray_too_large_for_float(this:
                                                           *const root::FloatComplexNDArray)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3allEi"]
        pub fn FloatComplexNDArray_all(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3anyEi"]
        pub fn FloatComplexNDArray_any(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray7cumprodEi"]
        pub fn FloatComplexNDArray_cumprod(this:
                                               *const root::FloatComplexNDArray,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumsumEi"]
        pub fn FloatComplexNDArray_cumsum(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4prodEi"]
        pub fn FloatComplexNDArray_prod(this:
                                            *const root::FloatComplexNDArray,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5dprodEi"]
        pub fn FloatComplexNDArray_dprod(this:
                                             *const root::FloatComplexNDArray,
                                         dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3sumEi"]
        pub fn FloatComplexNDArray_sum(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4dsumEi"]
        pub fn FloatComplexNDArray_dsum(this:
                                            *const root::FloatComplexNDArray,
                                        dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5sumsqEi"]
        pub fn FloatComplexNDArray_sumsq(this:
                                             *const root::FloatComplexNDArray,
                                         dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6concatERKS_RK5ArrayIiE"]
        pub fn FloatComplexNDArray_concat(this:
                                              *mut root::FloatComplexNDArray,
                                          rb:
                                              *const root::FloatComplexNDArray,
                                          ra_idx:
                                              *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray6concatERK12FloatNDArrayRK5ArrayIiE"]
        pub fn FloatComplexNDArray_concat1(this:
                                               *mut root::FloatComplexNDArray,
                                           rb: *const root::FloatNDArray,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3maxEi"]
        pub fn FloatComplexNDArray_max(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3maxER5ArrayIiEi"]
        pub fn FloatComplexNDArray_max1(this:
                                            *const root::FloatComplexNDArray,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3minEi"]
        pub fn FloatComplexNDArray_min(this: *const root::FloatComplexNDArray,
                                       dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3minER5ArrayIiEi"]
        pub fn FloatComplexNDArray_min1(this:
                                            *const root::FloatComplexNDArray,
                                        index:
                                            *mut root::Array<::std::os::raw::c_int>,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cummaxEi"]
        pub fn FloatComplexNDArray_cummax(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cummaxER5ArrayIiEi"]
        pub fn FloatComplexNDArray_cummax1(this:
                                               *const root::FloatComplexNDArray,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumminEi"]
        pub fn FloatComplexNDArray_cummin(this:
                                              *const root::FloatComplexNDArray,
                                          dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray6cumminER5ArrayIiEi"]
        pub fn FloatComplexNDArray_cummin1(this:
                                               *const root::FloatComplexNDArray,
                                           index:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diffEii"]
        pub fn FloatComplexNDArray_diff(this:
                                            *const root::FloatComplexNDArray,
                                        order: root::octave_idx_type,
                                        dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERK7NDArrayii"]
        pub fn FloatComplexNDArray_insert(this:
                                              *mut root::FloatComplexNDArray,
                                          a: *const root::NDArray,
                                          r: root::octave_idx_type,
                                          c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERKS_ii"]
        pub fn FloatComplexNDArray_insert1(this:
                                               *mut root::FloatComplexNDArray,
                                           a:
                                               *const root::FloatComplexNDArray,
                                           r: root::octave_idx_type,
                                           c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArray6insertERKS_RK5ArrayIiE"]
        pub fn FloatComplexNDArray_insert2(this:
                                               *mut root::FloatComplexNDArray,
                                           a:
                                               *const root::FloatComplexNDArray,
                                           ra_idx:
                                               *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray3absEv"]
        pub fn FloatComplexNDArray_abs(this: *const root::FloatComplexNDArray)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5isnanEv"]
        pub fn FloatComplexNDArray_isnan(this:
                                             *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray5isinfEv"]
        pub fn FloatComplexNDArray_isinf(this:
                                             *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray8isfiniteEv"]
        pub fn FloatComplexNDArray_isfinite(this:
                                                *const root::FloatComplexNDArray)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray7fourierEi"]
        pub fn FloatComplexNDArray_fourier(this:
                                               *const root::FloatComplexNDArray,
                                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray8ifourierEi"]
        pub fn FloatComplexNDArray_ifourier(this:
                                                *const root::FloatComplexNDArray,
                                            dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray9fourier2dEv"]
        pub fn FloatComplexNDArray_fourier2d(this:
                                                 *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray10ifourier2dEv"]
        pub fn FloatComplexNDArray_ifourier2d(this:
                                                  *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray9fourierNdEv"]
        pub fn FloatComplexNDArray_fourierNd(this:
                                                 *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray10ifourierNdEv"]
        pub fn FloatComplexNDArray_ifourierNd(this:
                                                  *const root::FloatComplexNDArray)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn FloatComplexNDArray_increment_index(ra_idx:
                                                       *mut root::Array<::std::os::raw::c_int>,
                                                   dimensions:
                                                       *const root::dim_vector,
                                                   start_dimension:
                                                       ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN19FloatComplexNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn FloatComplexNDArray_compute_index(ra_idx:
                                                     *mut root::Array<::std::os::raw::c_int>,
                                                 dimensions:
                                                     *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diagEi"]
        pub fn FloatComplexNDArray_diag(this:
                                            *const root::FloatComplexNDArray,
                                        k: root::octave_idx_type)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK19FloatComplexNDArray4diagEii"]
        pub fn FloatComplexNDArray_diag1(this:
                                             *const root::FloatComplexNDArray,
                                         m: root::octave_idx_type,
                                         n: root::octave_idx_type)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZN19FloatComplexNDArrayC1ERK11charNDArray"]
        pub fn FloatComplexNDArray_FloatComplexNDArray(this:
                                                           *mut root::FloatComplexNDArray,
                                                       arg1:
                                                           *const root::charNDArray);
    }
    impl FloatComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32,
                                   min_val: *mut f32) -> bool {
            FloatComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            FloatComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            FloatComplexNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int)
         -> root::ComplexNDArray {
            FloatComplexNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::FloatComplexNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::FloatNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(&self,
                              index: *mut root::Array<::std::os::raw::c_int>,
                              dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(&self, order: root::octave_idx_type,
                           dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::NDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::FloatComplexNDArray,
                              r: root::octave_idx_type,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(&mut self, a: *const root::FloatComplexNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatComplexNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            FloatComplexNDArray_increment_index(ra_idx, dimensions,
                                                start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            FloatComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type)
         -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexNDArray_FloatComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolNDArray {
        pub _base: root::Array<bool>,
    }
    pub type boolNDArray_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_boolNDArray() {
        assert_eq!(::std::mem::size_of::<boolNDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( boolNDArray ) ));
        assert_eq! (::std::mem::align_of::<boolNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( boolNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6invertEv"]
        pub fn boolNDArray_invert(this: *mut root::boolNDArray)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3allEi"]
        pub fn boolNDArray_all(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3anyEi"]
        pub fn boolNDArray_any(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray3sumEi"]
        pub fn boolNDArray_sum(this: *const root::boolNDArray,
                               dim: ::std::os::raw::c_int) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray6cumsumEi"]
        pub fn boolNDArray_cumsum(this: *const root::boolNDArray,
                                  dim: ::std::os::raw::c_int)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6concatERKS_RK5ArrayIiE"]
        pub fn boolNDArray_concat(this: *mut root::boolNDArray,
                                  rb: *const root::boolNDArray,
                                  ra_idx:
                                      *const root::Array<::std::os::raw::c_int>)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6insertERKS_ii"]
        pub fn boolNDArray_insert(this: *mut root::boolNDArray,
                                  a: *const root::boolNDArray,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11boolNDArray6insertERKS_RK5ArrayIiE"]
        pub fn boolNDArray_insert1(this: *mut root::boolNDArray,
                                   a: *const root::boolNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN11boolNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn boolNDArray_increment_index(ra_idx:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dimensions:
                                               *const root::dim_vector,
                                           start_dimension:
                                               ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN11boolNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn boolNDArray_compute_index(ra_idx:
                                             *mut root::Array<::std::os::raw::c_int>,
                                         dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray4diagEi"]
        pub fn boolNDArray_diag(this: *const root::boolNDArray,
                                k: root::octave_idx_type)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11boolNDArray4diagEii"]
        pub fn boolNDArray_diag1(this: *const root::boolNDArray,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::boolNDArray;
    }
    impl boolNDArray {
        #[inline]
        pub unsafe fn invert(&mut self) -> *mut root::boolNDArray {
            boolNDArray_invert(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            boolNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            boolNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            boolNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int)
         -> root::NDArray {
            boolNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::boolNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::boolNDArray {
            boolNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::boolNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::boolNDArray {
            boolNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::boolNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::boolNDArray {
            boolNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            boolNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            boolNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::boolNDArray {
            boolNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::boolNDArray {
            boolNDArray_diag1(self, m, n)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charNDArray {
        pub _base: root::Array<::std::os::raw::c_char>,
    }
    pub type charNDArray_matrix_type = root::charMatrix;
    #[test]
    fn bindgen_test_layout_charNDArray() {
        assert_eq!(::std::mem::size_of::<charNDArray>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( charNDArray ) ));
        assert_eq! (::std::mem::align_of::<charNDArray>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( charNDArray ) ));
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3allEi"]
        pub fn charNDArray_all(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3anyEi"]
        pub fn charNDArray_any(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6concatERKS_RK5ArrayIiE"]
        pub fn charNDArray_concat(this: *mut root::charNDArray,
                                  rb: *const root::charNDArray,
                                  ra_idx:
                                      *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6concatERK7NDArrayRK5ArrayIiE"]
        pub fn charNDArray_concat1(this: *mut root::charNDArray,
                                   rb: *const root::NDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3maxEi"]
        pub fn charNDArray_max(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3maxER5ArrayIiEi"]
        pub fn charNDArray_max1(this: *const root::charNDArray,
                                index:
                                    *mut root::Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3minEi"]
        pub fn charNDArray_min(this: *const root::charNDArray,
                               dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray3minER5ArrayIiEi"]
        pub fn charNDArray_min1(this: *const root::charNDArray,
                                index:
                                    *mut root::Array<::std::os::raw::c_int>,
                                dim: ::std::os::raw::c_int)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6insertERKS_ii"]
        pub fn charNDArray_insert(this: *mut root::charNDArray,
                                  a: *const root::charNDArray,
                                  r: root::octave_idx_type,
                                  c: root::octave_idx_type)
         -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArray6insertERKS_RK5ArrayIiE"]
        pub fn charNDArray_insert1(this: *mut root::charNDArray,
                                   a: *const root::charNDArray,
                                   ra_idx:
                                       *const root::Array<::std::os::raw::c_int>)
         -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name =
              "_ZN11charNDArray15increment_indexER5ArrayIiERK10dim_vectori"]
        pub fn charNDArray_increment_index(ra_idx:
                                               *mut root::Array<::std::os::raw::c_int>,
                                           dimensions:
                                               *const root::dim_vector,
                                           start_dimension:
                                               ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name =
              "_ZN11charNDArray13compute_indexER5ArrayIiERK10dim_vector"]
        pub fn charNDArray_compute_index(ra_idx:
                                             *mut root::Array<::std::os::raw::c_int>,
                                         dimensions: *const root::dim_vector)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray4diagEi"]
        pub fn charNDArray_diag(this: *const root::charNDArray,
                                k: root::octave_idx_type)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK11charNDArray4diagEii"]
        pub fn charNDArray_diag1(this: *const root::charNDArray,
                                 m: root::octave_idx_type,
                                 n: root::octave_idx_type)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1Ec"]
        pub fn charNDArray_charNDArray(this: *mut root::charNDArray,
                                       c: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1EPKc"]
        pub fn charNDArray_charNDArray1(this: *mut root::charNDArray,
                                        s: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1ERKSs"]
        pub fn charNDArray_charNDArray2(this: *mut root::charNDArray,
                                        s: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZN11charNDArrayC1ERK13string_vectorc"]
        pub fn charNDArray_charNDArray3(this: *mut root::charNDArray,
                                        s: *const root::string_vector,
                                        fill_value: ::std::os::raw::c_char);
    }
    impl charNDArray {
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            charNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::boolNDArray {
            charNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::charNDArray,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            charNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(&mut self, rb: *const root::NDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> root::charNDArray {
            charNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int)
         -> root::charNDArray {
            charNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int)
         -> root::charNDArray {
            charNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(&self,
                           index: *mut root::Array<::std::os::raw::c_int>,
                           dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::charNDArray,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::charNDArray {
            charNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::charNDArray,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::charNDArray {
            charNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(ra_idx:
                                          *mut root::Array<::std::os::raw::c_int>,
                                      dimensions: *const root::dim_vector,
                                      start_dimension:
                                          ::std::os::raw::c_int) {
            charNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(ra_idx:
                                        *mut root::Array<::std::os::raw::c_int>,
                                    dimensions: *const root::dim_vector)
         -> root::octave_idx_type {
            charNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::charNDArray {
            charNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::charNDArray {
            charNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(s: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray1(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(s: *const root::std::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray2(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(s: *const root::string_vector,
                           fill_value: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            charNDArray_charNDArray3(&mut __bindgen_tmp, s, fill_value);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ColumnVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_ColumnVector() {
        assert_eq!(::std::mem::size_of::<ColumnVector>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( ColumnVector ) ));
        assert_eq! (::std::mem::align_of::<ColumnVector>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( ColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector6insertERKS_i"]
        pub fn ColumnVector_insert(this: *mut root::ColumnVector,
                                   a: *const root::ColumnVector,
                                   r: root::octave_idx_type)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector4fillEd"]
        pub fn ColumnVector_fill(this: *mut root::ColumnVector, val: f64)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN12ColumnVector4fillEdii"]
        pub fn ColumnVector_fill1(this: *mut root::ColumnVector, val: f64,
                                  r1: root::octave_idx_type,
                                  r2: root::octave_idx_type)
         -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector5stackERKS_"]
        pub fn ColumnVector_stack(this: *const root::ColumnVector,
                                  a: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector9transposeEv"]
        pub fn ColumnVector_transpose(this: *const root::ColumnVector)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector7extractEii"]
        pub fn ColumnVector_extract(this: *const root::ColumnVector,
                                    r1: root::octave_idx_type,
                                    r2: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector9extract_nEii"]
        pub fn ColumnVector_extract_n(this: *const root::ColumnVector,
                                      r1: root::octave_idx_type,
                                      n: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3minEv"]
        pub fn ColumnVector_min(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3maxEv"]
        pub fn ColumnVector_max(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12ColumnVector3absEv"]
        pub fn ColumnVector_abs(this: *const root::ColumnVector)
         -> root::ColumnVector;
    }
    impl ColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::ColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::ColumnVector {
            ColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ColumnVector {
            ColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ColumnVector {
            ColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector)
         -> root::ColumnVector {
            ColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::RowVector {
            ColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::ColumnVector {
            ColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ColumnVector {
            ColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { ColumnVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { ColumnVector_max(self) }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexColumnVector {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexColumnVector() {
        assert_eq!(::std::mem::size_of::<ComplexColumnVector>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( ComplexColumnVector ) ));
        assert_eq! (::std::mem::align_of::<ComplexColumnVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector6insertERK12ColumnVectori"]
        pub fn ComplexColumnVector_insert(this:
                                              *mut root::ComplexColumnVector,
                                          a: *const root::ColumnVector,
                                          r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector6insertERKS_i"]
        pub fn ComplexColumnVector_insert1(this:
                                               *mut root::ComplexColumnVector,
                                           a:
                                               *const root::ComplexColumnVector,
                                           r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillEd"]
        pub fn ComplexColumnVector_fill(this: *mut root::ComplexColumnVector,
                                        val: f64)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillERKSt7complexIdE"]
        pub fn ComplexColumnVector_fill1(this: *mut root::ComplexColumnVector,
                                         val: *const root::Complex)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillEdii"]
        pub fn ComplexColumnVector_fill2(this: *mut root::ComplexColumnVector,
                                         val: f64, r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVector4fillERKSt7complexIdEii"]
        pub fn ComplexColumnVector_fill3(this: *mut root::ComplexColumnVector,
                                         val: *const root::Complex,
                                         r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector5stackERK12ColumnVector"]
        pub fn ComplexColumnVector_stack(this:
                                             *const root::ComplexColumnVector,
                                         a: *const root::ColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector5stackERKS_"]
        pub fn ComplexColumnVector_stack1(this:
                                              *const root::ComplexColumnVector,
                                          a: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9hermitianEv"]
        pub fn ComplexColumnVector_hermitian(this:
                                                 *const root::ComplexColumnVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9transposeEv"]
        pub fn ComplexColumnVector_transpose(this:
                                                 *const root::ComplexColumnVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector7extractEii"]
        pub fn ComplexColumnVector_extract(this:
                                               *const root::ComplexColumnVector,
                                           r1: root::octave_idx_type,
                                           r2: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector9extract_nEii"]
        pub fn ComplexColumnVector_extract_n(this:
                                                 *const root::ComplexColumnVector,
                                             r1: root::octave_idx_type,
                                             n: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3minEv"]
        pub fn ComplexColumnVector_min(this: *const root::ComplexColumnVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3maxEv"]
        pub fn ComplexColumnVector_max(this: *const root::ComplexColumnVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK19ComplexColumnVector3absEv"]
        pub fn ComplexColumnVector_abs(this: *const root::ComplexColumnVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN19ComplexColumnVectorC1ERK12ColumnVector"]
        pub fn ComplexColumnVector_ComplexColumnVector(this:
                                                           *mut root::ComplexColumnVector,
                                                       a:
                                                           *const root::ColumnVector);
    }
    impl ComplexColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::ColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexColumnVector,
                              r: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector)
         -> root::ComplexColumnVector {
            ComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::ComplexColumnVector)
         -> root::ComplexColumnVector {
            ComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexRowVector {
            ComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexRowVector {
            ComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexColumnVector_ComplexColumnVector(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatColumnVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatColumnVector() {
        assert_eq!(::std::mem::size_of::<FloatColumnVector>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( FloatColumnVector )
                   ));
        assert_eq! (::std::mem::align_of::<FloatColumnVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatColumnVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector6insertERKS_i"]
        pub fn FloatColumnVector_insert(this: *mut root::FloatColumnVector,
                                        a: *const root::FloatColumnVector,
                                        r: root::octave_idx_type)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector4fillEf"]
        pub fn FloatColumnVector_fill(this: *mut root::FloatColumnVector,
                                      val: f32)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN17FloatColumnVector4fillEfii"]
        pub fn FloatColumnVector_fill1(this: *mut root::FloatColumnVector,
                                       val: f32, r1: root::octave_idx_type,
                                       r2: root::octave_idx_type)
         -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector5stackERKS_"]
        pub fn FloatColumnVector_stack(this: *const root::FloatColumnVector,
                                       a: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector9transposeEv"]
        pub fn FloatColumnVector_transpose(this:
                                               *const root::FloatColumnVector)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector7extractEii"]
        pub fn FloatColumnVector_extract(this: *const root::FloatColumnVector,
                                         r1: root::octave_idx_type,
                                         r2: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector9extract_nEii"]
        pub fn FloatColumnVector_extract_n(this:
                                               *const root::FloatColumnVector,
                                           r1: root::octave_idx_type,
                                           n: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3minEv"]
        pub fn FloatColumnVector_min(this: *const root::FloatColumnVector)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3maxEv"]
        pub fn FloatColumnVector_max(this: *const root::FloatColumnVector)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK17FloatColumnVector3absEv"]
        pub fn FloatColumnVector_abs(this: *const root::FloatColumnVector)
         -> root::FloatColumnVector;
    }
    impl FloatColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatColumnVector {
            FloatColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatColumnVector)
         -> root::FloatColumnVector {
            FloatColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatRowVector {
            FloatColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 { FloatColumnVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f32 { FloatColumnVector_max(self) }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexColumnVector {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexColumnVector() {
        assert_eq!(::std::mem::size_of::<FloatComplexColumnVector>() , 40usize
                   , concat ! (
                   "Size of: " , stringify ! ( FloatComplexColumnVector ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexColumnVector>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( FloatComplexColumnVector )
                    ));
    }
    extern "C" {
        #[link_name =
              "_ZN24FloatComplexColumnVector6insertERK17FloatColumnVectori"]
        pub fn FloatComplexColumnVector_insert(this:
                                                   *mut root::FloatComplexColumnVector,
                                               a:
                                                   *const root::FloatColumnVector,
                                               r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector6insertERKS_i"]
        pub fn FloatComplexColumnVector_insert1(this:
                                                    *mut root::FloatComplexColumnVector,
                                                a:
                                                    *const root::FloatComplexColumnVector,
                                                r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillEf"]
        pub fn FloatComplexColumnVector_fill(this:
                                                 *mut root::FloatComplexColumnVector,
                                             val: f32)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillERKSt7complexIfE"]
        pub fn FloatComplexColumnVector_fill1(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: *const root::FloatComplex)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillEfii"]
        pub fn FloatComplexColumnVector_fill2(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: f32,
                                              r1: root::octave_idx_type,
                                              r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVector4fillERKSt7complexIfEii"]
        pub fn FloatComplexColumnVector_fill3(this:
                                                  *mut root::FloatComplexColumnVector,
                                              val: *const root::FloatComplex,
                                              r1: root::octave_idx_type,
                                              r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK24FloatComplexColumnVector5stackERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_stack(this:
                                                  *const root::FloatComplexColumnVector,
                                              a:
                                                  *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector5stackERKS_"]
        pub fn FloatComplexColumnVector_stack1(this:
                                                   *const root::FloatComplexColumnVector,
                                               a:
                                                   *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9hermitianEv"]
        pub fn FloatComplexColumnVector_hermitian(this:
                                                      *const root::FloatComplexColumnVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9transposeEv"]
        pub fn FloatComplexColumnVector_transpose(this:
                                                      *const root::FloatComplexColumnVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector7extractEii"]
        pub fn FloatComplexColumnVector_extract(this:
                                                    *const root::FloatComplexColumnVector,
                                                r1: root::octave_idx_type,
                                                r2: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector9extract_nEii"]
        pub fn FloatComplexColumnVector_extract_n(this:
                                                      *const root::FloatComplexColumnVector,
                                                  r1: root::octave_idx_type,
                                                  n: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3minEv"]
        pub fn FloatComplexColumnVector_min(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3maxEv"]
        pub fn FloatComplexColumnVector_max(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK24FloatComplexColumnVector3absEv"]
        pub fn FloatComplexColumnVector_abs(this:
                                                *const root::FloatComplexColumnVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZN24FloatComplexColumnVectorC1ERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_FloatComplexColumnVector(this:
                                                                     *mut root::FloatComplexColumnVector,
                                                                 a:
                                                                     *const root::FloatColumnVector);
    }
    impl FloatComplexColumnVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatColumnVector,
                             r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(&mut self,
                              a: *const root::FloatComplexColumnVector,
                              r: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            r1: root::octave_idx_type,
                            r2: root::octave_idx_type)
         -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatComplexColumnVector)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              r2: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, r1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexColumnVector_FloatComplexColumnVector(&mut __bindgen_tmp,
                                                              a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RowVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_RowVector() {
        assert_eq!(::std::mem::size_of::<RowVector>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( RowVector ) ));
        assert_eq! (::std::mem::align_of::<RowVector>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( RowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN9RowVector6insertERKS_i"]
        pub fn RowVector_insert(this: *mut root::RowVector,
                                a: *const root::RowVector,
                                c: root::octave_idx_type)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN9RowVector4fillEd"]
        pub fn RowVector_fill(this: *mut root::RowVector, val: f64)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZN9RowVector4fillEdii"]
        pub fn RowVector_fill1(this: *mut root::RowVector, val: f64,
                               c1: root::octave_idx_type,
                               c2: root::octave_idx_type)
         -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector6appendERKS_"]
        pub fn RowVector_append(this: *const root::RowVector,
                                a: *const root::RowVector) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector9transposeEv"]
        pub fn RowVector_transpose(this: *const root::RowVector)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector7extractEii"]
        pub fn RowVector_extract(this: *const root::RowVector,
                                 c1: root::octave_idx_type,
                                 c2: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector9extract_nEii"]
        pub fn RowVector_extract_n(this: *const root::RowVector,
                                   c1: root::octave_idx_type,
                                   n: root::octave_idx_type)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector3minEv"]
        pub fn RowVector_min(this: *const root::RowVector) -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK9RowVector3maxEv"]
        pub fn RowVector_max(this: *const root::RowVector) -> f64;
    }
    impl RowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::RowVector,
                             c: root::octave_idx_type)
         -> *mut root::RowVector {
            RowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::RowVector {
            RowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::RowVector {
            RowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector)
         -> root::RowVector {
            RowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ColumnVector {
            RowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::RowVector {
            RowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type) -> root::RowVector {
            RowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 { RowVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f64 { RowVector_max(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexRowVector {
        pub _base: root::MArray<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexRowVector() {
        assert_eq!(::std::mem::size_of::<ComplexRowVector>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( ComplexRowVector )
                   ));
        assert_eq! (::std::mem::align_of::<ComplexRowVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexRowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector6insertERK9RowVectori"]
        pub fn ComplexRowVector_insert(this: *mut root::ComplexRowVector,
                                       a: *const root::RowVector,
                                       c: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector6insertERKS_i"]
        pub fn ComplexRowVector_insert1(this: *mut root::ComplexRowVector,
                                        a: *const root::ComplexRowVector,
                                        c: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillEd"]
        pub fn ComplexRowVector_fill(this: *mut root::ComplexRowVector,
                                     val: f64) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillERKSt7complexIdE"]
        pub fn ComplexRowVector_fill1(this: *mut root::ComplexRowVector,
                                      val: *const root::Complex)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillEdii"]
        pub fn ComplexRowVector_fill2(this: *mut root::ComplexRowVector,
                                      val: f64, c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN16ComplexRowVector4fillERKSt7complexIdEii"]
        pub fn ComplexRowVector_fill3(this: *mut root::ComplexRowVector,
                                      val: *const root::Complex,
                                      c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector6appendERK9RowVector"]
        pub fn ComplexRowVector_append(this: *const root::ComplexRowVector,
                                       a: *const root::RowVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector6appendERKS_"]
        pub fn ComplexRowVector_append1(this: *const root::ComplexRowVector,
                                        a: *const root::ComplexRowVector)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9hermitianEv"]
        pub fn ComplexRowVector_hermitian(this: *const root::ComplexRowVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9transposeEv"]
        pub fn ComplexRowVector_transpose(this: *const root::ComplexRowVector)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector7extractEii"]
        pub fn ComplexRowVector_extract(this: *const root::ComplexRowVector,
                                        c1: root::octave_idx_type,
                                        c2: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector9extract_nEii"]
        pub fn ComplexRowVector_extract_n(this: *const root::ComplexRowVector,
                                          c1: root::octave_idx_type,
                                          n: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector3minEv"]
        pub fn ComplexRowVector_min(this: *const root::ComplexRowVector)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK16ComplexRowVector3maxEv"]
        pub fn ComplexRowVector_max(this: *const root::ComplexRowVector)
         -> root::Complex;
    }
    impl ComplexRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::RowVector,
                             c: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::ComplexRowVector,
                              c: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::ComplexRowVector {
            ComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector)
         -> root::ComplexRowVector {
            ComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::ComplexRowVector)
         -> root::ComplexRowVector {
            ComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexColumnVector {
            ComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexColumnVector {
            ComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatRowVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatRowVector() {
        assert_eq!(::std::mem::size_of::<FloatRowVector>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( FloatRowVector ) ));
        assert_eq! (::std::mem::align_of::<FloatRowVector>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( FloatRowVector ) ));
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector6insertERKS_i"]
        pub fn FloatRowVector_insert(this: *mut root::FloatRowVector,
                                     a: *const root::FloatRowVector,
                                     c: root::octave_idx_type)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector4fillEf"]
        pub fn FloatRowVector_fill(this: *mut root::FloatRowVector, val: f32)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZN14FloatRowVector4fillEfii"]
        pub fn FloatRowVector_fill1(this: *mut root::FloatRowVector, val: f32,
                                    c1: root::octave_idx_type,
                                    c2: root::octave_idx_type)
         -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector6appendERKS_"]
        pub fn FloatRowVector_append(this: *const root::FloatRowVector,
                                     a: *const root::FloatRowVector)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector9transposeEv"]
        pub fn FloatRowVector_transpose(this: *const root::FloatRowVector)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector7extractEii"]
        pub fn FloatRowVector_extract(this: *const root::FloatRowVector,
                                      c1: root::octave_idx_type,
                                      c2: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector9extract_nEii"]
        pub fn FloatRowVector_extract_n(this: *const root::FloatRowVector,
                                        c1: root::octave_idx_type,
                                        n: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector3minEv"]
        pub fn FloatRowVector_min(this: *const root::FloatRowVector) -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK14FloatRowVector3maxEv"]
        pub fn FloatRowVector_max(this: *const root::FloatRowVector) -> f32;
    }
    impl FloatRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatRowVector,
                             c: root::octave_idx_type)
         -> *mut root::FloatRowVector {
            FloatRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatRowVector {
            FloatRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatRowVector {
            FloatRowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector)
         -> root::FloatRowVector {
            FloatRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatColumnVector {
            FloatRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 { FloatRowVector_min(self) }
        #[inline]
        pub unsafe fn max(&self) -> f32 { FloatRowVector_max(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexRowVector {
        pub _base: root::MArray<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexRowVector() {
        assert_eq!(::std::mem::size_of::<FloatComplexRowVector>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexRowVector ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexRowVector>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatComplexRowVector )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector6insertERK14FloatRowVectori"]
        pub fn FloatComplexRowVector_insert(this:
                                                *mut root::FloatComplexRowVector,
                                            a: *const root::FloatRowVector,
                                            c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector6insertERKS_i"]
        pub fn FloatComplexRowVector_insert1(this:
                                                 *mut root::FloatComplexRowVector,
                                             a:
                                                 *const root::FloatComplexRowVector,
                                             c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillEf"]
        pub fn FloatComplexRowVector_fill(this:
                                              *mut root::FloatComplexRowVector,
                                          val: f32)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillERKSt7complexIfE"]
        pub fn FloatComplexRowVector_fill1(this:
                                               *mut root::FloatComplexRowVector,
                                           val: *const root::FloatComplex)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillEfii"]
        pub fn FloatComplexRowVector_fill2(this:
                                               *mut root::FloatComplexRowVector,
                                           val: f32,
                                           c1: root::octave_idx_type,
                                           c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZN21FloatComplexRowVector4fillERKSt7complexIfEii"]
        pub fn FloatComplexRowVector_fill3(this:
                                               *mut root::FloatComplexRowVector,
                                           val: *const root::FloatComplex,
                                           c1: root::octave_idx_type,
                                           c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector6appendERK14FloatRowVector"]
        pub fn FloatComplexRowVector_append(this:
                                                *const root::FloatComplexRowVector,
                                            a: *const root::FloatRowVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector6appendERKS_"]
        pub fn FloatComplexRowVector_append1(this:
                                                 *const root::FloatComplexRowVector,
                                             a:
                                                 *const root::FloatComplexRowVector)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9hermitianEv"]
        pub fn FloatComplexRowVector_hermitian(this:
                                                   *const root::FloatComplexRowVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9transposeEv"]
        pub fn FloatComplexRowVector_transpose(this:
                                                   *const root::FloatComplexRowVector)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector7extractEii"]
        pub fn FloatComplexRowVector_extract(this:
                                                 *const root::FloatComplexRowVector,
                                             c1: root::octave_idx_type,
                                             c2: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector9extract_nEii"]
        pub fn FloatComplexRowVector_extract_n(this:
                                                   *const root::FloatComplexRowVector,
                                               c1: root::octave_idx_type,
                                               n: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector3minEv"]
        pub fn FloatComplexRowVector_min(this:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK21FloatComplexRowVector3maxEv"]
        pub fn FloatComplexRowVector_max(this:
                                             *const root::FloatComplexRowVector)
         -> root::FloatComplex;
    }
    impl FloatComplexRowVector {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::FloatRowVector,
                             c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self,
                              a: *const root::FloatComplexRowVector,
                              c: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            c1: root::octave_idx_type,
                            c2: root::octave_idx_type)
         -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatComplexRowVector)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(&self, c1: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(&self, c1: root::octave_idx_type,
                                n: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagMatrix {
        pub _base: root::MDiagArray2<f64>,
    }
    #[test]
    fn bindgen_test_layout_DiagMatrix() {
        assert_eq!(::std::mem::size_of::<DiagMatrix>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( DiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<DiagMatrix>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( DiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillEd"]
        pub fn DiagMatrix_fill(this: *mut root::DiagMatrix, val: f64)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillEdii"]
        pub fn DiagMatrix_fill1(this: *mut root::DiagMatrix, val: f64,
                                beg: root::octave_idx_type,
                                end: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK12ColumnVector"]
        pub fn DiagMatrix_fill2(this: *mut root::DiagMatrix,
                                a: *const root::ColumnVector)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK9RowVector"]
        pub fn DiagMatrix_fill3(this: *mut root::DiagMatrix,
                                a: *const root::RowVector)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK12ColumnVectori"]
        pub fn DiagMatrix_fill4(this: *mut root::DiagMatrix,
                                a: *const root::ColumnVector,
                                beg: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN10DiagMatrix4fillERK9RowVectori"]
        pub fn DiagMatrix_fill5(this: *mut root::DiagMatrix,
                                a: *const root::RowVector,
                                beg: root::octave_idx_type)
         -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3absEv"]
        pub fn DiagMatrix_abs(this: *const root::DiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7extractEiiii"]
        pub fn DiagMatrix_extract(this: *const root::DiagMatrix,
                                  r1: root::octave_idx_type,
                                  c1: root::octave_idx_type,
                                  r2: root::octave_idx_type,
                                  c2: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3rowEi"]
        pub fn DiagMatrix_row(this: *const root::DiagMatrix,
                              i: root::octave_idx_type) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix3rowEPc"]
        pub fn DiagMatrix_row1(this: *const root::DiagMatrix,
                               s: *mut ::std::os::raw::c_char)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix6columnEi"]
        pub fn DiagMatrix_column(this: *const root::DiagMatrix,
                                 i: root::octave_idx_type)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix6columnEPc"]
        pub fn DiagMatrix_column1(this: *const root::DiagMatrix,
                                  s: *mut ::std::os::raw::c_char)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7inverseEv"]
        pub fn DiagMatrix_inverse(this: *const root::DiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix7inverseERi"]
        pub fn DiagMatrix_inverse1(this: *const root::DiagMatrix,
                                   info: *mut root::octave_idx_type)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix14pseudo_inverseEd"]
        pub fn DiagMatrix_pseudo_inverse(this: *const root::DiagMatrix,
                                         tol: f64) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix11determinantEv"]
        pub fn DiagMatrix_determinant(this: *const root::DiagMatrix)
         -> root::DET;
    }
    extern "C" {
        #[link_name = "_ZNK10DiagMatrix5rcondEv"]
        pub fn DiagMatrix_rcond(this: *const root::DiagMatrix) -> f64;
    }
    impl DiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::DiagMatrix {
            DiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f64, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, a: *const root::ColumnVector)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, a: *const root::RowVector)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::ColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::RowVector,
                            beg: root::octave_idx_type)
         -> *mut root::DiagMatrix {
            DiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix { DiagMatrix_abs(self) }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type) -> root::Matrix {
            DiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::RowVector {
            DiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::RowVector {
            DiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ColumnVector {
            DiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ColumnVector {
            DiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::DiagMatrix {
            DiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::DiagMatrix {
            DiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::DiagMatrix {
            DiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            DiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { DiagMatrix_rcond(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::std::complex<f64>>,
    }
    #[test]
    fn bindgen_test_layout_ComplexDiagMatrix() {
        assert_eq!(::std::mem::size_of::<ComplexDiagMatrix>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( ComplexDiagMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<ComplexDiagMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ComplexDiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillEd"]
        pub fn ComplexDiagMatrix_fill(this: *mut root::ComplexDiagMatrix,
                                      val: f64)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERKSt7complexIdE"]
        pub fn ComplexDiagMatrix_fill1(this: *mut root::ComplexDiagMatrix,
                                       val: *const root::Complex)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillEdii"]
        pub fn ComplexDiagMatrix_fill2(this: *mut root::ComplexDiagMatrix,
                                       val: f64, beg: root::octave_idx_type,
                                       end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERKSt7complexIdEii"]
        pub fn ComplexDiagMatrix_fill3(this: *mut root::ComplexDiagMatrix,
                                       val: *const root::Complex,
                                       beg: root::octave_idx_type,
                                       end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK12ColumnVector"]
        pub fn ComplexDiagMatrix_fill4(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ColumnVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVector"]
        pub fn ComplexDiagMatrix_fill5(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexColumnVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK9RowVector"]
        pub fn ComplexDiagMatrix_fill6(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::RowVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK16ComplexRowVector"]
        pub fn ComplexDiagMatrix_fill7(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexRowVector)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK12ColumnVectori"]
        pub fn ComplexDiagMatrix_fill8(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ColumnVector,
                                       beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVectori"]
        pub fn ComplexDiagMatrix_fill9(this: *mut root::ComplexDiagMatrix,
                                       a: *const root::ComplexColumnVector,
                                       beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK9RowVectori"]
        pub fn ComplexDiagMatrix_fill10(this: *mut root::ComplexDiagMatrix,
                                        a: *const root::RowVector,
                                        beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrix4fillERK16ComplexRowVectori"]
        pub fn ComplexDiagMatrix_fill11(this: *mut root::ComplexDiagMatrix,
                                        a: *const root::ComplexRowVector,
                                        beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3absEv"]
        pub fn ComplexDiagMatrix_abs(this: *const root::ComplexDiagMatrix)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7extractEiiii"]
        pub fn ComplexDiagMatrix_extract(this: *const root::ComplexDiagMatrix,
                                         r1: root::octave_idx_type,
                                         c1: root::octave_idx_type,
                                         r2: root::octave_idx_type,
                                         c2: root::octave_idx_type)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3rowEi"]
        pub fn ComplexDiagMatrix_row(this: *const root::ComplexDiagMatrix,
                                     i: root::octave_idx_type)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix3rowEPc"]
        pub fn ComplexDiagMatrix_row1(this: *const root::ComplexDiagMatrix,
                                      s: *mut ::std::os::raw::c_char)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix6columnEi"]
        pub fn ComplexDiagMatrix_column(this: *const root::ComplexDiagMatrix,
                                        i: root::octave_idx_type)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix6columnEPc"]
        pub fn ComplexDiagMatrix_column1(this: *const root::ComplexDiagMatrix,
                                         s: *mut ::std::os::raw::c_char)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7inverseERi"]
        pub fn ComplexDiagMatrix_inverse(this: *const root::ComplexDiagMatrix,
                                         info: *mut root::octave_idx_type)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix7inverseEv"]
        pub fn ComplexDiagMatrix_inverse1(this:
                                              *const root::ComplexDiagMatrix)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix14pseudo_inverseEd"]
        pub fn ComplexDiagMatrix_pseudo_inverse(this:
                                                    *const root::ComplexDiagMatrix,
                                                tol: f64)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix21all_elements_are_realEv"]
        pub fn ComplexDiagMatrix_all_elements_are_real(this:
                                                           *const root::ComplexDiagMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix11determinantEv"]
        pub fn ComplexDiagMatrix_determinant(this:
                                                 *const root::ComplexDiagMatrix)
         -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK17ComplexDiagMatrix5rcondEv"]
        pub fn ComplexDiagMatrix_rcond(this: *const root::ComplexDiagMatrix)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZN17ComplexDiagMatrixC1ERK10DiagMatrix"]
        pub fn ComplexDiagMatrix_ComplexDiagMatrix(this:
                                                       *mut root::ComplexDiagMatrix,
                                                   a:
                                                       *const root::DiagMatrix);
    }
    impl ComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f64, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::Complex,
                            beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::ColumnVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::ComplexColumnVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(&mut self, a: *const root::RowVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(&mut self, a: *const root::ComplexRowVector)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(&mut self, a: *const root::ColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(&mut self, a: *const root::ComplexColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(&mut self, a: *const root::RowVector,
                             beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(&mut self, a: *const root::ComplexRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix {
            ComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::ComplexMatrix {
            ComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::ComplexRowVector {
            ComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ComplexRowVector {
            ComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::ComplexColumnVector {
            ComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::ComplexColumnVector {
            ComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self, info: *mut root::octave_idx_type)
         -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64)
         -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 { ComplexDiagMatrix_rcond(self) }
        #[inline]
        pub unsafe fn new(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ComplexDiagMatrix_ComplexDiagMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatDiagMatrix {
        pub _base: root::MDiagArray2<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatDiagMatrix() {
        assert_eq!(::std::mem::size_of::<FloatDiagMatrix>() , 48usize , concat
                   ! ( "Size of: " , stringify ! ( FloatDiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatDiagMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( FloatDiagMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillEf"]
        pub fn FloatDiagMatrix_fill(this: *mut root::FloatDiagMatrix,
                                    val: f32) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillEfii"]
        pub fn FloatDiagMatrix_fill1(this: *mut root::FloatDiagMatrix,
                                     val: f32, beg: root::octave_idx_type,
                                     end: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatDiagMatrix_fill2(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatColumnVector)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatDiagMatrix_fill3(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatRowVector)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK17FloatColumnVectori"]
        pub fn FloatDiagMatrix_fill4(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatColumnVector,
                                     beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN15FloatDiagMatrix4fillERK14FloatRowVectori"]
        pub fn FloatDiagMatrix_fill5(this: *mut root::FloatDiagMatrix,
                                     a: *const root::FloatRowVector,
                                     beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3absEv"]
        pub fn FloatDiagMatrix_abs(this: *const root::FloatDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7extractEiiii"]
        pub fn FloatDiagMatrix_extract(this: *const root::FloatDiagMatrix,
                                       r1: root::octave_idx_type,
                                       c1: root::octave_idx_type,
                                       r2: root::octave_idx_type,
                                       c2: root::octave_idx_type)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3rowEi"]
        pub fn FloatDiagMatrix_row(this: *const root::FloatDiagMatrix,
                                   i: root::octave_idx_type)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix3rowEPc"]
        pub fn FloatDiagMatrix_row1(this: *const root::FloatDiagMatrix,
                                    s: *mut ::std::os::raw::c_char)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix6columnEi"]
        pub fn FloatDiagMatrix_column(this: *const root::FloatDiagMatrix,
                                      i: root::octave_idx_type)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix6columnEPc"]
        pub fn FloatDiagMatrix_column1(this: *const root::FloatDiagMatrix,
                                       s: *mut ::std::os::raw::c_char)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7inverseEv"]
        pub fn FloatDiagMatrix_inverse(this: *const root::FloatDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix7inverseERi"]
        pub fn FloatDiagMatrix_inverse1(this: *const root::FloatDiagMatrix,
                                        info: *mut root::octave_idx_type)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix14pseudo_inverseEf"]
        pub fn FloatDiagMatrix_pseudo_inverse(this:
                                                  *const root::FloatDiagMatrix,
                                              tol: f32)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix11determinantEv"]
        pub fn FloatDiagMatrix_determinant(this: *const root::FloatDiagMatrix)
         -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "_ZNK15FloatDiagMatrix5rcondEv"]
        pub fn FloatDiagMatrix_rcond(this: *const root::FloatDiagMatrix)
         -> f32;
    }
    impl FloatDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: f32, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, a: *const root::FloatColumnVector)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, a: *const root::FloatRowVector)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::FloatColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(&mut self, a: *const root::FloatRowVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatMatrix {
            FloatDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatRowVector {
            FloatDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatRowVector {
            FloatDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatColumnVector {
            FloatDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatColumnVector {
            FloatDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type)
         -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatDiagMatrix {
            FloatDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 { FloatDiagMatrix_rcond(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::std::complex<f32>>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexDiagMatrix() {
        assert_eq!(::std::mem::size_of::<FloatComplexDiagMatrix>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( FloatComplexDiagMatrix ) ));
        assert_eq! (::std::mem::align_of::<FloatComplexDiagMatrix>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( FloatComplexDiagMatrix )
                    ));
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillEf"]
        pub fn FloatComplexDiagMatrix_fill(this:
                                               *mut root::FloatComplexDiagMatrix,
                                           val: f32)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexDiagMatrix_fill1(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: *const root::FloatComplex)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillEfii"]
        pub fn FloatComplexDiagMatrix_fill2(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: f32,
                                            beg: root::octave_idx_type,
                                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfEii"]
        pub fn FloatComplexDiagMatrix_fill3(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            val: *const root::FloatComplex,
                                            beg: root::octave_idx_type,
                                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatComplexDiagMatrix_fill4(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatColumnVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVector"]
        pub fn FloatComplexDiagMatrix_fill5(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexColumnVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatComplexDiagMatrix_fill6(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatRowVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVector"]
        pub fn FloatComplexDiagMatrix_fill7(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexRowVector)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVectori"]
        pub fn FloatComplexDiagMatrix_fill8(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a: *const root::FloatColumnVector,
                                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVectori"]
        pub fn FloatComplexDiagMatrix_fill9(this:
                                                *mut root::FloatComplexDiagMatrix,
                                            a:
                                                *const root::FloatComplexColumnVector,
                                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVectori"]
        pub fn FloatComplexDiagMatrix_fill10(this:
                                                 *mut root::FloatComplexDiagMatrix,
                                             a: *const root::FloatRowVector,
                                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVectori"]
        pub fn FloatComplexDiagMatrix_fill11(this:
                                                 *mut root::FloatComplexDiagMatrix,
                                             a:
                                                 *const root::FloatComplexRowVector,
                                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3absEv"]
        pub fn FloatComplexDiagMatrix_abs(this:
                                              *const root::FloatComplexDiagMatrix)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7extractEiiii"]
        pub fn FloatComplexDiagMatrix_extract(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              r1: root::octave_idx_type,
                                              c1: root::octave_idx_type,
                                              r2: root::octave_idx_type,
                                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3rowEi"]
        pub fn FloatComplexDiagMatrix_row(this:
                                              *const root::FloatComplexDiagMatrix,
                                          i: root::octave_idx_type)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix3rowEPc"]
        pub fn FloatComplexDiagMatrix_row1(this:
                                               *const root::FloatComplexDiagMatrix,
                                           s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix6columnEi"]
        pub fn FloatComplexDiagMatrix_column(this:
                                                 *const root::FloatComplexDiagMatrix,
                                             i: root::octave_idx_type)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix6columnEPc"]
        pub fn FloatComplexDiagMatrix_column1(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7inverseERi"]
        pub fn FloatComplexDiagMatrix_inverse(this:
                                                  *const root::FloatComplexDiagMatrix,
                                              info:
                                                  *mut root::octave_idx_type)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix7inverseEv"]
        pub fn FloatComplexDiagMatrix_inverse1(this:
                                                   *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix14pseudo_inverseEf"]
        pub fn FloatComplexDiagMatrix_pseudo_inverse(this:
                                                         *const root::FloatComplexDiagMatrix,
                                                     tol: f32)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix21all_elements_are_realEv"]
        pub fn FloatComplexDiagMatrix_all_elements_are_real(this:
                                                                *const root::FloatComplexDiagMatrix)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix11determinantEv"]
        pub fn FloatComplexDiagMatrix_determinant(this:
                                                      *const root::FloatComplexDiagMatrix)
         -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "_ZNK22FloatComplexDiagMatrix5rcondEv"]
        pub fn FloatComplexDiagMatrix_rcond(this:
                                                *const root::FloatComplexDiagMatrix)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZN22FloatComplexDiagMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexDiagMatrix_FloatComplexDiagMatrix(this:
                                                                 *mut root::FloatComplexDiagMatrix,
                                                             a:
                                                                 *const root::FloatDiagMatrix);
    }
    impl FloatComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::FloatComplex)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, val: f32, beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, val: *const root::FloatComplex,
                            beg: root::octave_idx_type,
                            end: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(&mut self, a: *const root::FloatColumnVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(&mut self,
                            a: *const root::FloatComplexColumnVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(&mut self, a: *const root::FloatRowVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(&mut self, a: *const root::FloatComplexRowVector)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(&mut self, a: *const root::FloatColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(&mut self,
                            a: *const root::FloatComplexColumnVector,
                            beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(&mut self, a: *const root::FloatRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(&mut self, a: *const root::FloatComplexRowVector,
                             beg: root::octave_idx_type)
         -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(&self, r1: root::octave_idx_type,
                              c1: root::octave_idx_type,
                              r2: root::octave_idx_type,
                              c2: root::octave_idx_type)
         -> root::FloatComplexMatrix {
            FloatComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type)
         -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type)
         -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char)
         -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self, info: *mut root::octave_idx_type)
         -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32)
         -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatComplexDiagMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            FloatComplexDiagMatrix_FloatComplexDiagMatrix(&mut __bindgen_tmp,
                                                          a);
            __bindgen_tmp
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum blas_trans_type {
        blas_no_trans = 78,
        blas_trans = 84,
        blas_conj_trans = 67,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct string_vector {
        pub _base: root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                       root::std::allocator>>,
    }
    #[test]
    fn bindgen_test_layout_string_vector() {
        assert_eq!(::std::mem::size_of::<string_vector>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( string_vector ) ));
        assert_eq! (::std::mem::align_of::<string_vector>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( string_vector ) ));
    }
    extern "C" {
        #[link_name = "_ZN13string_vector4sortEb"]
        pub fn string_vector_sort(this: *mut root::string_vector,
                                  make_uniq: bool)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector4uniqEv"]
        pub fn string_vector_uniq(this: *mut root::string_vector)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector6appendERKSs"]
        pub fn string_vector_append(this: *mut root::string_vector,
                                    s: *const root::std::string)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector6appendERKS_"]
        pub fn string_vector_append1(this: *mut root::string_vector,
                                     sv: *const root::string_vector)
         -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector4joinERKSs"]
        pub fn string_vector_join(this: *const root::string_vector,
                                  sep: *const root::std::string)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector9c_str_vecEv"]
        pub fn string_vector_c_str_vec(this: *const root::string_vector)
         -> *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector8std_listEv"]
        pub fn string_vector_std_list(this: *const root::string_vector)
         -> root::std::list;
    }
    extern "C" {
        #[link_name = "_ZN13string_vector16delete_c_str_vecEPKPKc"]
        pub fn string_vector_delete_c_str_vec(arg1:
                                                  *const *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZNK13string_vector15list_in_columnsERSoiRKSs"]
        pub fn string_vector_list_in_columns(this: *const root::string_vector,
                                             arg1: *mut root::std::ostream,
                                             width: ::std::os::raw::c_int,
                                             prefix: *const root::std::string)
         -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN13string_vectorC1EPKPKc"]
        pub fn string_vector_string_vector(this: *mut root::string_vector,
                                           s:
                                               *const *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN13string_vectorC1EPKPKci"]
        pub fn string_vector_string_vector1(this: *mut root::string_vector,
                                            s:
                                                *const *const ::std::os::raw::c_char,
                                            n: root::octave_idx_type);
    }
    impl string_vector {
        #[inline]
        pub unsafe fn sort(&mut self, make_uniq: bool)
         -> *mut root::string_vector {
            string_vector_sort(self, make_uniq)
        }
        #[inline]
        pub unsafe fn uniq(&mut self) -> *mut root::string_vector {
            string_vector_uniq(self)
        }
        #[inline]
        pub unsafe fn append(&mut self, s: *const root::std::string)
         -> *mut root::string_vector {
            string_vector_append(self, s)
        }
        #[inline]
        pub unsafe fn append1(&mut self, sv: *const root::string_vector)
         -> *mut root::string_vector {
            string_vector_append1(self, sv)
        }
        #[inline]
        pub unsafe fn join(&self, sep: *const root::std::string)
         -> root::std::string {
            string_vector_join(self, sep)
        }
        #[inline]
        pub unsafe fn c_str_vec(&self) -> *mut *mut ::std::os::raw::c_char {
            string_vector_c_str_vec(self)
        }
        #[inline]
        pub unsafe fn std_list(&self) -> root::std::list {
            string_vector_std_list(self)
        }
        #[inline]
        pub unsafe fn delete_c_str_vec(arg1:
                                           *const *const ::std::os::raw::c_char) {
            string_vector_delete_c_str_vec(arg1)
        }
        #[inline]
        pub unsafe fn list_in_columns(&self, arg1: *mut root::std::ostream,
                                      width: ::std::os::raw::c_int,
                                      prefix: *const root::std::string)
         -> *mut root::std::ostream {
            string_vector_list_in_columns(self, arg1, width, prefix)
        }
        #[inline]
        pub unsafe fn new(s: *const *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            string_vector_string_vector(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(s: *const *const ::std::os::raw::c_char,
                           n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            string_vector_string_vector1(&mut __bindgen_tmp, s, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct intNDArray<T> {
        pub _base: root::MArray<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagArray2<T> {
        pub _base: root::Array<T>,
        pub d1: root::octave_idx_type,
        pub d2: root::octave_idx_type,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MDiagArray2<T> {
        pub _base: root::DiagArray2<T>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct base_det<T> {
        pub c2: T,
        pub e2: ::std::os::raw::c_int,
    }
    pub type DET = root::base_det<f64>;
    pub type FloatDET = root::base_det<f32>;
    pub type ComplexDET = root::base_det<root::std::complex<f64>>;
    pub type FloatComplexDET = root::base_det<root::std::complex<f32>>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseBoolMatrix {
        pub _base: root::Sparse<bool>,
    }
    pub type SparseBoolMatrix_dense_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_SparseBoolMatrix() {
        assert_eq!(::std::mem::size_of::<SparseBoolMatrix>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( SparseBoolMatrix )
                   ));
        assert_eq! (::std::mem::align_of::<SparseBoolMatrix>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( SparseBoolMatrix ) ));
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6insertERKS_ii"]
        pub fn SparseBoolMatrix_insert(this: *mut root::SparseBoolMatrix,
                                       a: *const root::SparseBoolMatrix,
                                       r: root::octave_idx_type,
                                       c: root::octave_idx_type)
         -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6insertERKS_RK5ArrayIiE"]
        pub fn SparseBoolMatrix_insert1(this: *mut root::SparseBoolMatrix,
                                        a: *const root::SparseBoolMatrix,
                                        indx:
                                            *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZN16SparseBoolMatrix6concatERKS_RK5ArrayIiE"]
        pub fn SparseBoolMatrix_concat(this: *mut root::SparseBoolMatrix,
                                       rb: *const root::SparseBoolMatrix,
                                       ra_idx:
                                           *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix4diagEi"]
        pub fn SparseBoolMatrix_diag(this: *const root::SparseBoolMatrix,
                                     k: root::octave_idx_type)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix12matrix_valueEv"]
        pub fn SparseBoolMatrix_matrix_value(this:
                                                 *const root::SparseBoolMatrix)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7squeezeEv"]
        pub fn SparseBoolMatrix_squeeze(this: *const root::SparseBoolMatrix)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix5indexERK10idx_vectorb"]
        pub fn SparseBoolMatrix_index(this: *const root::SparseBoolMatrix,
                                      i: *const root::idx_vector,
                                      resize_ok: bool)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix5indexERK10idx_vectorS2_b"]
        pub fn SparseBoolMatrix_index1(this: *const root::SparseBoolMatrix,
                                       i: *const root::idx_vector,
                                       j: *const root::idx_vector,
                                       resize_ok: bool)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7reshapeERK10dim_vector"]
        pub fn SparseBoolMatrix_reshape(this: *const root::SparseBoolMatrix,
                                        new_dims: *const root::dim_vector)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix7permuteERK5ArrayIiEb"]
        pub fn SparseBoolMatrix_permute(this: *const root::SparseBoolMatrix,
                                        vec:
                                            *const root::Array<::std::os::raw::c_int>,
                                        inv: bool) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix8ipermuteERK5ArrayIiE"]
        pub fn SparseBoolMatrix_ipermute(this: *const root::SparseBoolMatrix,
                                         vec:
                                             *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3allEi"]
        pub fn SparseBoolMatrix_all(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3anyEi"]
        pub fn SparseBoolMatrix_any(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK16SparseBoolMatrix3sumEi"]
        pub fn SparseBoolMatrix_sum(this: *const root::SparseBoolMatrix,
                                    dim: ::std::os::raw::c_int)
         -> root::SparseMatrix;
    }
    impl SparseBoolMatrix {
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::SparseBoolMatrix,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type)
         -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::SparseBoolMatrix,
                              indx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::SparseBoolMatrix,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::boolMatrix {
            SparseBoolMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseBoolMatrix {
            SparseBoolMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector,
                            resize_ok: bool) -> root::SparseBoolMatrix {
            SparseBoolMatrix_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(&self, i: *const root::idx_vector,
                             j: *const root::idx_vector, resize_ok: bool)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::SparseBoolMatrix {
            SparseBoolMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(&self,
                               vec: *const root::Array<::std::os::raw::c_int>)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int)
         -> root::SparseBoolMatrix {
            SparseBoolMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int)
         -> root::SparseMatrix {
            SparseBoolMatrix_sum(self, dim)
        }
    }
    pub type int8NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_schar>>;
    pub type int16NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_short>>;
    pub type int32NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_int>>;
    pub type int64NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>;
    pub type uint8NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>;
    pub type uint16NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>;
    pub type uint32NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_uint>>;
    pub type uint64NDArray =
        root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>;
    pub type octave_time = root::octave::sys::time;
    pub type octave_base_tm = root::octave::sys::base_tm;
    pub type octave_localtime = root::octave::sys::localtime;
    pub type octave_gmtime = root::octave::sys::gmtime;
    pub type octave_strptime = root::octave::sys::strptime;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Cell {
        pub _base: root::Array<root::octave_value>,
    }
    pub type Cell_ctype_mapper =
        ::std::option::Option<unsafe extern "C" fn() -> root::octave_value>;
    #[test]
    fn bindgen_test_layout_Cell() {
        assert_eq!(::std::mem::size_of::<Cell>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( Cell ) ));
        assert_eq! (::std::mem::align_of::<Cell>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( Cell ) ));
    }
    extern "C" {
        #[link_name = "_ZNK4Cell10is_cellstrEv"]
        pub fn Cell_is_cellstr(this: *const root::Cell) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell13cellstr_valueEv"]
        pub fn Cell_cellstr_value(this: *const root::Cell)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>>;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell5indexERK17octave_value_listb"]
        pub fn Cell_index(this: *const root::Cell,
                          idx: *const root::octave_value_list,
                          resize_ok: bool) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell15delete_elementsERK17octave_value_list"]
        pub fn Cell_delete_elements(this: *mut root::Cell,
                                    idx: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name =
              "_ZN4Cell6assignERK17octave_value_listRKS_RK12octave_value"]
        pub fn Cell_assign(this: *mut root::Cell,
                           idx: *const root::octave_value_list,
                           rhs: *const root::Cell,
                           fill_val: *const root::octave_value);
    }
    extern "C" {
        #[link_name = "_ZNK4Cell3nnzEv"]
        pub fn Cell_nnz(this: *const root::Cell) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell6columnEi"]
        pub fn Cell_column(this: *const root::Cell, i: root::octave_idx_type)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6concatERKS_RK5ArrayIiE"]
        pub fn Cell_concat(this: *mut root::Cell, rb: *const root::Cell,
                           ra_idx: *const root::Array<::std::os::raw::c_int>)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6insertERKS_ii"]
        pub fn Cell_insert(this: *mut root::Cell, a: *const root::Cell,
                           r: root::octave_idx_type, c: root::octave_idx_type)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4Cell6insertERKS_RK5ArrayIiE"]
        pub fn Cell_insert1(this: *mut root::Cell, a: *const root::Cell,
                            ra_idx: *const root::Array<::std::os::raw::c_int>)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell4diagEi"]
        pub fn Cell_diag(this: *const root::Cell, k: root::octave_idx_type)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK4Cell4diagEii"]
        pub fn Cell_diag1(this: *const root::Cell, m: root::octave_idx_type,
                          n: root::octave_idx_type) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK17octave_value_list"]
        pub fn Cell_Cell(this: *mut root::Cell,
                         ovl: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK13string_vectorb"]
        pub fn Cell_Cell1(this: *mut root::Cell,
                          sv: *const root::string_vector, trim: bool);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERKSt4listISsSaISsEE"]
        pub fn Cell_Cell2(this: *mut root::Cell, lst: *const root::std::list);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK5ArrayISsE"]
        pub fn Cell_Cell3(this: *mut root::Cell,
                          sa:
                              *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                         root::std::allocator>>);
    }
    extern "C" {
        #[link_name = "_ZN4CellC1ERK10dim_vectorRK13string_vectorb"]
        pub fn Cell_Cell4(this: *mut root::Cell, dv: *const root::dim_vector,
                          sv: *const root::string_vector, trim: bool);
    }
    impl Cell {
        #[inline]
        pub unsafe fn is_cellstr(&self) -> bool { Cell_is_cellstr(self) }
        #[inline]
        pub unsafe fn cellstr_value(&self)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>> {
            Cell_cellstr_value(self)
        }
        #[inline]
        pub unsafe fn index(&self, idx: *const root::octave_value_list,
                            resize_ok: bool) -> root::Cell {
            Cell_index(self, idx, resize_ok)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self,
                                      idx: *const root::octave_value_list) {
            Cell_delete_elements(self, idx)
        }
        #[inline]
        pub unsafe fn assign(&mut self, idx: *const root::octave_value_list,
                             rhs: *const root::Cell,
                             fill_val: *const root::octave_value) {
            Cell_assign(self, idx, rhs, fill_val)
        }
        #[inline]
        pub unsafe fn nnz(&self) -> root::octave_idx_type { Cell_nnz(self) }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::Cell {
            Cell_column(self, i)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::Cell,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::Cell {
            Cell_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(&mut self, a: *const root::Cell,
                             r: root::octave_idx_type,
                             c: root::octave_idx_type) -> *mut root::Cell {
            Cell_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(&mut self, a: *const root::Cell,
                              ra_idx:
                                  *const root::Array<::std::os::raw::c_int>)
         -> *mut root::Cell {
            Cell_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Cell {
            Cell_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(&self, m: root::octave_idx_type,
                            n: root::octave_idx_type) -> root::Cell {
            Cell_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(ovl: *const root::octave_value_list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell(&mut __bindgen_tmp, ovl);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(sv: *const root::string_vector, trim: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell1(&mut __bindgen_tmp, sv, trim);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(lst: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell2(&mut __bindgen_tmp, lst);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(sa:
                               *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                          root::std::allocator>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell3(&mut __bindgen_tmp, sa);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(dv: *const root::dim_vector,
                           sv: *const root::string_vector, trim: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Cell_Cell4(&mut __bindgen_tmp, dv, sv, trim);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mxArray([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_map {
        pub xkeys: root::octave_fields,
        pub xvals: root::std::vector,
        pub dimensions: root::dim_vector,
    }
    pub type octave_map_element_type = root::octave_scalar_map;
    pub type octave_map_const_iterator = root::octave_fields_const_iterator;
    pub type octave_map_iterator = root::octave_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_map() {
        assert_eq!(::std::mem::size_of::<octave_map>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( octave_map ) ));
        assert_eq! (::std::mem::align_of::<octave_map>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( octave_map ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . xkeys as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( xkeys ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . xvals as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( xvals ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_map ) ) . dimensions as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_map ) , "::"
                    , stringify ! ( dimensions ) ));
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map8getfieldERKSs"]
        pub fn octave_map_getfield(this: *const root::octave_map,
                                   key: *const root::std::string)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map8setfieldERKSsRK4Cell"]
        pub fn octave_map_setfield(this: *mut root::octave_map,
                                   key: *const root::std::string,
                                   val: *const root::Cell);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map7rmfieldERKSs"]
        pub fn octave_map_rmfield(this: *mut root::octave_map,
                                  key: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsEv"]
        pub fn octave_map_orderfields(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsER5ArrayIiE"]
        pub fn octave_map_orderfields1(this: *const root::octave_map,
                                       perm:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map11orderfieldsERKS_R5ArrayIiE"]
        pub fn octave_map_orderfields2(this: *const root::octave_map,
                                       other: *const root::octave_map,
                                       perm:
                                           *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map8contentsERKSs"]
        pub fn octave_map_contents(this: *const root::octave_map,
                                   k: *const root::std::string) -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map8contentsERKSs"]
        pub fn octave_map_contents1(this: *mut root::octave_map,
                                    k: *const root::std::string)
         -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemEi"]
        pub fn octave_map_checkelem(this: *const root::octave_map,
                                    n: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemEii"]
        pub fn octave_map_checkelem1(this: *const root::octave_map,
                                     i: root::octave_idx_type,
                                     j: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9checkelemERK5ArrayIiE"]
        pub fn octave_map_checkelem2(this: *const root::octave_map,
                                     ra_idx:
                                         *const root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7squeezeEv"]
        pub fn octave_map_squeeze(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7permuteERK5ArrayIiEb"]
        pub fn octave_map_permute(this: *const root::octave_map,
                                  vec:
                                      *const root::Array<::std::os::raw::c_int>,
                                  inv: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map9transposeEv"]
        pub fn octave_map_transpose(this: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map7reshapeERK10dim_vector"]
        pub fn octave_map_reshape(this: *const root::octave_map,
                                  dv: *const root::dim_vector)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6resizeERK10dim_vectorb"]
        pub fn octave_map_resize(this: *mut root::octave_map,
                                 dv: *const root::dim_vector, fill: bool);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map3catEiiPK17octave_scalar_map"]
        pub fn octave_map_cat(dim: ::std::os::raw::c_int,
                              n: root::octave_idx_type,
                              map_list: *const root::octave_scalar_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map3catEiiPKS_"]
        pub fn octave_map_cat1(dim: ::std::os::raw::c_int,
                               n: root::octave_idx_type,
                               map_list: *const root::octave_map)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK10idx_vectorb"]
        pub fn octave_map_index(this: *const root::octave_map,
                                i: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK10idx_vectorS2_b"]
        pub fn octave_map_index1(this: *const root::octave_map,
                                 i: *const root::idx_vector,
                                 j: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK5ArrayI10idx_vectorEb"]
        pub fn octave_map_index2(this: *const root::octave_map,
                                 ia: *const root::Array<root::idx_vector>,
                                 resize_ok: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map5indexERK17octave_value_listb"]
        pub fn octave_map_index3(this: *const root::octave_map,
                                 arg1: *const root::octave_value_list,
                                 resize_ok: bool) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map6columnEi"]
        pub fn octave_map_column(this: *const root::octave_map,
                                 k: root::octave_idx_type)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map4pageEi"]
        pub fn octave_map_page(this: *const root::octave_map,
                               k: root::octave_idx_type) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK10idx_vectorRKS_"]
        pub fn octave_map_assign(this: *mut root::octave_map,
                                 i: *const root::idx_vector,
                                 rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK10idx_vectorS2_RKS_"]
        pub fn octave_map_assign1(this: *mut root::octave_map,
                                  i: *const root::idx_vector,
                                  j: *const root::idx_vector,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK5ArrayI10idx_vectorERKS_"]
        pub fn octave_map_assign2(this: *mut root::octave_map,
                                  ia: *const root::Array<root::idx_vector>,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6assignERK17octave_value_listRKS_"]
        pub fn octave_map_assign3(this: *mut root::octave_map,
                                  arg1: *const root::octave_value_list,
                                  rhs: *const root::octave_map);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map6assignERK17octave_value_listRKSsRK4Cell"]
        pub fn octave_map_assign4(this: *mut root::octave_map,
                                  idx: *const root::octave_value_list,
                                  k: *const root::std::string,
                                  rhs: *const root::Cell);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map15delete_elementsERK10idx_vector"]
        pub fn octave_map_delete_elements(this: *mut root::octave_map,
                                          i: *const root::idx_vector);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map15delete_elementsEiRK10idx_vector"]
        pub fn octave_map_delete_elements1(this: *mut root::octave_map,
                                           dim: ::std::os::raw::c_int,
                                           i: *const root::idx_vector);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map15delete_elementsERK5ArrayI10idx_vectorE"]
        pub fn octave_map_delete_elements2(this: *mut root::octave_map,
                                           ia:
                                               *const root::Array<root::idx_vector>);
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map15delete_elementsERK17octave_value_list"]
        pub fn octave_map_delete_elements3(this: *mut root::octave_map,
                                           arg1:
                                               *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN10octave_map6concatERKS_RK5ArrayIiE"]
        pub fn octave_map_concat(this: *mut root::octave_map,
                                 rb: *const root::octave_map,
                                 ra_idx:
                                     *const root::Array<::std::os::raw::c_int>)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK10octave_map17fast_elem_extractEi"]
        pub fn octave_map_fast_elem_extract(this: *const root::octave_map,
                                            n: root::octave_idx_type)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name =
              "_ZN10octave_map16fast_elem_insertEiRK17octave_scalar_map"]
        pub fn octave_map_fast_elem_insert(this: *mut root::octave_map,
                                           n: root::octave_idx_type,
                                           rhs:
                                               *const root::octave_scalar_map)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZN10octave_mapC1ERK17octave_scalar_map"]
        pub fn octave_map_octave_map(this: *mut root::octave_map,
                                     m: *const root::octave_scalar_map);
    }
    impl octave_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string)
         -> root::Cell {
            octave_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(&mut self, key: *const root::std::string,
                               val: *const root::Cell) {
            octave_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_map {
            octave_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(&self,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(&self, other: *const root::octave_map,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string)
         -> root::Cell {
            octave_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string)
         -> *mut root::Cell {
            octave_map_contents1(self, k)
        }
        #[inline]
        pub unsafe fn checkelem(&self, n: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_checkelem(self, n)
        }
        #[inline]
        pub unsafe fn checkelem1(&self, i: root::octave_idx_type,
                                 j: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_checkelem1(self, i, j)
        }
        #[inline]
        pub unsafe fn checkelem2(&self,
                                 ra_idx:
                                     *const root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_map_checkelem2(self, ra_idx)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::octave_map {
            octave_map_squeeze(self)
        }
        #[inline]
        pub unsafe fn permute(&self,
                              vec: *const root::Array<::std::os::raw::c_int>,
                              inv: bool) -> root::octave_map {
            octave_map_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::octave_map {
            octave_map_transpose(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, dv: *const root::dim_vector)
         -> root::octave_map {
            octave_map_reshape(self, dv)
        }
        #[inline]
        pub unsafe fn resize(&mut self, dv: *const root::dim_vector,
                             fill: bool) {
            octave_map_resize(self, dv, fill)
        }
        #[inline]
        pub unsafe fn cat(dim: ::std::os::raw::c_int,
                          n: root::octave_idx_type,
                          map_list: *const root::octave_scalar_map)
         -> root::octave_map {
            octave_map_cat(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn cat1(dim: ::std::os::raw::c_int,
                           n: root::octave_idx_type,
                           map_list: *const root::octave_map)
         -> root::octave_map {
            octave_map_cat1(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector,
                            resize_ok: bool) -> root::octave_map {
            octave_map_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(&self, i: *const root::idx_vector,
                             j: *const root::idx_vector, resize_ok: bool)
         -> root::octave_map {
            octave_map_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn index2(&self, ia: *const root::Array<root::idx_vector>,
                             resize_ok: bool) -> root::octave_map {
            octave_map_index2(self, ia, resize_ok)
        }
        #[inline]
        pub unsafe fn index3(&self, arg1: *const root::octave_value_list,
                             resize_ok: bool) -> root::octave_map {
            octave_map_index3(self, arg1, resize_ok)
        }
        #[inline]
        pub unsafe fn column(&self, k: root::octave_idx_type)
         -> root::octave_map {
            octave_map_column(self, k)
        }
        #[inline]
        pub unsafe fn page(&self, k: root::octave_idx_type)
         -> root::octave_map {
            octave_map_page(self, k)
        }
        #[inline]
        pub unsafe fn assign(&mut self, i: *const root::idx_vector,
                             rhs: *const root::octave_map) {
            octave_map_assign(self, i, rhs)
        }
        #[inline]
        pub unsafe fn assign1(&mut self, i: *const root::idx_vector,
                              j: *const root::idx_vector,
                              rhs: *const root::octave_map) {
            octave_map_assign1(self, i, j, rhs)
        }
        #[inline]
        pub unsafe fn assign2(&mut self,
                              ia: *const root::Array<root::idx_vector>,
                              rhs: *const root::octave_map) {
            octave_map_assign2(self, ia, rhs)
        }
        #[inline]
        pub unsafe fn assign3(&mut self, arg1: *const root::octave_value_list,
                              rhs: *const root::octave_map) {
            octave_map_assign3(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn assign4(&mut self, idx: *const root::octave_value_list,
                              k: *const root::std::string,
                              rhs: *const root::Cell) {
            octave_map_assign4(self, idx, k, rhs)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self, i: *const root::idx_vector) {
            octave_map_delete_elements(self, i)
        }
        #[inline]
        pub unsafe fn delete_elements1(&mut self, dim: ::std::os::raw::c_int,
                                       i: *const root::idx_vector) {
            octave_map_delete_elements1(self, dim, i)
        }
        #[inline]
        pub unsafe fn delete_elements2(&mut self,
                                       ia:
                                           *const root::Array<root::idx_vector>) {
            octave_map_delete_elements2(self, ia)
        }
        #[inline]
        pub unsafe fn delete_elements3(&mut self,
                                       arg1: *const root::octave_value_list) {
            octave_map_delete_elements3(self, arg1)
        }
        #[inline]
        pub unsafe fn concat(&mut self, rb: *const root::octave_map,
                             ra_idx:
                                 *const root::Array<::std::os::raw::c_int>)
         -> root::octave_map {
            octave_map_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn fast_elem_extract(&self, n: root::octave_idx_type)
         -> root::octave_scalar_map {
            octave_map_fast_elem_extract(self, n)
        }
        #[inline]
        pub unsafe fn fast_elem_insert(&mut self, n: root::octave_idx_type,
                                       rhs: *const root::octave_scalar_map)
         -> bool {
            octave_map_fast_elem_insert(self, n, rhs)
        }
        #[inline]
        pub unsafe fn new(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_map_octave_map(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_scalar_map {
        pub xkeys: root::octave_fields,
        pub xvals: root::std::vector,
    }
    pub type octave_scalar_map_const_iterator =
        root::octave_fields_const_iterator;
    pub type octave_scalar_map_iterator =
        root::octave_scalar_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_scalar_map() {
        assert_eq!(::std::mem::size_of::<octave_scalar_map>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_scalar_map )
                   ));
        assert_eq! (::std::mem::align_of::<octave_scalar_map>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_scalar_map ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_scalar_map ) ) . xkeys as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_scalar_map )
                    , "::" , stringify ! ( xkeys ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_scalar_map ) ) . xvals as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_scalar_map )
                    , "::" , stringify ! ( xvals ) ));
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map8getfieldERKSs"]
        pub fn octave_scalar_map_getfield(this:
                                              *const root::octave_scalar_map,
                                          key: *const root::std::string)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map8setfieldERKSsRK12octave_value"]
        pub fn octave_scalar_map_setfield(this: *mut root::octave_scalar_map,
                                          key: *const root::std::string,
                                          val: *const root::octave_value);
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map7rmfieldERKSs"]
        pub fn octave_scalar_map_rmfield(this: *mut root::octave_scalar_map,
                                         key: *const root::std::string);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsEv"]
        pub fn octave_scalar_map_orderfields(this:
                                                 *const root::octave_scalar_map)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsER5ArrayIiE"]
        pub fn octave_scalar_map_orderfields1(this:
                                                  *const root::octave_scalar_map,
                                              perm:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map11orderfieldsERKS_R5ArrayIiE"]
        pub fn octave_scalar_map_orderfields2(this:
                                                  *const root::octave_scalar_map,
                                              other:
                                                  *const root::octave_scalar_map,
                                              perm:
                                                  *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_scalar_map8contentsERKSs"]
        pub fn octave_scalar_map_contents(this:
                                              *const root::octave_scalar_map,
                                          k: *const root::std::string)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN17octave_scalar_map8contentsERKSs"]
        pub fn octave_scalar_map_contents1(this: *mut root::octave_scalar_map,
                                           k: *const root::std::string)
         -> *mut root::octave_value;
    }
    impl octave_scalar_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string)
         -> root::octave_value {
            octave_scalar_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(&mut self, key: *const root::std::string,
                               val: *const root::octave_value) {
            octave_scalar_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_scalar_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_scalar_map {
            octave_scalar_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(&self,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_scalar_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(&self,
                                   other: *const root::octave_scalar_map,
                                   perm:
                                       *mut root::Array<::std::os::raw::c_int>)
         -> root::octave_scalar_map {
            octave_scalar_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string)
         -> root::octave_value {
            octave_scalar_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string)
         -> *mut root::octave_value {
            octave_scalar_map_contents1(self, k)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_stream([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_function {
        pub _base: root::octave_base_value,
        pub relative: bool,
        pub locked: bool,
        pub private_function: bool,
        pub xdispatch_class: root::std::string,
        pub xpackage_name: root::std::string,
        pub my_name: root::std::string,
        pub my_dir_name: root::std::string,
        pub doc: root::std::string,
    }
    #[test]
    fn bindgen_test_layout_octave_function() {
        assert_eq!(::std::mem::size_of::<octave_function>() , 56usize , concat
                   ! ( "Size of: " , stringify ! ( octave_function ) ));
        assert_eq! (::std::mem::align_of::<octave_function>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . relative as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( relative ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . locked as *
                    const _ as usize } , 13usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( locked ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) .
                    private_function as * const _ as usize } , 14usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( private_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . xdispatch_class
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( xdispatch_class ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . xpackage_name
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( xpackage_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . my_name as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( my_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . my_dir_name as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( my_dir_name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_function ) ) . doc as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_function ) ,
                    "::" , stringify ! ( doc ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_function([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_handle([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_inline([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value_list {
        pub data: root::Array<root::octave_value>,
        pub names: root::string_vector,
    }
    #[test]
    fn bindgen_test_layout_octave_value_list() {
        assert_eq!(::std::mem::size_of::<octave_value_list>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_value_list )
                   ));
        assert_eq! (::std::mem::align_of::<octave_value_list>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_value_list ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_list ) ) . data as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value_list )
                    , "::" , stringify ! ( data ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_list ) ) . names as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value_list )
                    , "::" , stringify ! ( names ) ));
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list7prependERK12octave_value"]
        pub fn octave_value_list_prepend(this: *mut root::octave_value_list,
                                         val: *const root::octave_value)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list6appendERK12octave_value"]
        pub fn octave_value_list_append(this: *mut root::octave_value_list,
                                        val: *const root::octave_value)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list6appendERKS_"]
        pub fn octave_value_list_append1(this: *mut root::octave_value_list,
                                         lst: *const root::octave_value_list)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list7reverseEv"]
        pub fn octave_value_list_reverse(this: *mut root::octave_value_list)
         -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list6spliceEiiRKS_"]
        pub fn octave_value_list_splice(this: *const root::octave_value_list,
                                        offset: root::octave_idx_type,
                                        len: root::octave_idx_type,
                                        lst: *const root::octave_value_list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list13all_strings_pEv"]
        pub fn octave_value_list_all_strings_p(this:
                                                   *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list11all_scalarsEv"]
        pub fn octave_value_list_all_scalars(this:
                                                 *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list8any_cellEv"]
        pub fn octave_value_list_any_cell(this:
                                              *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list15has_magic_colonEv"]
        pub fn octave_value_list_has_magic_colon(this:
                                                     *const root::octave_value_list)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_value_list9make_argvERKSs"]
        pub fn octave_value_list_make_argv(this:
                                               *const root::octave_value_list,
                                           arg1: *const root::std::string)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_list20make_storable_valuesEv"]
        pub fn octave_value_list_make_storable_values(this:
                                                          *mut root::octave_value_list);
    }
    extern "C" {
        #[link_name = "_ZN17octave_value_listC1ERKSt4listIS_SaIS_EE"]
        pub fn octave_value_list_octave_value_list(this:
                                                       *mut root::octave_value_list,
                                                   arg1:
                                                       *const root::std::list);
    }
    impl octave_value_list {
        #[inline]
        pub unsafe fn prepend(&mut self, val: *const root::octave_value)
         -> *mut root::octave_value_list {
            octave_value_list_prepend(self, val)
        }
        #[inline]
        pub unsafe fn append(&mut self, val: *const root::octave_value)
         -> *mut root::octave_value_list {
            octave_value_list_append(self, val)
        }
        #[inline]
        pub unsafe fn append1(&mut self, lst: *const root::octave_value_list)
         -> *mut root::octave_value_list {
            octave_value_list_append1(self, lst)
        }
        #[inline]
        pub unsafe fn reverse(&mut self) -> *mut root::octave_value_list {
            octave_value_list_reverse(self)
        }
        #[inline]
        pub unsafe fn splice(&self, offset: root::octave_idx_type,
                             len: root::octave_idx_type,
                             lst: *const root::octave_value_list)
         -> root::octave_value_list {
            octave_value_list_splice(self, offset, len, lst)
        }
        #[inline]
        pub unsafe fn all_strings_p(&self) -> bool {
            octave_value_list_all_strings_p(self)
        }
        #[inline]
        pub unsafe fn all_scalars(&self) -> bool {
            octave_value_list_all_scalars(self)
        }
        #[inline]
        pub unsafe fn any_cell(&self) -> bool {
            octave_value_list_any_cell(self)
        }
        #[inline]
        pub unsafe fn has_magic_colon(&self) -> bool {
            octave_value_list_has_magic_colon(self)
        }
        #[inline]
        pub unsafe fn make_argv(&self, arg1: *const root::std::string)
         -> root::string_vector {
            octave_value_list_make_argv(self, arg1)
        }
        #[inline]
        pub unsafe fn make_storable_values(&mut self) {
            octave_value_list_make_storable_values(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_list_octave_value_list(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_lvalue([u8; 0]);
    pub type octave_hdf5_id = i64;
    pub type octave_hdf5_err = ::std::os::raw::c_int;
    #[repr(C)]
    pub struct octave_value__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value {
        pub vtable_: *const octave_value__bindgen_vtable,
        pub rep: *mut root::octave_base_value,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_unary_op {
        op_not = 0,
        op_uplus = 1,
        op_uminus = 2,
        op_transpose = 3,
        op_hermitian = 4,
        op_incr = 5,
        op_decr = 6,
        num_unary_ops = 7,
        unknown_unary_op = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_binary_op {
        op_add = 0,
        op_sub = 1,
        op_mul = 2,
        op_div = 3,
        op_pow = 4,
        op_ldiv = 5,
        op_lt = 6,
        op_le = 7,
        op_eq = 8,
        op_ge = 9,
        op_gt = 10,
        op_ne = 11,
        op_el_mul = 12,
        op_el_div = 13,
        op_el_pow = 14,
        op_el_ldiv = 15,
        op_el_and = 16,
        op_el_or = 17,
        op_struct_ref = 18,
        num_binary_ops = 19,
        unknown_binary_op = 20,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_compound_binary_op {
        op_trans_mul = 0,
        op_mul_trans = 1,
        op_herm_mul = 2,
        op_mul_herm = 3,
        op_trans_ldiv = 4,
        op_herm_ldiv = 5,
        op_el_not_and = 6,
        op_el_not_or = 7,
        op_el_and_not = 8,
        op_el_or_not = 9,
        num_compound_binary_ops = 10,
        unknown_compound_binary_op = 11,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_assign_op {
        op_asn_eq = 0,
        op_add_eq = 1,
        op_sub_eq = 2,
        op_mul_eq = 3,
        op_div_eq = 4,
        op_ldiv_eq = 5,
        op_pow_eq = 6,
        op_el_mul_eq = 7,
        op_el_div_eq = 8,
        op_el_ldiv_eq = 9,
        op_el_pow_eq = 10,
        op_el_and_eq = 11,
        op_el_or_eq = 12,
        num_assign_ops = 13,
        unknown_assign_op = 14,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_value_magic_colon { magic_colon_t = 0, }
    #[test]
    fn bindgen_test_layout_octave_value() {
        assert_eq!(::std::mem::size_of::<octave_value>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( octave_value ) ));
        assert_eq! (::std::mem::align_of::<octave_value>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( octave_value ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value ) ) . rep as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_value ) ,
                    "::" , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value22assign_op_to_binary_opENS_9assign_opE"]
        pub fn octave_value_assign_op_to_binary_op(arg1:
                                                       root::octave_value_assign_op)
         -> root::octave_value_binary_op;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value22binary_op_to_assign_opENS_9binary_opE"]
        pub fn octave_value_binary_op_to_assign_op(arg1:
                                                       root::octave_value_binary_op)
         -> root::octave_value_assign_op;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value18unary_op_as_stringENS_8unary_opE"]
        pub fn octave_value_unary_op_as_string(arg1:
                                                   root::octave_value_unary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value17unary_op_fcn_nameENS_8unary_opE"]
        pub fn octave_value_unary_op_fcn_name(arg1:
                                                  root::octave_value_unary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19binary_op_as_stringENS_9binary_opE"]
        pub fn octave_value_binary_op_as_string(arg1:
                                                    root::octave_value_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value18binary_op_fcn_nameENS_9binary_opE"]
        pub fn octave_value_binary_op_fcn_name(arg1:
                                                   root::octave_value_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value18binary_op_fcn_nameENS_18compound_binary_opE"]
        pub fn octave_value_binary_op_fcn_name1(arg1:
                                                    root::octave_value_compound_binary_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19assign_op_as_stringENS_9assign_opE"]
        pub fn octave_value_assign_op_as_string(arg1:
                                                    root::octave_value_assign_op)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value10empty_convERKSsRKS_"]
        pub fn octave_value_empty_conv(type_: *const root::std::string,
                                       rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value5cloneEv"]
        pub fn octave_value_clone(this: *const root::octave_value)
         -> *mut root::octave_base_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value12maybe_mutateEv"]
        pub fn octave_value_maybe_mutate(this: *mut root::octave_value);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value14single_subsrefERKSsRK17octave_value_list"]
        pub fn octave_value_single_subsref(this: *mut root::octave_value,
                                           type_: *const root::std::string,
                                           idx:
                                               *const root::octave_value_list)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value7subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEi"]
        pub fn octave_value_subsref(this: *mut root::octave_value,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list,
                                    nargout: ::std::os::raw::c_int)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value7subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEiPKS2_I13octave_lvalueSaIS8_EE"]
        pub fn octave_value_subsref1(this: *mut root::octave_value,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     nargout: ::std::os::raw::c_int,
                                     lvalue_list: *const root::std::list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefERKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref(this: *mut root::octave_value,
                                         type_: *const root::std::string,
                                         idx: *const root::std::list,
                                         skip: usize) -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEiRKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref1(this: *mut root::octave_value,
                                          nargout: ::std::os::raw::c_int,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          skip: usize)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEiRKSsRKSt4listI17octave_value_listSaIS3_EEPKS2_I13octave_lvalueSaIS8_EEy"]
        pub fn octave_value_next_subsref2(this: *mut root::octave_value,
                                          nargout: ::std::os::raw::c_int,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          lvalue_list: *const root::std::list,
                                          skip: usize)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value12next_subsrefEbRKSsRKSt4listI17octave_value_listSaIS3_EEy"]
        pub fn octave_value_next_subsref3(this: *mut root::octave_value,
                                          auto_add: bool,
                                          type_: *const root::std::string,
                                          idx: *const root::std::list,
                                          skip: usize) -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value17do_multi_index_opEiRK17octave_value_list"]
        pub fn octave_value_do_multi_index_op(this: *mut root::octave_value,
                                              nargout: ::std::os::raw::c_int,
                                              idx:
                                                  *const root::octave_value_list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value17do_multi_index_opEiRK17octave_value_listPKSt4listI13octave_lvalueSaIS4_EE"]
        pub fn octave_value_do_multi_index_op1(this: *mut root::octave_value,
                                               nargout: ::std::os::raw::c_int,
                                               idx:
                                                   *const root::octave_value_list,
                                               lvalue_list:
                                                   *const root::std::list)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value8subsasgnERKSsRKSt4listI17octave_value_listSaIS3_EERKS_"]
        pub fn octave_value_subsasgn(this: *mut root::octave_value,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value14undef_subsasgnERKSsRKSt4listI17octave_value_listSaIS3_EERKS_"]
        pub fn octave_value_undef_subsasgn(this: *mut root::octave_value,
                                           type_: *const root::std::string,
                                           idx: *const root::std::list,
                                           rhs: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value6assignENS_9assign_opERKSsRKSt4listI17octave_value_listSaIS4_EERKS_"]
        pub fn octave_value_assign(this: *mut root::octave_value,
                                   op: root::octave_value_assign_op,
                                   type_: *const root::std::string,
                                   idx: *const root::std::list,
                                   rhs: *const root::octave_value)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value6assignENS_9assign_opERKS_"]
        pub fn octave_value_assign1(this: *mut root::octave_value,
                                    arg1: root::octave_value_assign_op,
                                    rhs: *const root::octave_value)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value6lengthEv"]
        pub fn octave_value_length(this: *const root::octave_value)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value8is_equalERKS_"]
        pub fn octave_value_is_equal(this: *const root::octave_value,
                                     arg1: *const root::octave_value) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14idx_type_valueEbb"]
        pub fn octave_value_idx_type_value(this: *const root::octave_value,
                                           req_int: bool, frc_str_conv: bool)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10cell_valueEv"]
        pub fn octave_value_cell_value(this: *const root::octave_value)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value9map_valueEv"]
        pub fn octave_value_map_value(this: *const root::octave_value)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16scalar_map_valueEv"]
        pub fn octave_value_scalar_map_value(this: *const root::octave_value)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14function_valueEb"]
        pub fn octave_value_function_value(this: *const root::octave_value,
                                           silent: bool)
         -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19user_function_valueEb"]
        pub fn octave_value_user_function_value(this:
                                                    *const root::octave_value,
                                                silent: bool)
         -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17user_script_valueEb"]
        pub fn octave_value_user_script_value(this: *const root::octave_value,
                                              silent: bool)
         -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15user_code_valueEb"]
        pub fn octave_value_user_code_value(this: *const root::octave_value,
                                            silent: bool)
         -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16fcn_handle_valueEb"]
        pub fn octave_value_fcn_handle_value(this: *const root::octave_value,
                                             silent: bool)
         -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16fcn_inline_valueEb"]
        pub fn octave_value_fcn_inline_value(this: *const root::octave_value,
                                             silent: bool)
         -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10list_valueEv"]
        pub fn octave_value_list_value(this: *const root::octave_value)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19column_vector_valueEbb"]
        pub fn octave_value_column_vector_value(this:
                                                    *const root::octave_value,
                                                frc_str_conv: bool,
                                                frc_vec_conv: bool)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27complex_column_vector_valueEbb"]
        pub fn octave_value_complex_column_vector_value(this:
                                                            *const root::octave_value,
                                                        frc_str_conv: bool,
                                                        frc_vec_conv: bool)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16row_vector_valueEbb"]
        pub fn octave_value_row_vector_value(this: *const root::octave_value,
                                             frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value24complex_row_vector_valueEbb"]
        pub fn octave_value_complex_row_vector_value(this:
                                                         *const root::octave_value,
                                                     frc_str_conv: bool,
                                                     frc_vec_conv: bool)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25float_column_vector_valueEbb"]
        pub fn octave_value_float_column_vector_value(this:
                                                          *const root::octave_value,
                                                      frc_str_conv: bool,
                                                      frc_vec_conv: bool)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value33float_complex_column_vector_valueEbb"]
        pub fn octave_value_float_complex_column_vector_value(this:
                                                                  *const root::octave_value,
                                                              frc_str_conv:
                                                                  bool,
                                                              frc_vec_conv:
                                                                  bool)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value22float_row_vector_valueEbb"]
        pub fn octave_value_float_row_vector_value(this:
                                                       *const root::octave_value,
                                                   frc_str_conv: bool,
                                                   frc_vec_conv: bool)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value30float_complex_row_vector_valueEbb"]
        pub fn octave_value_float_complex_row_vector_value(this:
                                                               *const root::octave_value,
                                                           frc_str_conv: bool,
                                                           frc_vec_conv: bool)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16int_vector_valueEbbb"]
        pub fn octave_value_int_vector_value(this: *const root::octave_value,
                                             req_int: bool,
                                             frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28octave_idx_type_vector_valueEbbb"]
        pub fn octave_value_octave_idx_type_vector_value(this:
                                                             *const root::octave_value,
                                                         req_int: bool,
                                                         frc_str_conv: bool,
                                                         frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12vector_valueEbb"]
        pub fn octave_value_vector_value(this: *const root::octave_value,
                                         frc_str_conv: bool,
                                         frc_vec_conv: bool)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20complex_vector_valueEbb"]
        pub fn octave_value_complex_vector_value(this:
                                                     *const root::octave_value,
                                                 frc_str_conv: bool,
                                                 frc_vec_conv: bool)
         -> root::Array<root::std::complex<f64>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18float_vector_valueEbb"]
        pub fn octave_value_float_vector_value(this:
                                                   *const root::octave_value,
                                               frc_str_conv: bool,
                                               frc_vec_conv: bool)
         -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26float_complex_vector_valueEbb"]
        pub fn octave_value_float_complex_vector_value(this:
                                                           *const root::octave_value,
                                                       frc_str_conv: bool,
                                                       frc_vec_conv: bool)
         -> root::Array<root::std::complex<f32>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xshort_valueEPKcz"]
        pub fn octave_value_xshort_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_short;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xushort_valueEPKcz"]
        pub fn octave_value_xushort_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_ushort;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10xint_valueEPKcz"]
        pub fn octave_value_xint_value(this: *const root::octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xuint_valueEPKcz"]
        pub fn octave_value_xuint_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xnint_valueEPKcz"]
        pub fn octave_value_xnint_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xlong_valueEPKcz"]
        pub fn octave_value_xlong_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xulong_valueEPKcz"]
        pub fn octave_value_xulong_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xint64_valueEPKcz"]
        pub fn octave_value_xint64_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> i64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xuint64_valueEPKcz"]
        pub fn octave_value_xuint64_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> u64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15xidx_type_valueEPKcz"]
        pub fn octave_value_xidx_type_value(this: *const root::octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xdouble_valueEPKcz"]
        pub fn octave_value_xdouble_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xfloat_valueEPKcz"]
        pub fn octave_value_xfloat_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xscalar_valueEPKcz"]
        pub fn octave_value_xscalar_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> f64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_scalar_valueEPKcz"]
        pub fn octave_value_xfloat_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> f32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xmatrix_valueEPKcz"]
        pub fn octave_value_xmatrix_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::Matrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_matrix_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xarray_valueEPKcz"]
        pub fn octave_value_xarray_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> root::NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xfloat_array_valueEPKcz"]
        pub fn octave_value_xfloat_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14xcomplex_valueEPKcz"]
        pub fn octave_value_xcomplex_value(this: *const root::octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
         -> root::Complex;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xfloat_complex_valueEPKcz"]
        pub fn octave_value_xfloat_complex_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value21xcomplex_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_matrix_value(this:
                                                      *const root::octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
         -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27xfloat_complex_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_matrix_value(this:
                                                            *const root::octave_value,
                                                        fmt:
                                                            *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xcomplex_array_valueEPKcz"]
        pub fn octave_value_xcomplex_array_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xfloat_complex_array_valueEPKcz"]
        pub fn octave_value_xfloat_complex_array_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xbool_valueEPKcz"]
        pub fn octave_value_xbool_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xbool_matrix_valueEPKcz"]
        pub fn octave_value_xbool_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xbool_array_valueEPKcz"]
        pub fn octave_value_xbool_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xchar_matrix_valueEPKcz"]
        pub fn octave_value_xchar_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::charMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xchar_array_valueEPKcz"]
        pub fn octave_value_xchar_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xsparse_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_matrix_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28xsparse_complex_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_complex_matrix_value(this:
                                                             *const root::octave_value,
                                                         fmt:
                                                             *const ::std::os::raw::c_char, ...)
         -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25xsparse_bool_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_bool_matrix_value(this:
                                                          *const root::octave_value,
                                                      fmt:
                                                          *const ::std::os::raw::c_char, ...)
         -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xdiag_matrix_valueEPKcz"]
        pub fn octave_value_xdiag_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value24xfloat_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_diag_matrix_value(this:
                                                         *const root::octave_value,
                                                     fmt:
                                                         *const ::std::os::raw::c_char, ...)
         -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xcomplex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_diag_matrix_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value32xfloat_complex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_diag_matrix_value(this:
                                                                 *const root::octave_value,
                                                             fmt:
                                                                 *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xperm_matrix_valueEPKcz"]
        pub fn octave_value_xperm_matrix_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint8_scalar_valueEPKcz"]
        pub fn octave_value_xint8_scalar_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::octave_int8;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint16_scalar_valueEPKcz"]
        pub fn octave_value_xint16_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int16;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint32_scalar_valueEPKcz"]
        pub fn octave_value_xint32_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xint64_scalar_valueEPKcz"]
        pub fn octave_value_xint64_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_int64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint8_scalar_valueEPKcz"]
        pub fn octave_value_xuint8_scalar_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::octave_uint8;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint16_scalar_valueEPKcz"]
        pub fn octave_value_xuint16_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint16;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint32_scalar_valueEPKcz"]
        pub fn octave_value_xuint32_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint32;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuint64_scalar_valueEPKcz"]
        pub fn octave_value_xuint64_scalar_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::octave_uint64;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xint8_array_valueEPKcz"]
        pub fn octave_value_xint8_array_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::int8NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint16_array_valueEPKcz"]
        pub fn octave_value_xint16_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int16NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint32_array_valueEPKcz"]
        pub fn octave_value_xint32_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int32NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xint64_array_valueEPKcz"]
        pub fn octave_value_xint64_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::int64NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xuint8_array_valueEPKcz"]
        pub fn octave_value_xuint8_array_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> root::uint8NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint16_array_valueEPKcz"]
        pub fn octave_value_xuint16_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint16NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint32_array_valueEPKcz"]
        pub fn octave_value_xuint32_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint32NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xuint64_array_valueEPKcz"]
        pub fn octave_value_xuint64_array_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::uint64NDArray;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xstring_valueEPKcz"]
        pub fn octave_value_xstring_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::std::string;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xstring_vector_valueEPKcz"]
        pub fn octave_value_xstring_vector_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xcell_valueEPKcz"]
        pub fn octave_value_xcell_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> root::Cell;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14xcellstr_valueEPKcz"]
        pub fn octave_value_xcellstr_value(this: *const root::octave_value,
                                           fmt:
                                               *const ::std::os::raw::c_char, ...)
         ->
             root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                 root::std::allocator>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value12xrange_valueEPKcz"]
        pub fn octave_value_xrange_value(this: *const root::octave_value,
                                         fmt:
                                             *const ::std::os::raw::c_char, ...)
         -> root::Range;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10xmap_valueEPKcz"]
        pub fn octave_value_xmap_value(this: *const root::octave_value,
                                       fmt:
                                           *const ::std::os::raw::c_char, ...)
         -> root::octave_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xscalar_map_valueEPKcz"]
        pub fn octave_value_xscalar_map_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xcolumn_vector_valueEPKcz"]
        pub fn octave_value_xcolumn_vector_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value28xcomplex_column_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_column_vector_value(this:
                                                             *const root::octave_value,
                                                         fmt:
                                                             *const ::std::os::raw::c_char, ...)
         -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xrow_vector_valueEPKcz"]
        pub fn octave_value_xrow_vector_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::RowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value25xcomplex_row_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_row_vector_value(this:
                                                          *const root::octave_value,
                                                      fmt:
                                                          *const ::std::os::raw::c_char, ...)
         -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value26xfloat_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_column_vector_value(this:
                                                           *const root::octave_value,
                                                       fmt:
                                                           *const ::std::os::raw::c_char, ...)
         -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value34xfloat_complex_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_column_vector_value(this:
                                                                   *const root::octave_value,
                                                               fmt:
                                                                   *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value23xfloat_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_row_vector_value(this:
                                                        *const root::octave_value,
                                                    fmt:
                                                        *const ::std::os::raw::c_char, ...)
         -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value31xfloat_complex_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_row_vector_value(this:
                                                                *const root::octave_value,
                                                            fmt:
                                                                *const ::std::os::raw::c_char, ...)
         -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xint_vector_valueEPKcz"]
        pub fn octave_value_xint_vector_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value29xoctave_idx_type_vector_valueEPKcz"]
        pub fn octave_value_xoctave_idx_type_vector_value(this:
                                                              *const root::octave_value,
                                                          fmt:
                                                              *const ::std::os::raw::c_char, ...)
         -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value13xvector_valueEPKcz"]
        pub fn octave_value_xvector_value(this: *const root::octave_value,
                                          fmt:
                                              *const ::std::os::raw::c_char, ...)
         -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value21xcomplex_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_vector_value(this:
                                                      *const root::octave_value,
                                                  fmt:
                                                      *const ::std::os::raw::c_char, ...)
         -> root::Array<root::std::complex<f64>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value19xfloat_vector_valueEPKcz"]
        pub fn octave_value_xfloat_vector_value(this:
                                                    *const root::octave_value,
                                                fmt:
                                                    *const ::std::os::raw::c_char, ...)
         -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value27xfloat_complex_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_vector_value(this:
                                                            *const root::octave_value,
                                                        fmt:
                                                            *const ::std::os::raw::c_char, ...)
         -> root::Array<root::std::complex<f32>>;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value15xfunction_valueEPKcz"]
        pub fn octave_value_xfunction_value(this: *const root::octave_value,
                                            fmt:
                                                *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value20xuser_function_valueEPKcz"]
        pub fn octave_value_xuser_function_value(this:
                                                     *const root::octave_value,
                                                 fmt:
                                                     *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value18xuser_script_valueEPKcz"]
        pub fn octave_value_xuser_script_value(this:
                                                   *const root::octave_value,
                                               fmt:
                                                   *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value16xuser_code_valueEPKcz"]
        pub fn octave_value_xuser_code_value(this: *const root::octave_value,
                                             fmt:
                                                 *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xfcn_handle_valueEPKcz"]
        pub fn octave_value_xfcn_handle_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value17xfcn_inline_valueEPKcz"]
        pub fn octave_value_xfcn_inline_value(this: *const root::octave_value,
                                              fmt:
                                                  *const ::std::os::raw::c_char, ...)
         -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value11xlist_valueEPKcz"]
        pub fn octave_value_xlist_value(this: *const root::octave_value,
                                        fmt:
                                            *const ::std::os::raw::c_char, ...)
         -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value14storable_valueEv"]
        pub fn octave_value_storable_value(this: *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZN12octave_value19make_storable_valueEv"]
        pub fn octave_value_make_storable_value(this:
                                                    *mut root::octave_value);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value21do_non_const_unary_opENS_8unary_opE"]
        pub fn octave_value_do_non_const_unary_op(this:
                                                      *mut root::octave_value,
                                                  op:
                                                      root::octave_value_unary_op)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_value21do_non_const_unary_opENS_8unary_opERKSsRKSt4listI17octave_value_listSaIS4_EE"]
        pub fn octave_value_do_non_const_unary_op1(this:
                                                       *mut root::octave_value,
                                                   op:
                                                       root::octave_value_unary_op,
                                                   type_:
                                                       *const root::std::string,
                                                   idx:
                                                       *const root::std::list)
         -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK12octave_value10print_infoERSoRKSs"]
        pub fn octave_value_print_info(this: *const root::octave_value,
                                       os: *mut root::std::ostream,
                                       prefix: *const root::std::string);
    }
    extern "C" {
        #[link_name =
              "_ZNK12octave_value5writeER13octave_streamiN13oct_data_conv9data_typeEiN6octave9mach_info12float_formatE"]
        pub fn octave_value_write(this: *const root::octave_value,
                                  os: *mut root::octave_stream,
                                  block_size: ::std::os::raw::c_int,
                                  output_type: root::oct_data_conv_data_type,
                                  skip: ::std::os::raw::c_int,
                                  flt_fmt:
                                      root::octave::mach_info_float_format)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Es"]
        pub fn octave_value_octave_value(this: *mut root::octave_value,
                                         i: ::std::os::raw::c_short);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Et"]
        pub fn octave_value_octave_value1(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ushort);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ei"]
        pub fn octave_value_octave_value2(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ej"]
        pub fn octave_value_octave_value3(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1El"]
        pub fn octave_value_octave_value4(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Em"]
        pub fn octave_value_octave_value5(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ulong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ex"]
        pub fn octave_value_octave_value6(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_longlong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ey"]
        pub fn octave_value_octave_value7(this: *mut root::octave_value,
                                          i: ::std::os::raw::c_ulonglong);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EN6octave3sys4timeE"]
        pub fn octave_value_octave_value8(this: *mut root::octave_value,
                                          t: root::octave::sys::time);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ed"]
        pub fn octave_value_octave_value9(this: *mut root::octave_value,
                                          d: f64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ef"]
        pub fn octave_value_octave_value10(this: *mut root::octave_value,
                                           d: f32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIS_Eb"]
        pub fn octave_value_octave_value11(this: *mut root::octave_value,
                                           a:
                                               *const root::Array<root::octave_value>,
                                           is_cs_list: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK4Cellb"]
        pub fn octave_value_octave_value12(this: *mut root::octave_value,
                                           c: *const root::Cell,
                                           is_cs_list: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6MatrixRK10MatrixType"]
        pub fn octave_value_octave_value13(this: *mut root::octave_value,
                                           m: *const root::Matrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11FloatMatrixRK10MatrixType"]
        pub fn octave_value_octave_value14(this: *mut root::octave_value,
                                           m: *const root::FloatMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK7NDArray"]
        pub fn octave_value_octave_value15(this: *mut root::octave_value,
                                           nda: *const root::NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12FloatNDArray"]
        pub fn octave_value_octave_value16(this: *mut root::octave_value,
                                           nda: *const root::FloatNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIdE"]
        pub fn octave_value_octave_value17(this: *mut root::octave_value,
                                           m: *const root::Array<f64>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIfE"]
        pub fn octave_value_octave_value18(this: *mut root::octave_value,
                                           m: *const root::Array<f32>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagMatrix"]
        pub fn octave_value_octave_value19(this: *mut root::octave_value,
                                           d: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2IdE"]
        pub fn octave_value_octave_value20(this: *mut root::octave_value,
                                           d: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2IfE"]
        pub fn octave_value_octave_value21(this: *mut root::octave_value,
                                           d: *const root::DiagArray2<f32>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn octave_value_octave_value22(this: *mut root::octave_value,
                                           d:
                                               *const root::DiagArray2<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn octave_value_octave_value23(this: *mut root::octave_value,
                                           d:
                                               *const root::DiagArray2<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK15FloatDiagMatrix"]
        pub fn octave_value_octave_value24(this: *mut root::octave_value,
                                           d: *const root::FloatDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK9RowVector"]
        pub fn octave_value_octave_value25(this: *mut root::octave_value,
                                           v: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK14FloatRowVector"]
        pub fn octave_value_octave_value26(this: *mut root::octave_value,
                                           v: *const root::FloatRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12ColumnVector"]
        pub fn octave_value_octave_value27(this: *mut root::octave_value,
                                           v: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17FloatColumnVector"]
        pub fn octave_value_octave_value28(this: *mut root::octave_value,
                                           v: *const root::FloatColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSt7complexIdE"]
        pub fn octave_value_octave_value29(this: *mut root::octave_value,
                                           C: *const root::Complex);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSt7complexIfE"]
        pub fn octave_value_octave_value30(this: *mut root::octave_value,
                                           C: *const root::FloatComplex);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK13ComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value31(this: *mut root::octave_value,
                                           m: *const root::ComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK18FloatComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value32(this: *mut root::octave_value,
                                           m: *const root::FloatComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK14ComplexNDArray"]
        pub fn octave_value_octave_value33(this: *mut root::octave_value,
                                           cnda: *const root::ComplexNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK19FloatComplexNDArray"]
        pub fn octave_value_octave_value34(this: *mut root::octave_value,
                                           cnda:
                                               *const root::FloatComplexNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISt7complexIdEE"]
        pub fn octave_value_octave_value35(this: *mut root::octave_value,
                                           m:
                                               *const root::Array<root::std::complex<f64>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISt7complexIfEE"]
        pub fn octave_value_octave_value36(this: *mut root::octave_value,
                                           m:
                                               *const root::Array<root::std::complex<f32>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17ComplexDiagMatrix"]
        pub fn octave_value_octave_value37(this: *mut root::octave_value,
                                           d: *const root::ComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK22FloatComplexDiagMatrix"]
        pub fn octave_value_octave_value38(this: *mut root::octave_value,
                                           d:
                                               *const root::FloatComplexDiagMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK16ComplexRowVector"]
        pub fn octave_value_octave_value39(this: *mut root::octave_value,
                                           v: *const root::ComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK21FloatComplexRowVector"]
        pub fn octave_value_octave_value40(this: *mut root::octave_value,
                                           v:
                                               *const root::FloatComplexRowVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK19ComplexColumnVector"]
        pub fn octave_value_octave_value41(this: *mut root::octave_value,
                                           v:
                                               *const root::ComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK24FloatComplexColumnVector"]
        pub fn octave_value_octave_value42(this: *mut root::octave_value,
                                           v:
                                               *const root::FloatComplexColumnVector);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10PermMatrix"]
        pub fn octave_value_octave_value43(this: *mut root::octave_value,
                                           p: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Eb"]
        pub fn octave_value_octave_value44(this: *mut root::octave_value,
                                           b: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10boolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value45(this: *mut root::octave_value,
                                           bm: *const root::boolMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11boolNDArray"]
        pub fn octave_value_octave_value46(this: *mut root::octave_value,
                                           bnda: *const root::boolNDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIbE"]
        pub fn octave_value_octave_value47(this: *mut root::octave_value,
                                           bnda: *const root::Array<bool>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Ecc"]
        pub fn octave_value_octave_value48(this: *mut root::octave_value,
                                           c: ::std::os::raw::c_char,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EPKcc"]
        pub fn octave_value_octave_value49(this: *mut root::octave_value,
                                           s: *const ::std::os::raw::c_char,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERKSsc"]
        pub fn octave_value_octave_value50(this: *mut root::octave_value,
                                           s: *const root::std::string,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK13string_vectorc"]
        pub fn octave_value_octave_value51(this: *mut root::octave_value,
                                           s: *const root::string_vector,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10charMatrixc"]
        pub fn octave_value_octave_value52(this: *mut root::octave_value,
                                           chm: *const root::charMatrix,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11charNDArrayc"]
        pub fn octave_value_octave_value53(this: *mut root::octave_value,
                                           chnda: *const root::charNDArray,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIcEc"]
        pub fn octave_value_octave_value54(this: *mut root::octave_value,
                                           chnda:
                                               *const root::Array<::std::os::raw::c_char>,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10charMatrixbc"]
        pub fn octave_value_octave_value55(this: *mut root::octave_value,
                                           chm: *const root::charMatrix,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK11charNDArraybc"]
        pub fn octave_value_octave_value56(this: *mut root::octave_value,
                                           chnda: *const root::charNDArray,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIcEbc"]
        pub fn octave_value_octave_value57(this: *mut root::octave_value,
                                           chnda:
                                               *const root::Array<::std::os::raw::c_char>,
                                           is_string: bool,
                                           type_: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK12SparseMatrixRK10MatrixType"]
        pub fn octave_value_octave_value58(this: *mut root::octave_value,
                                           m: *const root::SparseMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6SparseIdERK10MatrixType"]
        pub fn octave_value_octave_value59(this: *mut root::octave_value,
                                           m: *const root::Sparse<f64>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK19SparseComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value60(this: *mut root::octave_value,
                                           m:
                                               *const root::SparseComplexMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK6SparseISt7complexIdEERK10MatrixType"]
        pub fn octave_value_octave_value61(this: *mut root::octave_value,
                                           m:
                                               *const root::Sparse<root::std::complex<f64>>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK16SparseBoolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value62(this: *mut root::octave_value,
                                           bm: *const root::SparseBoolMatrix,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK6SparseIbERK10MatrixType"]
        pub fn octave_value_octave_value63(this: *mut root::octave_value,
                                           m: *const root::Sparse<bool>,
                                           t: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIaE"]
        pub fn octave_value_octave_value64(this: *mut root::octave_value,
                                           i: *const root::octave_int8);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIsE"]
        pub fn octave_value_octave_value65(this: *mut root::octave_value,
                                           i: *const root::octave_int16);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIiE"]
        pub fn octave_value_octave_value66(this: *mut root::octave_value,
                                           i: *const root::octave_int32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIxE"]
        pub fn octave_value_octave_value67(this: *mut root::octave_value,
                                           i: *const root::octave_int64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIhE"]
        pub fn octave_value_octave_value68(this: *mut root::octave_value,
                                           i: *const root::octave_uint8);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intItE"]
        pub fn octave_value_octave_value69(this: *mut root::octave_value,
                                           i: *const root::octave_uint16);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIjE"]
        pub fn octave_value_octave_value70(this: *mut root::octave_value,
                                           i: *const root::octave_uint32);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_intIyE"]
        pub fn octave_value_octave_value71(this: *mut root::octave_value,
                                           i: *const root::octave_uint64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value72(this: *mut root::octave_value,
                                           inda: *const root::int8NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value73(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_schar>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value74(this: *mut root::octave_value,
                                           inda: *const root::int16NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value75(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_short>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value76(this: *mut root::octave_value,
                                           inda: *const root::int32NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value77(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_int>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIxEE"]
        pub fn octave_value_octave_value78(this: *mut root::octave_value,
                                           inda: *const root::int64NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIxEE"]
        pub fn octave_value_octave_value79(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_longlong>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value80(this: *mut root::octave_value,
                                           inda: *const root::uint8NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value81(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_uchar>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intItEE"]
        pub fn octave_value_octave_value82(this: *mut root::octave_value,
                                           inda: *const root::uint16NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intItEE"]
        pub fn octave_value_octave_value83(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_ushort>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value84(this: *mut root::octave_value,
                                           inda: *const root::uint32NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value85(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_uint>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10intNDArrayI10octave_intIyEE"]
        pub fn octave_value_octave_value86(this: *mut root::octave_value,
                                           inda: *const root::uint64NDArray);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayI10octave_intIyEE"]
        pub fn octave_value_octave_value87(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<root::octave_int<::std::os::raw::c_ulonglong>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayIiEbb"]
        pub fn octave_value_octave_value88(this: *mut root::octave_value,
                                           inda:
                                               *const root::Array<::std::os::raw::c_int>,
                                           zero_based: bool,
                                           cache_index: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5ArrayISsE"]
        pub fn octave_value_octave_value89(this: *mut root::octave_value,
                                           cellstr:
                                               *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                                          root::std::allocator>>);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10idx_vectorb"]
        pub fn octave_value_octave_value90(this: *mut root::octave_value,
                                           idx: *const root::idx_vector,
                                           lazy: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1Eddd"]
        pub fn octave_value_octave_value91(this: *mut root::octave_value,
                                           base: f64, limit: f64, inc: f64);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK5Rangeb"]
        pub fn octave_value_octave_value92(this: *mut root::octave_value,
                                           r: *const root::Range,
                                           force_range: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK10octave_map"]
        pub fn octave_value_octave_value93(this: *mut root::octave_value,
                                           m: *const root::octave_map);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17octave_scalar_map"]
        pub fn octave_value_octave_value94(this: *mut root::octave_value,
                                           m: *const root::octave_scalar_map);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK10octave_mapRKSsRKSt4listISsSaISsEE"]
        pub fn octave_value_octave_value95(this: *mut root::octave_value,
                                           m: *const root::octave_map,
                                           id: *const root::std::string,
                                           plist: *const root::std::list);
    }
    extern "C" {
        #[link_name =
              "_ZN12octave_valueC1ERK17octave_scalar_mapRKSsRKSt4listISsSaISsEE"]
        pub fn octave_value_octave_value96(this: *mut root::octave_value,
                                           m: *const root::octave_scalar_map,
                                           id: *const root::std::string,
                                           plist: *const root::std::list);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ERK17octave_value_listb"]
        pub fn octave_value_octave_value97(this: *mut root::octave_value,
                                           m: *const root::octave_value_list,
                                           arg1: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1ENS_11magic_colonE"]
        pub fn octave_value_octave_value98(this: *mut root::octave_value,
                                           arg1:
                                               root::octave_value_magic_colon);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EP17octave_base_valueb"]
        pub fn octave_value_octave_value99(this: *mut root::octave_value,
                                           new_rep:
                                               *mut root::octave_base_value,
                                           borrow: bool);
    }
    extern "C" {
        #[link_name = "_ZN12octave_valueC1EP17octave_base_valuei"]
        pub fn octave_value_octave_value100(this: *mut root::octave_value,
                                            new_rep:
                                                *mut root::octave_base_value,
                                            xcount: ::std::os::raw::c_int);
    }
    impl octave_value {
        #[inline]
        pub unsafe fn assign_op_to_binary_op(arg1:
                                                 root::octave_value_assign_op)
         -> root::octave_value_binary_op {
            octave_value_assign_op_to_binary_op(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_to_assign_op(arg1:
                                                 root::octave_value_binary_op)
         -> root::octave_value_assign_op {
            octave_value_binary_op_to_assign_op(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_as_string(arg1: root::octave_value_unary_op)
         -> root::std::string {
            octave_value_unary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_fcn_name(arg1: root::octave_value_unary_op)
         -> root::std::string {
            octave_value_unary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_as_string(arg1: root::octave_value_binary_op)
         -> root::std::string {
            octave_value_binary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name(arg1: root::octave_value_binary_op)
         -> root::std::string {
            octave_value_binary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name1(arg1:
                                              root::octave_value_compound_binary_op)
         -> root::std::string {
            octave_value_binary_op_fcn_name1(arg1)
        }
        #[inline]
        pub unsafe fn assign_op_as_string(arg1: root::octave_value_assign_op)
         -> root::std::string {
            octave_value_assign_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn empty_conv(type_: *const root::std::string,
                                 rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_empty_conv(type_, rhs)
        }
        #[inline]
        pub unsafe fn clone(&self) -> *mut root::octave_base_value {
            octave_value_clone(self)
        }
        #[inline]
        pub unsafe fn maybe_mutate(&mut self) {
            octave_value_maybe_mutate(self)
        }
        #[inline]
        pub unsafe fn single_subsref(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::octave_value_list)
         -> root::octave_value {
            octave_value_single_subsref(self, type_, idx)
        }
        #[inline]
        pub unsafe fn subsref(&mut self, type_: *const root::std::string,
                              idx: *const root::std::list,
                              nargout: ::std::os::raw::c_int)
         -> root::octave_value_list {
            octave_value_subsref(self, type_, idx, nargout)
        }
        #[inline]
        pub unsafe fn subsref1(&mut self, type_: *const root::std::string,
                               idx: *const root::std::list,
                               nargout: ::std::os::raw::c_int,
                               lvalue_list: *const root::std::list)
         -> root::octave_value_list {
            octave_value_subsref1(self, type_, idx, nargout, lvalue_list)
        }
        #[inline]
        pub unsafe fn next_subsref(&mut self, type_: *const root::std::string,
                                   idx: *const root::std::list, skip: usize)
         -> root::octave_value {
            octave_value_next_subsref(self, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref1(&mut self, nargout: ::std::os::raw::c_int,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list, skip: usize)
         -> root::octave_value_list {
            octave_value_next_subsref1(self, nargout, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref2(&mut self, nargout: ::std::os::raw::c_int,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list,
                                    lvalue_list: *const root::std::list,
                                    skip: usize) -> root::octave_value_list {
            octave_value_next_subsref2(self, nargout, type_, idx, lvalue_list,
                                       skip)
        }
        #[inline]
        pub unsafe fn next_subsref3(&mut self, auto_add: bool,
                                    type_: *const root::std::string,
                                    idx: *const root::std::list, skip: usize)
         -> root::octave_value {
            octave_value_next_subsref3(self, auto_add, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn do_multi_index_op(&mut self,
                                        nargout: ::std::os::raw::c_int,
                                        idx: *const root::octave_value_list)
         -> root::octave_value_list {
            octave_value_do_multi_index_op(self, nargout, idx)
        }
        #[inline]
        pub unsafe fn do_multi_index_op1(&mut self,
                                         nargout: ::std::os::raw::c_int,
                                         idx: *const root::octave_value_list,
                                         lvalue_list: *const root::std::list)
         -> root::octave_value_list {
            octave_value_do_multi_index_op1(self, nargout, idx, lvalue_list)
        }
        #[inline]
        pub unsafe fn subsasgn(&mut self, type_: *const root::std::string,
                               idx: *const root::std::list,
                               rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn undef_subsasgn(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value {
            octave_value_undef_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign(&mut self, op: root::octave_value_assign_op,
                             type_: *const root::std::string,
                             idx: *const root::std::list,
                             rhs: *const root::octave_value)
         -> *mut root::octave_value {
            octave_value_assign(self, op, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign1(&mut self, arg1: root::octave_value_assign_op,
                              rhs: *const root::octave_value)
         -> *mut root::octave_value {
            octave_value_assign1(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn length(&self) -> root::octave_idx_type {
            octave_value_length(self)
        }
        #[inline]
        pub unsafe fn is_equal(&self, arg1: *const root::octave_value)
         -> bool {
            octave_value_is_equal(self, arg1)
        }
        #[inline]
        pub unsafe fn idx_type_value(&self, req_int: bool, frc_str_conv: bool)
         -> root::octave_idx_type {
            octave_value_idx_type_value(self, req_int, frc_str_conv)
        }
        #[inline]
        pub unsafe fn cell_value(&self) -> root::Cell {
            octave_value_cell_value(self)
        }
        #[inline]
        pub unsafe fn map_value(&self) -> root::octave_map {
            octave_value_map_value(self)
        }
        #[inline]
        pub unsafe fn scalar_map_value(&self) -> root::octave_scalar_map {
            octave_value_scalar_map_value(self)
        }
        #[inline]
        pub unsafe fn function_value(&self, silent: bool)
         -> *mut root::octave_function {
            octave_value_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_function_value(&self, silent: bool)
         -> *mut root::octave_user_function {
            octave_value_user_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_script_value(&self, silent: bool)
         -> *mut root::octave_user_script {
            octave_value_user_script_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_code_value(&self, silent: bool)
         -> *mut root::octave_user_code {
            octave_value_user_code_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_handle_value(&self, silent: bool)
         -> *mut root::octave_fcn_handle {
            octave_value_fcn_handle_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_inline_value(&self, silent: bool)
         -> *mut root::octave_fcn_inline {
            octave_value_fcn_inline_value(self, silent)
        }
        #[inline]
        pub unsafe fn list_value(&self) -> root::octave_value_list {
            octave_value_list_value(self)
        }
        #[inline]
        pub unsafe fn column_vector_value(&self, frc_str_conv: bool,
                                          frc_vec_conv: bool)
         -> root::ColumnVector {
            octave_value_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_column_vector_value(&self, frc_str_conv: bool,
                                                  frc_vec_conv: bool)
         -> root::ComplexColumnVector {
            octave_value_complex_column_vector_value(self, frc_str_conv,
                                                     frc_vec_conv)
        }
        #[inline]
        pub unsafe fn row_vector_value(&self, frc_str_conv: bool,
                                       frc_vec_conv: bool)
         -> root::RowVector {
            octave_value_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_row_vector_value(&self, frc_str_conv: bool,
                                               frc_vec_conv: bool)
         -> root::ComplexRowVector {
            octave_value_complex_row_vector_value(self, frc_str_conv,
                                                  frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_column_vector_value(&self, frc_str_conv: bool,
                                                frc_vec_conv: bool)
         -> root::FloatColumnVector {
            octave_value_float_column_vector_value(self, frc_str_conv,
                                                   frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_column_vector_value(&self,
                                                        frc_str_conv: bool,
                                                        frc_vec_conv: bool)
         -> root::FloatComplexColumnVector {
            octave_value_float_complex_column_vector_value(self, frc_str_conv,
                                                           frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_row_vector_value(&self, frc_str_conv: bool,
                                             frc_vec_conv: bool)
         -> root::FloatRowVector {
            octave_value_float_row_vector_value(self, frc_str_conv,
                                                frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_row_vector_value(&self,
                                                     frc_str_conv: bool,
                                                     frc_vec_conv: bool)
         -> root::FloatComplexRowVector {
            octave_value_float_complex_row_vector_value(self, frc_str_conv,
                                                        frc_vec_conv)
        }
        #[inline]
        pub unsafe fn int_vector_value(&self, req_int: bool,
                                       frc_str_conv: bool, frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int> {
            octave_value_int_vector_value(self, req_int, frc_str_conv,
                                          frc_vec_conv)
        }
        #[inline]
        pub unsafe fn octave_idx_type_vector_value(&self, req_int: bool,
                                                   frc_str_conv: bool,
                                                   frc_vec_conv: bool)
         -> root::Array<::std::os::raw::c_int> {
            octave_value_octave_idx_type_vector_value(self, req_int,
                                                      frc_str_conv,
                                                      frc_vec_conv)
        }
        #[inline]
        pub unsafe fn vector_value(&self, frc_str_conv: bool,
                                   frc_vec_conv: bool) -> root::Array<f64> {
            octave_value_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_vector_value(&self, frc_str_conv: bool,
                                           frc_vec_conv: bool)
         -> root::Array<root::std::complex<f64>> {
            octave_value_complex_vector_value(self, frc_str_conv,
                                              frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_vector_value(&self, frc_str_conv: bool,
                                         frc_vec_conv: bool)
         -> root::Array<f32> {
            octave_value_float_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_vector_value(&self, frc_str_conv: bool,
                                                 frc_vec_conv: bool)
         -> root::Array<root::std::complex<f32>> {
            octave_value_float_complex_vector_value(self, frc_str_conv,
                                                    frc_vec_conv)
        }
        #[inline]
        pub unsafe fn storable_value(&self) -> root::octave_value {
            octave_value_storable_value(self)
        }
        #[inline]
        pub unsafe fn make_storable_value(&mut self) {
            octave_value_make_storable_value(self)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op(&mut self,
                                            op: root::octave_value_unary_op)
         -> *mut root::octave_value {
            octave_value_do_non_const_unary_op(self, op)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op1(&mut self,
                                             op: root::octave_value_unary_op,
                                             type_: *const root::std::string,
                                             idx: *const root::std::list)
         -> *mut root::octave_value {
            octave_value_do_non_const_unary_op1(self, op, type_, idx)
        }
        #[inline]
        pub unsafe fn print_info(&self, os: *mut root::std::ostream,
                                 prefix: *const root::std::string) {
            octave_value_print_info(self, os, prefix)
        }
        #[inline]
        pub unsafe fn write(&self, os: *mut root::octave_stream,
                            block_size: ::std::os::raw::c_int,
                            output_type: root::oct_data_conv_data_type,
                            skip: ::std::os::raw::c_int,
                            flt_fmt: root::octave::mach_info_float_format)
         -> ::std::os::raw::c_int {
            octave_value_write(self, os, block_size, output_type, skip,
                               flt_fmt)
        }
        #[inline]
        pub unsafe fn new(i: ::std::os::raw::c_short) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(i: ::std::os::raw::c_ushort) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value1(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(i: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value2(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(i: ::std::os::raw::c_uint) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value3(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(i: ::std::os::raw::c_long) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value4(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(i: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value5(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(i: ::std::os::raw::c_longlong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value6(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(i: ::std::os::raw::c_ulonglong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value7(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(t: root::octave::sys::time) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value8(&mut __bindgen_tmp, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(d: f64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value9(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(d: f32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value10(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::Array<root::octave_value>,
                            is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value11(&mut __bindgen_tmp, a, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(c: *const root::Cell, is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value12(&mut __bindgen_tmp, c, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(m: *const root::Matrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value13(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new14(m: *const root::FloatMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value14(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new15(nda: *const root::NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value15(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new16(nda: *const root::FloatNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value16(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new17(m: *const root::Array<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value17(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new18(m: *const root::Array<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value18(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new19(d: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value19(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new20(d: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value20(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new21(d: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value21(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new22(d:
                                *const root::DiagArray2<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value22(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new23(d:
                                *const root::DiagArray2<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value23(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new24(d: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value24(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new25(v: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value25(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new26(v: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value26(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new27(v: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value27(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new28(v: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value28(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new29(C: *const root::Complex) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value29(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new30(C: *const root::FloatComplex) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value30(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new31(m: *const root::ComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value31(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new32(m: *const root::FloatComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value32(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new33(cnda: *const root::ComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value33(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new34(cnda: *const root::FloatComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value34(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new35(m: *const root::Array<root::std::complex<f64>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value35(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new36(m: *const root::Array<root::std::complex<f32>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value36(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new37(d: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value37(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new38(d: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value38(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new39(v: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value39(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new40(v: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value40(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new41(v: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value41(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new42(v: *const root::FloatComplexColumnVector)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value42(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new43(p: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value43(&mut __bindgen_tmp, p);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new44(b: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value44(&mut __bindgen_tmp, b);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new45(bm: *const root::boolMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value45(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new46(bnda: *const root::boolNDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value46(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new47(bnda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value47(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new48(c: ::std::os::raw::c_char,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value48(&mut __bindgen_tmp, c, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new49(s: *const ::std::os::raw::c_char,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value49(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new50(s: *const root::std::string,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value50(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new51(s: *const root::string_vector,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value51(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new52(chm: *const root::charMatrix,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value52(&mut __bindgen_tmp, chm, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new53(chnda: *const root::charNDArray,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value53(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new54(chnda: *const root::Array<::std::os::raw::c_char>,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value54(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new55(chm: *const root::charMatrix, is_string: bool,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value55(&mut __bindgen_tmp, chm, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new56(chnda: *const root::charNDArray, is_string: bool,
                            type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value56(&mut __bindgen_tmp, chnda, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new57(chnda: *const root::Array<::std::os::raw::c_char>,
                            is_string: bool, type_: ::std::os::raw::c_char)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value57(&mut __bindgen_tmp, chnda, is_string,
                                        type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new58(m: *const root::SparseMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value58(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new59(m: *const root::Sparse<f64>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value59(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new60(m: *const root::SparseComplexMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value60(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new61(m: *const root::Sparse<root::std::complex<f64>>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value61(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new62(bm: *const root::SparseBoolMatrix,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value62(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new63(m: *const root::Sparse<bool>,
                            t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value63(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new64(i: *const root::octave_int8) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value64(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new65(i: *const root::octave_int16) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value65(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new66(i: *const root::octave_int32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value66(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new67(i: *const root::octave_int64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value67(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new68(i: *const root::octave_uint8) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value68(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new69(i: *const root::octave_uint16) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value69(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new70(i: *const root::octave_uint32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value70(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new71(i: *const root::octave_uint64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value71(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new72(inda: *const root::int8NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value72(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new73(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_schar>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value73(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new74(inda: *const root::int16NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value74(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new75(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_short>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value75(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new76(inda: *const root::int32NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value76(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new77(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_int>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value77(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new78(inda: *const root::int64NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value78(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new79(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_longlong>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value79(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new80(inda: *const root::uint8NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value80(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new81(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_uchar>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value81(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new82(inda: *const root::uint16NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value82(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new83(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_ushort>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value83(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new84(inda: *const root::uint32NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value84(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new85(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_uint>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value85(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new86(inda: *const root::uint64NDArray) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value86(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new87(inda:
                                *const root::Array<root::octave_int<::std::os::raw::c_ulonglong>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value87(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new88(inda: *const root::Array<::std::os::raw::c_int>,
                            zero_based: bool, cache_index: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value88(&mut __bindgen_tmp, inda, zero_based,
                                        cache_index);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new89(cellstr:
                                *const root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                                           root::std::allocator>>)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value89(&mut __bindgen_tmp, cellstr);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new90(idx: *const root::idx_vector, lazy: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value90(&mut __bindgen_tmp, idx, lazy);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new91(base: f64, limit: f64, inc: f64) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value91(&mut __bindgen_tmp, base, limit, inc);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new92(r: *const root::Range, force_range: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value92(&mut __bindgen_tmp, r, force_range);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new93(m: *const root::octave_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value93(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new94(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value94(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new95(m: *const root::octave_map,
                            id: *const root::std::string,
                            plist: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value95(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new96(m: *const root::octave_scalar_map,
                            id: *const root::std::string,
                            plist: *const root::std::list) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value96(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new97(m: *const root::octave_value_list, arg1: bool)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value97(&mut __bindgen_tmp, m, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new98(arg1: root::octave_value_magic_colon) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value98(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new99(new_rep: *mut root::octave_base_value,
                            borrow: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value99(&mut __bindgen_tmp, new_rep, borrow);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new100(new_rep: *mut root::octave_base_value,
                             xcount: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_value_octave_value100(&mut __bindgen_tmp, new_rep, xcount);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_script([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_code([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tree_walker([u8; 0]);
    pub const builtin_type_t_btyp_num_types: root::builtin_type_t =
        builtin_type_t::btyp_unknown;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum builtin_type_t {
        btyp_double = 0,
        btyp_float = 1,
        btyp_complex = 2,
        btyp_float_complex = 3,
        btyp_int8 = 4,
        btyp_int16 = 5,
        btyp_int32 = 6,
        btyp_int64 = 7,
        btyp_uint8 = 8,
        btyp_uint16 = 9,
        btyp_uint32 = 10,
        btyp_uint64 = 11,
        btyp_bool = 12,
        btyp_char = 13,
        btyp_struct = 14,
        btyp_cell = 15,
        btyp_func_handle = 16,
        btyp_unknown = 17,
    }
    #[repr(C)]
    pub struct octave_base_value__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_base_value {
        pub vtable_: *const octave_base_value__bindgen_vtable,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    pub type octave_base_value_type_conv_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value)
                                  -> *mut root::octave_base_value>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct octave_base_value_type_conv_info {
        pub _fcn: root::octave_base_value_type_conv_fcn,
        pub _type_id: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_octave_base_value_type_conv_info() {
        assert_eq!(::std::mem::size_of::<octave_base_value_type_conv_info>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   octave_base_value_type_conv_info ) ));
        assert_eq! (::std::mem::align_of::<octave_base_value_type_conv_info>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    octave_base_value_type_conv_info ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value_type_conv_info ) )
                    . _fcn as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_base_value_type_conv_info ) , "::" , stringify ! (
                    _fcn ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value_type_conv_info ) )
                    . _type_id as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_base_value_type_conv_info ) , "::" , stringify ! (
                    _type_id ) ));
    }
    impl Clone for octave_base_value_type_conv_info {
        fn clone(&self) -> Self { *self }
    }
    pub const octave_base_value_unary_mapper_t_num_unary_mappers:
              root::octave_base_value_unary_mapper_t =
        octave_base_value_unary_mapper_t::umap_unknown;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum octave_base_value_unary_mapper_t {
        umap_abs = 0,
        umap_acos = 1,
        umap_acosh = 2,
        umap_angle = 3,
        umap_arg = 4,
        umap_asin = 5,
        umap_asinh = 6,
        umap_atan = 7,
        umap_atanh = 8,
        umap_cbrt = 9,
        umap_ceil = 10,
        umap_conj = 11,
        umap_cos = 12,
        umap_cosh = 13,
        umap_erf = 14,
        umap_erfinv = 15,
        umap_erfcinv = 16,
        umap_erfc = 17,
        umap_erfcx = 18,
        umap_erfi = 19,
        umap_dawson = 20,
        umap_exp = 21,
        umap_expm1 = 22,
        umap_isfinite = 23,
        umap_fix = 24,
        umap_floor = 25,
        umap_gamma = 26,
        umap_imag = 27,
        umap_isinf = 28,
        umap_isna = 29,
        umap_isnan = 30,
        umap_lgamma = 31,
        umap_log = 32,
        umap_log2 = 33,
        umap_log10 = 34,
        umap_log1p = 35,
        umap_real = 36,
        umap_round = 37,
        umap_roundb = 38,
        umap_signum = 39,
        umap_sin = 40,
        umap_sinh = 41,
        umap_sqrt = 42,
        umap_tan = 43,
        umap_tanh = 44,
        umap_xisalnum = 45,
        umap_xisalpha = 46,
        umap_xisascii = 47,
        umap_xiscntrl = 48,
        umap_xisdigit = 49,
        umap_xisgraph = 50,
        umap_xislower = 51,
        umap_xisprint = 52,
        umap_xispunct = 53,
        umap_xisspace = 54,
        umap_xisupper = 55,
        umap_xisxdigit = 56,
        umap_xsignbit = 57,
        umap_xtoascii = 58,
        umap_xtolower = 59,
        umap_xtoupper = 60,
        umap_unknown = 61,
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value23curr_print_indent_levelE"]
        pub static mut octave_base_value_curr_print_indent_level:
                   ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value17beginning_of_lineE"]
        pub static mut octave_base_value_beginning_of_line: bool;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value4t_idE"]
        pub static mut octave_base_value_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value6t_nameE"]
        pub static octave_base_value_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value6c_nameE"]
        pub static octave_base_value_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_base_value() {
        assert_eq!(::std::mem::size_of::<octave_base_value>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_base_value )
                   ));
        assert_eq! (::std::mem::align_of::<octave_base_value>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_base_value ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_base_value ) ) . count as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_base_value )
                    , "::" , stringify ! ( count ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN17octave_base_value14numeric_assignERKSsRKSt4listI17octave_value_listSaIS3_EERK12octave_value"]
        pub fn octave_base_value_numeric_assign(this:
                                                    *mut root::octave_base_value,
                                                type_:
                                                    *const root::std::string,
                                                idx: *const root::std::list,
                                                rhs:
                                                    *const root::octave_value)
         -> root::octave_value;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value6indentERSo"]
        pub fn octave_base_value_indent(this: *const root::octave_base_value,
                                        os: *mut root::std::ostream);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value7newlineERSo"]
        pub fn octave_base_value_newline(this: *const root::octave_base_value,
                                         os: *mut root::std::ostream);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value5resetEv"]
        pub fn octave_base_value_reset(this: *const root::octave_base_value);
    }
    extern "C" {
        #[link_name =
              "_ZN17octave_base_value13get_umap_nameENS_14unary_mapper_tE"]
        pub fn octave_base_value_get_umap_name(arg1:
                                                   root::octave_base_value_unary_mapper_t)
         -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value9warn_loadEPKc"]
        pub fn octave_base_value_warn_load(this:
                                               *const root::octave_base_value,
                                           type_:
                                               *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZNK17octave_base_value9warn_saveEPKc"]
        pub fn octave_base_value_warn_save(this:
                                               *const root::octave_base_value,
                                           type_:
                                               *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "_ZN17octave_base_value13register_typeEv"]
        pub fn octave_base_value_register_type();
    }
    impl octave_base_value {
        #[inline]
        pub unsafe fn numeric_assign(&mut self,
                                     type_: *const root::std::string,
                                     idx: *const root::std::list,
                                     rhs: *const root::octave_value)
         -> root::octave_value {
            octave_base_value_numeric_assign(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn indent(&self, os: *mut root::std::ostream) {
            octave_base_value_indent(self, os)
        }
        #[inline]
        pub unsafe fn newline(&self, os: *mut root::std::ostream) {
            octave_base_value_newline(self, os)
        }
        #[inline]
        pub unsafe fn reset(&self) { octave_base_value_reset(self) }
        #[inline]
        pub unsafe fn get_umap_name(arg1:
                                        root::octave_base_value_unary_mapper_t)
         -> *const ::std::os::raw::c_char {
            octave_base_value_get_umap_name(arg1)
        }
        #[inline]
        pub unsafe fn warn_load(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_load(self, type_)
        }
        #[inline]
        pub unsafe fn warn_save(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_save(self, type_)
        }
        #[inline]
        pub unsafe fn register_type() { octave_base_value_register_type() }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_fields {
        pub rep: *mut root::octave_fields_fields_rep,
    }
    #[repr(C)]
    pub struct octave_fields_fields_rep {
        pub _base: root::std::map,
        pub count: root::octave_refcount<::std::os::raw::c_int>,
    }
    #[test]
    fn bindgen_test_layout_octave_fields_fields_rep() {
        assert_eq!(::std::mem::size_of::<octave_fields_fields_rep>() , 56usize
                   , concat ! (
                   "Size of: " , stringify ! ( octave_fields_fields_rep ) ));
        assert_eq! (::std::mem::align_of::<octave_fields_fields_rep>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( octave_fields_fields_rep )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_fields_fields_rep ) ) . count
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_fields_fields_rep ) , "::" , stringify ! ( count )
                    ));
    }
    pub type octave_fields_const_iterator = u64;
    pub type octave_fields_iterator = root::octave_fields_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_fields() {
        assert_eq!(::std::mem::size_of::<octave_fields>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( octave_fields ) ));
        assert_eq! (::std::mem::align_of::<octave_fields>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( octave_fields ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_fields ) ) . rep as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_fields ) ,
                    "::" , stringify ! ( rep ) ));
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields7isfieldERKSs"]
        pub fn octave_fields_isfield(this: *const root::octave_fields,
                                     name: *const root::std::string) -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields8getfieldERKSs"]
        pub fn octave_fields_getfield(this: *const root::octave_fields,
                                      name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields8getfieldERKSs"]
        pub fn octave_fields_getfield1(this: *mut root::octave_fields,
                                       name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields7rmfieldERKSs"]
        pub fn octave_fields_rmfield(this: *mut root::octave_fields,
                                     name: *const root::std::string)
         -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fields11orderfieldsER5ArrayIiE"]
        pub fn octave_fields_orderfields(this: *mut root::octave_fields,
                                         perm:
                                             *mut root::Array<::std::os::raw::c_int>);
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields17equal_up_to_orderERKS_Pi"]
        pub fn octave_fields_equal_up_to_order(this:
                                                   *const root::octave_fields,
                                               other:
                                                   *const root::octave_fields,
                                               perm:
                                                   *mut root::octave_idx_type)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields17equal_up_to_orderERKS_R5ArrayIiE"]
        pub fn octave_fields_equal_up_to_order1(this:
                                                    *const root::octave_fields,
                                                other:
                                                    *const root::octave_fields,
                                                perm:
                                                    *mut root::Array<::std::os::raw::c_int>)
         -> bool;
    }
    extern "C" {
        #[link_name = "_ZNK13octave_fields10fieldnamesEv"]
        pub fn octave_fields_fieldnames(this: *const root::octave_fields)
         -> root::string_vector;
    }
    extern "C" {
        #[link_name = "_ZN13octave_fieldsC1ERK13string_vector"]
        pub fn octave_fields_octave_fields(this: *mut root::octave_fields,
                                           arg1: *const root::string_vector);
    }
    extern "C" {
        #[link_name = "_ZN13octave_fieldsC1EPKPKc"]
        pub fn octave_fields_octave_fields1(this: *mut root::octave_fields,
                                            arg1:
                                                *const *const ::std::os::raw::c_char);
    }
    impl octave_fields {
        #[inline]
        pub unsafe fn isfield(&self, name: *const root::std::string) -> bool {
            octave_fields_isfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield(&self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_getfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield1(&mut self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_getfield1(self, name)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, name: *const root::std::string)
         -> root::octave_idx_type {
            octave_fields_rmfield(self, name)
        }
        #[inline]
        pub unsafe fn orderfields(&mut self,
                                  perm:
                                      *mut root::Array<::std::os::raw::c_int>) {
            octave_fields_orderfields(self, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order(&self,
                                        other: *const root::octave_fields,
                                        perm: *mut root::octave_idx_type)
         -> bool {
            octave_fields_equal_up_to_order(self, other, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order1(&self,
                                         other: *const root::octave_fields,
                                         perm:
                                             *mut root::Array<::std::os::raw::c_int>)
         -> bool {
            octave_fields_equal_up_to_order1(self, other, perm)
        }
        #[inline]
        pub unsafe fn fieldnames(&self) -> root::string_vector {
            octave_fields_fieldnames(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::string_vector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_fields_octave_fields(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const *const ::std::os::raw::c_char)
         -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_fields_octave_fields1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value_typeinfo {
        pub num_types: ::std::os::raw::c_int,
        pub types: root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                       root::std::allocator>>,
        pub vals: root::Array<root::octave_value>,
        pub unary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub unary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub non_const_unary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub binary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub compound_binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub compound_binary_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub cat_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub assign_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub assignany_ops: root::Array<*mut ::std::os::raw::c_void>,
        pub pref_assign_conv: root::Array<::std::os::raw::c_int>,
        pub widening_ops: root::Array<*mut ::std::os::raw::c_void>,
    }
    pub type octave_value_typeinfo_unary_class_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_unary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_non_const_unary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value)>;
    pub type octave_value_typeinfo_binary_class_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value,
                                                   arg2:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_binary_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_cat_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_base_value,
                                                   ra_idx:
                                                       *const root::Array<::std::os::raw::c_int>)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_assign_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_value_list,
                                                   arg3:
                                                       *const root::octave_base_value)
                                  -> root::octave_value>;
    pub type octave_value_typeinfo_assignany_op_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::octave_base_value,
                                                   arg2:
                                                       *const root::octave_value_list,
                                                   arg3:
                                                       *const root::octave_value)
                                  -> root::octave_value>;
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo11init_tab_szE"]
        pub static octave_value_typeinfo_init_tab_sz: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo8instanceE"]
        pub static mut octave_value_typeinfo_instance:
                   *mut root::octave_value_typeinfo;
    }
    #[test]
    fn bindgen_test_layout_octave_value_typeinfo() {
        assert_eq!(::std::mem::size_of::<octave_value_typeinfo>() , 568usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_value_typeinfo ) ));
        assert_eq! (::std::mem::align_of::<octave_value_typeinfo>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_value_typeinfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . num_types
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( num_types )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . types as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( types ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . vals as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( vals ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    unary_class_ops as * const _ as usize } , 88usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    unary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . unary_ops
                    as * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( unary_ops )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    non_const_unary_ops as * const _ as usize } , 168usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    non_const_unary_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    binary_class_ops as * const _ as usize } , 208usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    binary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    binary_ops as * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( binary_ops
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    compound_binary_class_ops as * const _ as usize } ,
                    288usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    compound_binary_class_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    compound_binary_ops as * const _ as usize } , 328usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    compound_binary_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) . cat_ops
                    as * const _ as usize } , 368usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( cat_ops )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    assign_ops as * const _ as usize } , 408usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! ( assign_ops
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    assignany_ops as * const _ as usize } , 448usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    assignany_ops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    pref_assign_conv as * const _ as usize } , 488usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    pref_assign_conv ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_value_typeinfo ) ) .
                    widening_ops as * const _ as usize } , 528usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    octave_value_typeinfo ) , "::" , stringify ! (
                    widening_ops ) ));
    }
    extern "C" {
        #[link_name = "_ZN21octave_value_typeinfo11instance_okEv"]
        pub fn octave_value_typeinfo_instance_ok() -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo13register_typeERKSsS1_RK12octave_value"]
        pub fn octave_value_typeinfo_register_type(arg1:
                                                       *const root::std::string,
                                                   arg2:
                                                       *const root::std::string,
                                                   arg3:
                                                       *const root::octave_value)
         -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo23register_unary_class_opEN12octave_value8unary_opEPFS0_RKS0_E"]
        pub fn octave_value_typeinfo_register_unary_class_op(arg1:
                                                                 root::octave_value_unary_op,
                                                             arg2:
                                                                 root::octave_value_typeinfo_unary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo17register_unary_opEN12octave_value8unary_opEiPFS0_RK17octave_base_valueE"]
        pub fn octave_value_typeinfo_register_unary_op(arg1:
                                                           root::octave_value_unary_op,
                                                       arg2:
                                                           ::std::os::raw::c_int,
                                                       arg3:
                                                           root::octave_value_typeinfo_unary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo27register_non_const_unary_opEN12octave_value8unary_opEiPFvR17octave_base_valueE"]
        pub fn octave_value_typeinfo_register_non_const_unary_op(arg1:
                                                                     root::octave_value_unary_op,
                                                                 arg2:
                                                                     ::std::os::raw::c_int,
                                                                 arg3:
                                                                     root::octave_value_typeinfo_non_const_unary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value9binary_opEPFS0_RKS0_S3_E"]
        pub fn octave_value_typeinfo_register_binary_class_op(arg1:
                                                                  root::octave_value_binary_op,
                                                              arg2:
                                                                  root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_binary_opEN12octave_value9binary_opEiiPFS0_RK17octave_base_valueS4_E"]
        pub fn octave_value_typeinfo_register_binary_op(arg1:
                                                            root::octave_value_binary_op,
                                                        arg2:
                                                            ::std::os::raw::c_int,
                                                        arg3:
                                                            ::std::os::raw::c_int,
                                                        arg4:
                                                            root::octave_value_typeinfo_binary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value18compound_binary_opEPFS0_RKS0_S3_E"]
        pub fn octave_value_typeinfo_register_binary_class_op1(arg1:
                                                                   root::octave_value_compound_binary_op,
                                                               arg2:
                                                                   root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_binary_opEN12octave_value18compound_binary_opEiiPFS0_RK17octave_base_valueS4_E"]
        pub fn octave_value_typeinfo_register_binary_op1(arg1:
                                                             root::octave_value_compound_binary_op,
                                                         arg2:
                                                             ::std::os::raw::c_int,
                                                         arg3:
                                                             ::std::os::raw::c_int,
                                                         arg4:
                                                             root::octave_value_typeinfo_binary_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo15register_cat_opEiiPF12octave_valueR17octave_base_valueRKS1_RK5ArrayIiEE"]
        pub fn octave_value_typeinfo_register_cat_op(arg1:
                                                         ::std::os::raw::c_int,
                                                     arg2:
                                                         ::std::os::raw::c_int,
                                                     arg3:
                                                         root::octave_value_typeinfo_cat_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo18register_assign_opEN12octave_value9assign_opEiiPFS0_R17octave_base_valueRK17octave_value_listRKS2_E"]
        pub fn octave_value_typeinfo_register_assign_op(arg1:
                                                            root::octave_value_assign_op,
                                                        arg2:
                                                            ::std::os::raw::c_int,
                                                        arg3:
                                                            ::std::os::raw::c_int,
                                                        arg4:
                                                            root::octave_value_typeinfo_assign_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo21register_assignany_opEN12octave_value9assign_opEiPFS0_R17octave_base_valueRK17octave_value_listRKS0_E"]
        pub fn octave_value_typeinfo_register_assignany_op(arg1:
                                                               root::octave_value_assign_op,
                                                           arg2:
                                                               ::std::os::raw::c_int,
                                                           arg3:
                                                               root::octave_value_typeinfo_assignany_op_fcn)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo25register_pref_assign_convEiii"]
        pub fn octave_value_typeinfo_register_pref_assign_conv(arg1:
                                                                   ::std::os::raw::c_int,
                                                               arg2:
                                                                   ::std::os::raw::c_int,
                                                               arg3:
                                                                   ::std::os::raw::c_int)
         -> bool;
    }
    extern "C" {
        #[link_name =
              "_ZN21octave_value_typeinfo20register_widening_opEiiPFP17octave_base_valueRKS0_E"]
        pub fn octave_value_typeinfo_register_widening_op(arg1:
                                                              ::std::os::raw::c_int,
                                                          arg2:
                                                              ::std::os::raw::c_int,
                                                          arg3:
                                                              root::octave_base_value_type_conv_fcn)
         -> bool;
    }
    impl octave_value_typeinfo {
        #[inline]
        pub unsafe fn instance_ok() -> bool {
            octave_value_typeinfo_instance_ok()
        }
        #[inline]
        pub unsafe fn register_type(arg1: *const root::std::string,
                                    arg2: *const root::std::string,
                                    arg3: *const root::octave_value)
         -> ::std::os::raw::c_int {
            octave_value_typeinfo_register_type(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_unary_class_op(arg1:
                                                  root::octave_value_unary_op,
                                              arg2:
                                                  root::octave_value_typeinfo_unary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_unary_class_op(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_unary_op(arg1: root::octave_value_unary_op,
                                        arg2: ::std::os::raw::c_int,
                                        arg3:
                                            root::octave_value_typeinfo_unary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_unary_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_non_const_unary_op(arg1:
                                                      root::octave_value_unary_op,
                                                  arg2: ::std::os::raw::c_int,
                                                  arg3:
                                                      root::octave_value_typeinfo_non_const_unary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_non_const_unary_op(arg1, arg2,
                                                              arg3)
        }
        #[inline]
        pub unsafe fn register_binary_class_op(arg1:
                                                   root::octave_value_binary_op,
                                               arg2:
                                                   root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_class_op(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_binary_op(arg1: root::octave_value_binary_op,
                                         arg2: ::std::os::raw::c_int,
                                         arg3: ::std::os::raw::c_int,
                                         arg4:
                                             root::octave_value_typeinfo_binary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_op(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_binary_class_op1(arg1:
                                                    root::octave_value_compound_binary_op,
                                                arg2:
                                                    root::octave_value_typeinfo_binary_class_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_class_op1(arg1, arg2)
        }
        #[inline]
        pub unsafe fn register_binary_op1(arg1:
                                              root::octave_value_compound_binary_op,
                                          arg2: ::std::os::raw::c_int,
                                          arg3: ::std::os::raw::c_int,
                                          arg4:
                                              root::octave_value_typeinfo_binary_op_fcn)
         -> bool {
            octave_value_typeinfo_register_binary_op1(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_cat_op(arg1: ::std::os::raw::c_int,
                                      arg2: ::std::os::raw::c_int,
                                      arg3:
                                          root::octave_value_typeinfo_cat_op_fcn)
         -> bool {
            octave_value_typeinfo_register_cat_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_assign_op(arg1: root::octave_value_assign_op,
                                         arg2: ::std::os::raw::c_int,
                                         arg3: ::std::os::raw::c_int,
                                         arg4:
                                             root::octave_value_typeinfo_assign_op_fcn)
         -> bool {
            octave_value_typeinfo_register_assign_op(arg1, arg2, arg3, arg4)
        }
        #[inline]
        pub unsafe fn register_assignany_op(arg1:
                                                root::octave_value_assign_op,
                                            arg2: ::std::os::raw::c_int,
                                            arg3:
                                                root::octave_value_typeinfo_assignany_op_fcn)
         -> bool {
            octave_value_typeinfo_register_assignany_op(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_pref_assign_conv(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int,
                                                arg3: ::std::os::raw::c_int)
         -> bool {
            octave_value_typeinfo_register_pref_assign_conv(arg1, arg2, arg3)
        }
        #[inline]
        pub unsafe fn register_widening_op(arg1: ::std::os::raw::c_int,
                                           arg2: ::std::os::raw::c_int,
                                           arg3:
                                               root::octave_base_value_type_conv_fcn)
         -> bool {
            octave_value_typeinfo_register_widening_op(arg1, arg2, arg3)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct jit_type([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_builtin {
        pub _base: root::octave_function,
        pub f: root::octave_builtin_fcn,
        pub file: root::std::string,
        pub jtype: *mut root::jit_type,
    }
    pub type octave_builtin_fcn =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave_value_list,
                                                   arg2:
                                                       ::std::os::raw::c_int)
                                  -> root::octave_value_list>;
    extern "C" {
        #[link_name = "_ZN14octave_builtin16curr_lvalue_listE"]
        pub static mut octave_builtin_curr_lvalue_list:
                   *const root::std::list;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin4t_idE"]
        pub static mut octave_builtin_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin6t_nameE"]
        pub static octave_builtin_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin6c_nameE"]
        pub static octave_builtin_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_builtin() {
        assert_eq!(::std::mem::size_of::<octave_builtin>() , 80usize , concat
                   ! ( "Size of: " , stringify ! ( octave_builtin ) ));
        assert_eq! (::std::mem::align_of::<octave_builtin>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( octave_builtin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . f as * const _
                    as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( f ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . file as * const
                    _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( file ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_builtin ) ) . jtype as * const
                    _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_builtin ) ,
                    "::" , stringify ! ( jtype ) ));
    }
    extern "C" {
        #[link_name = "_ZNK14octave_builtin6to_jitEv"]
        pub fn octave_builtin_to_jit(this: *const root::octave_builtin)
         -> *mut root::jit_type;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin9stash_jitER8jit_type"]
        pub fn octave_builtin_stash_jit(this: *mut root::octave_builtin,
                                        type_: *mut root::jit_type);
    }
    extern "C" {
        #[link_name = "_ZNK14octave_builtin8functionEv"]
        pub fn octave_builtin_function(this: *const root::octave_builtin)
         -> root::octave_builtin_fcn;
    }
    extern "C" {
        #[link_name = "_ZN14octave_builtin13register_typeEv"]
        pub fn octave_builtin_register_type();
    }
    impl octave_builtin {
        #[inline]
        pub unsafe fn to_jit(&self) -> *mut root::jit_type {
            octave_builtin_to_jit(self)
        }
        #[inline]
        pub unsafe fn stash_jit(&mut self, type_: *mut root::jit_type) {
            octave_builtin_stash_jit(self, type_)
        }
        #[inline]
        pub unsafe fn function(&self) -> root::octave_builtin_fcn {
            octave_builtin_function(self)
        }
        #[inline]
        pub unsafe fn register_type() { octave_builtin_register_type() }
    }
    pub type octave_shlib = root::octave::dynamic_library;
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_dld_function {
        pub _base: root::octave_builtin,
        pub sh_lib: root::octave::dynamic_library,
        pub t_checked: root::octave::sys::time,
        pub system_fcn_file: bool,
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function4t_idE"]
        pub static mut octave_dld_function_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function6t_nameE"]
        pub static octave_dld_function_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function6c_nameE"]
        pub static octave_dld_function_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_dld_function() {
        assert_eq!(::std::mem::size_of::<octave_dld_function>() , 112usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_dld_function ) ));
        assert_eq! (::std::mem::align_of::<octave_dld_function>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_dld_function ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) . sh_lib as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( sh_lib ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) . t_checked
                    as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( t_checked ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_dld_function ) ) .
                    system_fcn_file as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( octave_dld_function
                    ) , "::" , stringify ! ( system_fcn_file ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_dld_function6createEPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKSsSA_"]
        pub fn octave_dld_function_create(ff: root::octave_builtin_fcn,
                                          shl:
                                              *const root::octave::dynamic_library,
                                          nm: *const root::std::string,
                                          ds: *const root::std::string)
         -> *mut root::octave_dld_function;
    }
    extern "C" {
        #[link_name = "_ZN19octave_dld_function13register_typeEv"]
        pub fn octave_dld_function_register_type();
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_dld_functionC1EPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKSsSA_"]
        pub fn octave_dld_function_octave_dld_function(this:
                                                           *mut root::octave_dld_function,
                                                       ff:
                                                           root::octave_builtin_fcn,
                                                       shl:
                                                           *const root::octave::dynamic_library,
                                                       nm:
                                                           *const root::std::string,
                                                       ds:
                                                           *const root::std::string);
    }
    impl octave_dld_function {
        #[inline]
        pub unsafe fn create(ff: root::octave_builtin_fcn,
                             shl: *const root::octave::dynamic_library,
                             nm: *const root::std::string,
                             ds: *const root::std::string)
         -> *mut root::octave_dld_function {
            octave_dld_function_create(ff, shl, nm, ds)
        }
        #[inline]
        pub unsafe fn register_type() { octave_dld_function_register_type() }
        #[inline]
        pub unsafe fn new(ff: root::octave_builtin_fcn,
                          shl: *const root::octave::dynamic_library,
                          nm: *const root::std::string,
                          ds: *const root::std::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_dld_function_octave_dld_function(&mut __bindgen_tmp, ff,
                                                    shl, nm, ds);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_auto_shlib {
        pub _base: root::octave::dynamic_library,
    }
    #[test]
    fn bindgen_test_layout_octave_auto_shlib() {
        assert_eq!(::std::mem::size_of::<octave_auto_shlib>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_auto_shlib )
                   ));
        assert_eq! (::std::mem::align_of::<octave_auto_shlib>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_auto_shlib ) ));
    }
    pub type octave_dld_fcn_installer =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave::dynamic_library,
                                                   relative: bool) -> bool>;
    pub type octave_dld_fcn_getter =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *const root::octave::dynamic_library,
                                                   relative: bool)
                                  -> *mut root::octave_function>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_pager_buf {
        pub _base: root::std::stringbuf,
        pub diary_skip: usize,
    }
    #[test]
    fn bindgen_test_layout_octave_pager_buf() {
        assert_eq!(::std::mem::size_of::<octave_pager_buf>() , 88usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_pager_buf )
                   ));
        assert_eq! (::std::mem::align_of::<octave_pager_buf>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_pager_buf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_pager_buf ) ) . diary_skip as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_pager_buf )
                    , "::" , stringify ! ( diary_skip ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN16octave_pager_buf31flush_current_contents_to_diaryEv"]
        pub fn octave_pager_buf_flush_current_contents_to_diary(this:
                                                                    *mut root::octave_pager_buf);
    }
    extern "C" {
        #[link_name = "_ZN16octave_pager_buf14set_diary_skipEv"]
        pub fn octave_pager_buf_set_diary_skip(this:
                                                   *mut root::octave_pager_buf);
    }
    impl octave_pager_buf {
        #[inline]
        pub unsafe fn flush_current_contents_to_diary(&mut self) {
            octave_pager_buf_flush_current_contents_to_diary(self)
        }
        #[inline]
        pub unsafe fn set_diary_skip(&mut self) {
            octave_pager_buf_set_diary_skip(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_pager_stream {
        pub _base: root::std::ostream,
        pub pb: *mut root::octave_pager_buf,
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream8instanceE"]
        pub static mut octave_pager_stream_instance:
                   *mut root::octave_pager_stream;
    }
    #[test]
    fn bindgen_test_layout_octave_pager_stream() {
        assert_eq!(::std::mem::size_of::<octave_pager_stream>() , 280usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_pager_stream ) ));
        assert_eq! (::std::mem::align_of::<octave_pager_stream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_pager_stream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_pager_stream ) ) . pb as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_pager_stream
                    ) , "::" , stringify ! ( pb ) ));
    }
    extern "C" {
        #[link_name =
              "_ZN19octave_pager_stream31flush_current_contents_to_diaryEv"]
        pub fn octave_pager_stream_flush_current_contents_to_diary();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream14set_diary_skipEv"]
        pub fn octave_pager_stream_set_diary_skip();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream6streamEv"]
        pub fn octave_pager_stream_stream() -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_stream5resetEv"]
        pub fn octave_pager_stream_reset();
    }
    extern "C" {
        #[link_name = "_ZN19octave_pager_streamC1Ev"]
        pub fn octave_pager_stream_octave_pager_stream(this:
                                                           *mut root::octave_pager_stream);
    }
    impl octave_pager_stream {
        #[inline]
        pub unsafe fn flush_current_contents_to_diary() {
            octave_pager_stream_flush_current_contents_to_diary()
        }
        #[inline]
        pub unsafe fn set_diary_skip() {
            octave_pager_stream_set_diary_skip()
        }
        #[inline]
        pub unsafe fn stream() -> *mut root::std::ostream {
            octave_pager_stream_stream()
        }
        #[inline]
        pub unsafe fn reset() { octave_pager_stream_reset() }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_pager_stream_octave_pager_stream(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_diary_buf {
        pub _base: root::std::stringbuf,
    }
    #[test]
    fn bindgen_test_layout_octave_diary_buf() {
        assert_eq!(::std::mem::size_of::<octave_diary_buf>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( octave_diary_buf )
                   ));
        assert_eq! (::std::mem::align_of::<octave_diary_buf>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_diary_buf ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_diary_stream {
        pub _base: root::std::ostream,
        pub db: *mut root::octave_diary_buf,
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream8instanceE"]
        pub static mut octave_diary_stream_instance:
                   *mut root::octave_diary_stream;
    }
    #[test]
    fn bindgen_test_layout_octave_diary_stream() {
        assert_eq!(::std::mem::size_of::<octave_diary_stream>() , 280usize ,
                   concat ! (
                   "Size of: " , stringify ! ( octave_diary_stream ) ));
        assert_eq! (::std::mem::align_of::<octave_diary_stream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( octave_diary_stream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const octave_diary_stream ) ) . db as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( octave_diary_stream
                    ) , "::" , stringify ! ( db ) ));
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream6streamEv"]
        pub fn octave_diary_stream_stream() -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_stream5resetEv"]
        pub fn octave_diary_stream_reset();
    }
    extern "C" {
        #[link_name = "_ZN19octave_diary_streamC1Ev"]
        pub fn octave_diary_stream_octave_diary_stream(this:
                                                           *mut root::octave_diary_stream);
    }
    impl octave_diary_stream {
        #[inline]
        pub unsafe fn stream() -> *mut root::std::ostream {
            octave_diary_stream_stream()
        }
        #[inline]
        pub unsafe fn reset() { octave_diary_stream_reset() }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            octave_diary_stream_octave_diary_stream(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_integral_constant_instantiation_85743() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_iterator_instantiation_85906() {
        assert_eq!(::std::mem::size_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::iterator ) ));
        assert_eq!(::std::mem::align_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::iterator ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91051() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_schar>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_schar> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_schar>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_schar> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91055() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_short>>()
                   , 2usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_short> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_short>>()
                   , 2usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_short> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91059() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_int>>()
                   , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_int>>()
                   , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91063() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_longlong>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_longlong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_longlong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_longlong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91067() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_uchar>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uchar> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_uchar>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uchar> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91071() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_ushort>>()
                   , 2usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ushort> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_ushort>>()
                   , 2usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ushort> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91075() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_uint>>()
                   , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_uint>>()
                   , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_octave_int_instantiation_91079() {
        assert_eq!(::std::mem::size_of::<root::octave_int<::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ulonglong> ) ));
        assert_eq!(::std::mem::align_of::<root::octave_int<::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::octave_int<::std::os::raw::c_ulonglong> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91134() {
        assert_eq!(::std::mem::size_of::<root::Array<::std::os::raw::c_int>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_int> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_int> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91149() {
        assert_eq!(::std::mem::size_of::<root::Array<f64>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91217() {
        assert_eq!(::std::mem::size_of::<root::Array<bool>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<bool>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_91222() {
        assert_eq!(::std::mem::size_of::<root::Sparse<bool>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<bool> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<bool>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<bool> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_91289() {
        assert_eq!(::std::mem::size_of::<root::Array<f32>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_92560() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<f64>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_92565() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<f64>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_93129() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<root::std::complex<f64>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_93133() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<root::std::complex<f64>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_93724() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<f32>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_93729() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<f32>>() , 48usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_instantiation_94287() {
        assert_eq!(::std::mem::size_of::<root::MDiagArray2<root::std::complex<f32>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::MDiagArray2<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MDiagArray2<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_instantiation_94291() {
        assert_eq!(::std::mem::size_of::<root::DiagArray2<root::std::complex<f32>>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::DiagArray2<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::DiagArray2<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MSparse_instantiation_94858() {
        assert_eq!(::std::mem::size_of::<root::MSparse<f64>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MSparse<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MSparse<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MSparse<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_94879() {
        assert_eq!(::std::mem::size_of::<root::Sparse<f64>>() , 24usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MSparse_instantiation_95559() {
        assert_eq!(::std::mem::size_of::<root::MSparse<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MSparse<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MSparse<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MSparse<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sparse_instantiation_95579() {
        assert_eq!(::std::mem::size_of::<root::Sparse<root::std::complex<f64>>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Sparse<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::Sparse<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Sparse<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_95587() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::complex<f64>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_96321() {
        assert_eq!(::std::mem::size_of::<root::Array<::std::os::raw::c_char>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96345() {
        assert_eq!(::std::mem::size_of::<root::MArray<f64>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96446() {
        assert_eq!(::std::mem::size_of::<root::MArray<root::std::complex<f64>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f64>> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<root::std::complex<f64>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f64>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96536() {
        assert_eq!(::std::mem::size_of::<root::MArray<f32>>() , 40usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<f32> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<f32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<f32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MArray_instantiation_96626() {
        assert_eq!(::std::mem::size_of::<root::MArray<root::std::complex<f32>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::MArray<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::MArray<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_96921() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::complex<f32>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f32>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::complex<f32>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::complex<f32>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_97745() {
        assert_eq!(::std::mem::size_of::<root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                          root::std::allocator>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::std::basic_string<::std::os::raw::c_char,
                                                           root::std::allocator>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::std::basic_string<::std::os::raw::c_char,
                                    root::std::allocator>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_97787() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_list_instantiation_97785() {
        assert_eq!(::std::mem::size_of::<root::std::list>() , 16usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::list ) ));
        assert_eq!(::std::mem::align_of::<root::std::list>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::list ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100267() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_schar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_schar>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_schar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_schar>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100498() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_short>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_short>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_short>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_short>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100729() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_int>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_int>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_int>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_int>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_100960() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_longlong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101191() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uchar>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101422() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ushort>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101653() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uint>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uint>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_uint>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_uint>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_instantiation_101884() {
        assert_eq!(::std::mem::size_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::intNDArray<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_115325() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_value>>() ,
                   40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_value> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_value>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115550() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115619() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_115676() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_list_instantiation_115674() {
        assert_eq!(::std::mem::size_of::<root::std::list>() , 16usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::list ) ));
        assert_eq!(::std::mem::align_of::<root::std::list>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::list ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116195() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_schar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_schar>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_schar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_schar>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116201() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_short>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_short>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_short>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_short>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116207() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_int>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_int>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_int>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_int>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116213() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_longlong>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_longlong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_longlong>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116219() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uchar>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_uchar>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uchar>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116225() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ushort>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_ushort>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ushort>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116231() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_uint>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uint>> ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_uint>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_uint>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Array_instantiation_116237() {
        assert_eq!(::std::mem::size_of::<root::Array<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::Array<root::octave_int<::std::os::raw::c_ulonglong>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::Array<root::octave_int<::std::os::raw::c_ulonglong>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_less_instantiation_117444() {
        assert_eq!(::std::mem::size_of::<root::std::less>() , 1usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::less ) ));
        assert_eq!(::std::mem::align_of::<root::std::less>() , 1usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::less ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_117448() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      ::std::os::raw::c_int>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_int>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       ::std::os::raw::c_int>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_int>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_117447() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_map_instantiation_117440() {
        assert_eq!(::std::mem::size_of::<root::std::map>() , 48usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::map ) ));
        assert_eq!(::std::mem::align_of::<root::std::map>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::map ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_118535() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      ::std::os::raw::c_ulonglong>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_ulonglong>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       ::std::os::raw::c_ulonglong>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                ::std::os::raw::c_ulonglong>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_118547() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_118555() {
        assert_eq!(::std::mem::size_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                              root::std::allocator>,
                                      *mut root::octave::dynamic_library_dynlib_rep>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                *mut root::octave::dynamic_library_dynlib_rep>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                                               root::std::allocator>,
                                       *mut root::octave::dynamic_library_dynlib_rep>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<root::std::basic_string<::std::os::raw::c_char,
                                        root::std::allocator>,
                *mut root::octave::dynamic_library_dynlib_rep>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_allocator_instantiation_118554() {
        assert_eq!(::std::mem::size_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::allocator ) ));
        assert_eq!(::std::mem::align_of::<root::std::allocator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::allocator ) ));
    }
}
