/* automatically generated by rust-bindgen */

#![allow(warnings)]
extern crate core;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Char_alloc_type = u8;
        pub type basic_string__Alloc_traits = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string___const_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _address: u8,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub union basic_string__bindgen_ty_2 {
            pub _bindgen_opaque_blob: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list {
            pub _address: u8,
        }
        pub type list__Base = u8;
        pub type list__Tp_alloc_type = u8;
        pub type list__Tp_alloc_traits = u8;
        pub type list__Node_alloc_type = u8;
        pub type list__Node_alloc_traits = u8;
        pub type list_value_type = u8;
        pub type list_pointer = u8;
        pub type list_const_pointer = u8;
        pub type list_reference = u8;
        pub type list_const_reference = u8;
        pub type list_iterator = u8;
        pub type list_const_iterator = u8;
        pub type list_const_reverse_iterator = u8;
        pub type list_reverse_iterator = u8;
        pub type list_size_type = u64;
        pub type list_difference_type = u64;
        pub type list_allocator_type = u8;
        pub type list__Node = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        pub type istream = [u64; 35usize];
        pub type ostream = [u64; 34usize];
        pub type stringbuf = [u64; 13usize];
        pub type ofstream = [u64; 64usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Constructible = u8;
        pub type shared_ptr__Assignable = u8;
        pub type shared_ptr_element_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct weak_ptr {
            pub _address: u8,
        }
        pub type weak_ptr__Constructible = u8;
        pub type weak_ptr__Assignable = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct enable_shared_from_this {
            pub _address: u8,
        }
        pub use self::super::super::u32 as ios_base_openmode;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct complex {
            pub _address: u8,
        }
        pub type complex_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__Temporary_value {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set {
            pub _address: u8,
        }
        pub type set_key_type = u8;
        pub type set_value_type = u8;
        pub type set_key_compare = u8;
        pub type set_value_compare = u8;
        pub type set_allocator_type = u8;
        pub type set__Key_alloc_type = u8;
        pub type set__Rep_type = u8;
        pub type set__Alloc_traits = u8;
        pub type set_pointer = u8;
        pub type set_const_pointer = u8;
        pub type set_reference = u8;
        pub type set_const_reference = u8;
        pub type set_iterator = u8;
        pub type set_const_iterator = u8;
        pub type set_reverse_iterator = u8;
        pub type set_const_reverse_iterator = u8;
        pub type set_size_type = u8;
        pub type set_difference_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        pub type map_key_type = u8;
        pub type map_mapped_type = u8;
        pub type map_value_type = u8;
        pub type map_key_compare = u8;
        pub type map_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare {
            pub _address: u8,
        }
        pub type map__Pair_alloc_type = u8;
        pub type map__Rep_type = u8;
        pub type map__Alloc_traits = u8;
        pub type map_pointer = u8;
        pub type map_const_pointer = u8;
        pub type map_reference = u8;
        pub type map_const_reference = u8;
        pub type map_iterator = u8;
        pub type map_const_iterator = u8;
        pub type map_size_type = u8;
        pub type map_difference_type = u8;
        pub type map_reverse_iterator = u8;
        pub type map_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque {
            pub _address: u8,
        }
        pub type deque__Base = u8;
        pub type deque__Tp_alloc_type = u8;
        pub type deque__Alloc_traits = u8;
        pub type deque__Map_pointer = u8;
        pub type deque_value_type = u8;
        pub type deque_pointer = u8;
        pub type deque_const_pointer = u8;
        pub type deque_reference = u8;
        pub type deque_const_reference = u8;
        pub type deque_iterator = u8;
        pub type deque_const_iterator = u8;
        pub type deque_const_reverse_iterator = u8;
        pub type deque_reverse_iterator = u8;
        pub type deque_size_type = u64;
        pub type deque_difference_type = u64;
        pub type deque_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct stack {
            pub _address: u8,
        }
        pub type stack__Uses = u8;
        pub type stack_value_type = u8;
        pub type stack_reference = u8;
        pub type stack_const_reference = u8;
        pub type stack_size_type = u8;
        pub type stack_container_type = u8;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type __int8_t = ::std::os::raw::c_schar;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __int16_t = ::std::os::raw::c_short;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __int64_t = ::std::os::raw::c_long;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type __time_t = ::std::os::raw::c_long;
    pub type octave_idx_type = i64;
    pub type octave_f77_int_type = i32;
    pub type off_t = root::__off_t;
    pub type time_t = root::__time_t;
    pub type __gnuc_va_list = root::__builtin_va_list;
    pub type FILE = root::_IO_FILE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut root::_IO_marker,
        pub _chain: *mut root::_IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: root::__off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut root::_IO_lock_t,
        pub _offset: root::__off64_t,
        pub _codecvt: *mut root::_IO_codecvt,
        pub _wide_data: *mut root::_IO_wide_data,
        pub _freeres_list: *mut root::_IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        assert_eq!(
            ::core::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::core::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    pub type va_list = root::__gnuc_va_list;
    pub mod octave {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct refcount<T> {
            pub count: root::octave::refcount_count_type<T>,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
        }
        pub type refcount_count_type<T> = T;
        #[repr(C)]
        pub struct execution_exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct execution_exception {
            pub vtable_: *const execution_exception__bindgen_vtable,
            pub m_stack_trace: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_execution_exception() {
            assert_eq!(
                ::core::mem::size_of::<execution_exception>(),
                40usize,
                concat!("Size of: ", stringify!(execution_exception))
            );
            assert_eq!(
                ::core::mem::align_of::<execution_exception>(),
                8usize,
                concat!("Alignment of ", stringify!(execution_exception))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<execution_exception>())).m_stack_trace as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(execution_exception),
                    "::",
                    stringify!(m_stack_trace)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct exit_exception {
            pub m_exit_status: ::std::os::raw::c_int,
            pub m_safe_to_return: bool,
        }
        #[test]
        fn bindgen_test_layout_exit_exception() {
            assert_eq!(
                ::core::mem::size_of::<exit_exception>(),
                8usize,
                concat!("Size of: ", stringify!(exit_exception))
            );
            assert_eq!(
                ::core::mem::align_of::<exit_exception>(),
                4usize,
                concat!("Alignment of ", stringify!(exit_exception))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<exit_exception>())).m_exit_status as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(exit_exception),
                    "::",
                    stringify!(m_exit_status)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<exit_exception>())).m_safe_to_return as *const _
                        as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(exit_exception),
                    "::",
                    stringify!(m_safe_to_return)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct interrupt_exception {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_interrupt_exception() {
            assert_eq!(
                ::core::mem::size_of::<interrupt_exception>(),
                1usize,
                concat!("Size of: ", stringify!(interrupt_exception))
            );
            assert_eq!(
                ::core::mem::align_of::<interrupt_exception>(),
                1usize,
                concat!("Alignment of ", stringify!(interrupt_exception))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct index_exception {
            pub _base: root::octave::execution_exception,
            pub index: root::std::string,
            pub nd: root::octave_idx_type,
            pub dim: root::octave_idx_type,
            pub var: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_index_exception() {
            assert_eq!(
                ::core::mem::size_of::<index_exception>(),
                120usize,
                concat!("Size of: ", stringify!(index_exception))
            );
            assert_eq!(
                ::core::mem::align_of::<index_exception>(),
                8usize,
                concat!("Alignment of ", stringify!(index_exception))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<index_exception>())).index as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(index_exception),
                    "::",
                    stringify!(index)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<index_exception>())).nd as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(index_exception),
                    "::",
                    stringify!(nd)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<index_exception>())).dim as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(index_exception),
                    "::",
                    stringify!(dim)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<index_exception>())).var as *const _ as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(index_exception),
                    "::",
                    stringify!(var)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave15index_exception10expressionB5cxx11Ev"]
            pub fn index_exception_expression(
                this: *const root::octave::index_exception,
            ) -> root::std::string;
        }
        impl index_exception {
            #[inline]
            pub unsafe fn expression(&self) -> root::std::string {
                index_exception_expression(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave15index_exception7messageB5cxx11Ev"]
            pub fn index_exception_message(this: *mut ::std::os::raw::c_void) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave29err_nan_to_logical_conversionEv"]
            pub fn err_nan_to_logical_conversion();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave31err_nan_to_character_conversionEv"]
            pub fn err_nan_to_character_conversion();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_nonconformantEPKcll"]
            pub fn err_nonconformant(
                op: *const ::std::os::raw::c_char,
                op1_len: root::octave_idx_type,
                op2_len: root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_nonconformantEPKcllll"]
            pub fn err_nonconformant1(
                op: *const ::std::os::raw::c_char,
                op1_nr: root::octave_idx_type,
                op1_nc: root::octave_idx_type,
                op2_nr: root::octave_idx_type,
                op2_nc: root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_nonconformantEPKcRK10dim_vectorS4_"]
            pub fn err_nonconformant2(
                op: *const ::std::os::raw::c_char,
                op1_dims: *const root::dim_vector,
                op2_dims: *const root::dim_vector,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave22err_index_out_of_rangeEiillRK10dim_vector"]
            pub fn err_index_out_of_range(
                nd: ::std::os::raw::c_int,
                dim: ::std::os::raw::c_int,
                iext: root::octave_idx_type,
                ext: root::octave_idx_type,
                d: *const root::dim_vector,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave22err_index_out_of_rangeEiill"]
            pub fn err_index_out_of_range1(
                nd: ::std::os::raw::c_int,
                dim: ::std::os::raw::c_int,
                iext: root::octave_idx_type,
                ext: root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave26err_del_index_out_of_rangeEbll"]
            pub fn err_del_index_out_of_range(
                is1d: bool,
                iext: root::octave_idx_type,
                ext: root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_invalid_indexEdllRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn err_invalid_index(
                n: f64,
                nd: root::octave_idx_type,
                dim: root::octave_idx_type,
                var: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_invalid_indexElllRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn err_invalid_index1(
                n: root::octave_idx_type,
                nd: root::octave_idx_type,
                dim: root::octave_idx_type,
                var: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17err_invalid_indexERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEllS7_"]
            pub fn err_invalid_index2(
                idx: *const root::std::string,
                nd: root::octave_idx_type,
                dim: root::octave_idx_type,
                var: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave18err_invalid_resizeEv"]
            pub fn err_invalid_resize();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave20warn_singular_matrixEd"]
            pub fn warn_singular_matrix(rcond: f64);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct numeric_limits {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_numeric_limits_open0_double_close0_instantiation() {
            assert_eq!(
                ::core::mem::size_of::<root::octave::numeric_limits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::octave::numeric_limits)
                )
            );
            assert_eq!(
                ::core::mem::align_of::<root::octave::numeric_limits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::octave::numeric_limits)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_numeric_limits_open0_float_close0_instantiation() {
            assert_eq!(
                ::core::mem::size_of::<root::octave::numeric_limits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::octave::numeric_limits)
                )
            );
            assert_eq!(
                ::core::mem::align_of::<root::octave::numeric_limits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::octave::numeric_limits)
                )
            );
        }
        pub mod math {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4isnaEd"]
                pub fn isna(x: f64) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4isnaEf"]
                pub fn isna1(x: f32) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4isnaERKSt7complexIdE"]
                pub fn isna2(x: *const root::Complex) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4isnaERKSt7complexIfE"]
                pub fn isna3(x: *const root::FloatComplex) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math12is_NaN_or_NAERKSt7complexIdE"]
                pub fn is_NaN_or_NA(x: *const root::Complex) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math12is_NaN_or_NAERKSt7complexIfE"]
                pub fn is_NaN_or_NA1(x: *const root::FloatComplex) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math13negative_signEd"]
                pub fn negative_sign(x: f64) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math13negative_signEf"]
                pub fn negative_sign1(x: f32) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4acosERKSt7complexIdE"]
                pub fn acos(x: *const root::Complex) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4acosERKSt7complexIfE"]
                pub fn acos1(x: *const root::FloatComplex) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4asinERKSt7complexIdE"]
                pub fn asin(x: *const root::Complex) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4asinERKSt7complexIfE"]
                pub fn asin1(x: *const root::FloatComplex) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2ERKSt7complexIdE"]
                pub fn log2(x: *const root::Complex) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2ERKSt7complexIfE"]
                pub fn log21(x: *const root::FloatComplex) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2EdRi"]
                pub fn log22(x: f64, exp: *mut ::std::os::raw::c_int) -> f64;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2EfRi"]
                pub fn log23(x: f32, exp: *mut ::std::os::raw::c_int) -> f32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2ERKSt7complexIdERi"]
                pub fn log24(
                    x: *const root::Complex,
                    exp: *mut ::std::os::raw::c_int,
                ) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4log2ERKSt7complexIfERi"]
                pub fn log25(
                    x: *const root::FloatComplex,
                    exp: *mut ::std::os::raw::c_int,
                ) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math5frexpEdPi"]
                pub fn frexp(x: f64, expptr: *mut ::std::os::raw::c_int) -> f64;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math5frexpEfPi"]
                pub fn frexp1(x: f32, expptr: *mut ::std::os::raw::c_int) -> f32;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8nint_bigEd"]
                pub fn nint_big(x: f64) -> root::octave_idx_type;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8nint_bigEf"]
                pub fn nint_big1(x: f32) -> root::octave_idx_type;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4nintEd"]
                pub fn nint(x: f64) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math4nintEf"]
                pub fn nint1(x: f32) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_acosEd"]
                pub fn rc_acos(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_acosEf"]
                pub fn rc_acos1(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_acoshEd"]
                pub fn rc_acosh(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_acoshEf"]
                pub fn rc_acosh1(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_asinEd"]
                pub fn rc_asin(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_asinEf"]
                pub fn rc_asin1(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_atanhEd"]
                pub fn rc_atanh(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_atanhEf"]
                pub fn rc_atanh1(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math6rc_logEd"]
                pub fn rc_log(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math6rc_logEf"]
                pub fn rc_log1(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_log2Ed"]
                pub fn rc_log2(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_log2Ef"]
                pub fn rc_log21(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_log10Ed"]
                pub fn rc_log10(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math8rc_log10Ef"]
                pub fn rc_log101(arg1: f32) -> root::FloatComplex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_sqrtEd"]
                pub fn rc_sqrt(arg1: f64) -> root::Complex;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math7rc_sqrtEf"]
                pub fn rc_sqrt1(arg1: f32) -> root::FloatComplex;
            }
            #[repr(C)]
            pub struct aepbalance__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct aepbalance<MT> {
                pub vtable_: *const aepbalance__bindgen_vtable,
                pub balanced_mat: MT,
                pub scale: root::octave::math::aepbalance_VT,
                pub ilo: root::octave_idx_type,
                pub ihi: root::octave_idx_type,
                pub job: ::std::os::raw::c_char,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<MT>>,
            }
            pub type aepbalance_VT = [u8; 0usize];
            #[repr(C)]
            pub struct gepbalance<T> {
                pub balanced_mat: T,
                pub balanced_mat2: T,
                pub balancing_mat: root::octave::math::gepbalance_RT,
                pub balancing_mat2: root::octave::math::gepbalance_RT,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub type gepbalance_RT = [u8; 0usize];
            #[repr(C)]
            pub struct chol<T> {
                pub chol_mat: T,
                pub xrcond: root::octave::math::chol_COND_T,
                pub is_upper: bool,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub type chol_VT = [u8; 0usize];
            pub type chol_COND_T = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug)]
            pub struct hess<T> {
                pub hess_mat: T,
                pub unitary_hess_mat: T,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct schur<T> {
                pub schur_mat: T,
                pub unitary_mat: T,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            pub struct svd<T> {
                pub m_type: root::octave::math::svd_Type,
                pub m_driver: root::octave::math::svd_Driver,
                pub left_sm: T,
                pub sigma: root::octave::math::svd_DM_T,
                pub right_sm: T,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub type svd_DM_T = [u8; 0usize];
            pub const svd_Type_std: root::octave::math::svd_Type = 0;
            pub const svd_Type_economy: root::octave::math::svd_Type = 0;
            pub const svd_Type_sigma_only: root::octave::math::svd_Type = 0;
            pub type svd_Type = i32;
            pub const svd_Driver_GESVD: root::octave::math::svd_Driver = 0;
            pub const svd_Driver_GESDD: root::octave::math::svd_Driver = 0;
            pub type svd_Driver = i32;
            pub type svd_P = [u8; 0usize];
            pub type svd_DM_P = [u8; 0usize];
            #[repr(C)]
            pub struct gsvd<T> {
                pub type_: root::octave::math::gsvd_Type,
                pub sigmaA: [u8; 0usize],
                pub sigmaB: [u8; 0usize],
                pub left_smA: T,
                pub left_smB: T,
                pub right_sm: T,
                pub R: T,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub const gsvd_Type_std: root::octave::math::gsvd_Type = 0;
            pub const gsvd_Type_economy: root::octave::math::gsvd_Type = 0;
            pub const gsvd_Type_sigma_only: root::octave::math::gsvd_Type = 0;
            pub type gsvd_Type = i32;
            pub type gsvd_P = [u8; 0usize];
            pub type gsvd_real_matrix = [u8; 0usize];
            #[repr(C)]
            pub struct lu__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct lu<T> {
                pub vtable_: *const lu__bindgen_vtable,
                pub a_fact: T,
                pub l_fact: T,
                pub ipvt: root::Array<root::octave_f77_int_type>,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub type lu_VT = [u8; 0usize];
            pub type lu_ELT_T = [u8; 0usize];
            #[repr(C)]
            pub struct qr__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct qr<T> {
                pub vtable_: *const qr__bindgen_vtable,
                pub q: T,
                pub r: T,
                pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            }
            pub type qr_ELT_T = [u8; 0usize];
            pub type qr_RV_T = [u8; 0usize];
            pub type qr_CV_T = [u8; 0usize];
            pub const qr_type_std: root::octave::math::qr_type = 0;
            pub const qr_type_raw: root::octave::math::qr_type = 0;
            pub const qr_type_economy: root::octave::math::qr_type = 0;
            pub type qr_type = i32;
            extern "C" {
                #[link_name = "\u{1}_ZN6octave4math18warn_qrupdate_onceEv"]
                pub fn warn_qrupdate_once();
            }
        }
        pub mod sys {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct time {
                pub ot_unix_time: root::time_t,
                pub ot_usec: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_time() {
                assert_eq!(
                    ::core::mem::size_of::<time>(),
                    16usize,
                    concat!("Size of: ", stringify!(time))
                );
                assert_eq!(
                    ::core::mem::align_of::<time>(),
                    8usize,
                    concat!("Alignment of ", stringify!(time))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<time>())).ot_unix_time as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(time),
                        "::",
                        stringify!(ot_unix_time)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<time>())).ot_usec as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(time),
                        "::",
                        stringify!(ot_usec)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys4time5stampEv"]
                pub fn time_stamp(this: *mut root::octave::sys::time);
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK6octave3sys4time5ctimeB5cxx11Ev"]
                pub fn time_ctime(this: *const root::octave::sys::time) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys4timeC1Ed"]
                pub fn time_time(this: *mut root::octave::sys::time, d: f64);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys4timeC1ERKNS0_7base_tmE"]
                pub fn time_time1(
                    this: *mut root::octave::sys::time,
                    tm: *const root::octave::sys::base_tm,
                );
            }
            impl time {
                #[inline]
                pub unsafe fn stamp(&mut self) {
                    time_stamp(self)
                }
                #[inline]
                pub unsafe fn ctime(&self) -> root::std::string {
                    time_ctime(self)
                }
                #[inline]
                pub unsafe fn new(d: f64) -> Self {
                    let mut __bindgen_tmp = ::core::mem::uninitialized();
                    time_time(&mut __bindgen_tmp, d);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(tm: *const root::octave::sys::base_tm) -> Self {
                    let mut __bindgen_tmp = ::core::mem::uninitialized();
                    time_time1(&mut __bindgen_tmp, tm);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            pub struct base_tm__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct base_tm {
                pub vtable_: *const base_tm__bindgen_vtable,
                pub m_usec: ::std::os::raw::c_int,
                pub m_sec: ::std::os::raw::c_int,
                pub m_min: ::std::os::raw::c_int,
                pub m_hour: ::std::os::raw::c_int,
                pub m_mday: ::std::os::raw::c_int,
                pub m_mon: ::std::os::raw::c_int,
                pub m_year: ::std::os::raw::c_int,
                pub m_wday: ::std::os::raw::c_int,
                pub m_yday: ::std::os::raw::c_int,
                pub m_isdst: ::std::os::raw::c_int,
                pub m_gmtoff: ::std::os::raw::c_long,
                pub m_zone: root::std::string,
            }
            #[test]
            fn bindgen_test_layout_base_tm() {
                assert_eq!(
                    ::core::mem::size_of::<base_tm>(),
                    88usize,
                    concat!("Size of: ", stringify!(base_tm))
                );
                assert_eq!(
                    ::core::mem::align_of::<base_tm>(),
                    8usize,
                    concat!("Alignment of ", stringify!(base_tm))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_usec as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_usec)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_sec as *const _ as usize },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_sec)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_min as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_min)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_hour as *const _ as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_hour)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_mday as *const _ as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_mday)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_mon as *const _ as usize },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_mon)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_year as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_year)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_wday as *const _ as usize },
                    36usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_wday)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_yday as *const _ as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_yday)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_isdst as *const _ as usize },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_isdst)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_gmtoff as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_gmtoff)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<base_tm>())).m_zone as *const _ as usize },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(base_tm),
                        "::",
                        stringify!(m_zone)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4usecEi"]
                pub fn base_tm_usec(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm3secEi"]
                pub fn base_tm_sec(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm3minEi"]
                pub fn base_tm_min(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4hourEi"]
                pub fn base_tm_hour(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4mdayEi"]
                pub fn base_tm_mday(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm3monEi"]
                pub fn base_tm_mon(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4yearEi"]
                pub fn base_tm_year(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4wdayEi"]
                pub fn base_tm_wday(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4ydayEi"]
                pub fn base_tm_yday(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm5isdstEi"]
                pub fn base_tm_isdst(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm6gmtoffEl"]
                pub fn base_tm_gmtoff(
                    this: *mut root::octave::sys::base_tm,
                    v: ::std::os::raw::c_long,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4zoneERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn base_tm_zone(
                    this: *mut root::octave::sys::base_tm,
                    s: *const root::std::string,
                ) -> *mut root::octave::sys::base_tm;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK6octave3sys7base_tm8strftimeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn base_tm_strftime(
                    this: *const root::octave::sys::base_tm,
                    fmt: *const root::std::string,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys7base_tm4initEPv"]
                pub fn base_tm_init(
                    this: *mut root::octave::sys::base_tm,
                    p: *mut ::std::os::raw::c_void,
                );
            }
            impl base_tm {
                #[inline]
                pub unsafe fn usec(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_usec(self, v)
                }
                #[inline]
                pub unsafe fn sec(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_sec(self, v)
                }
                #[inline]
                pub unsafe fn min(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_min(self, v)
                }
                #[inline]
                pub unsafe fn hour(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_hour(self, v)
                }
                #[inline]
                pub unsafe fn mday(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_mday(self, v)
                }
                #[inline]
                pub unsafe fn mon(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_mon(self, v)
                }
                #[inline]
                pub unsafe fn year(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_year(self, v)
                }
                #[inline]
                pub unsafe fn wday(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_wday(self, v)
                }
                #[inline]
                pub unsafe fn yday(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_yday(self, v)
                }
                #[inline]
                pub unsafe fn isdst(
                    &mut self,
                    v: ::std::os::raw::c_int,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_isdst(self, v)
                }
                #[inline]
                pub unsafe fn gmtoff(
                    &mut self,
                    v: ::std::os::raw::c_long,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_gmtoff(self, v)
                }
                #[inline]
                pub unsafe fn zone(
                    &mut self,
                    s: *const root::std::string,
                ) -> *mut root::octave::sys::base_tm {
                    base_tm_zone(self, s)
                }
                #[inline]
                pub unsafe fn strftime(&self, fmt: *const root::std::string) -> root::std::string {
                    base_tm_strftime(self, fmt)
                }
                #[inline]
                pub unsafe fn init(&mut self, p: *mut ::std::os::raw::c_void) {
                    base_tm_init(self, p)
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct localtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_localtime() {
                assert_eq!(
                    ::core::mem::size_of::<localtime>(),
                    88usize,
                    concat!("Size of: ", stringify!(localtime))
                );
                assert_eq!(
                    ::core::mem::align_of::<localtime>(),
                    8usize,
                    concat!("Alignment of ", stringify!(localtime))
                );
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct gmtime {
                pub _base: root::octave::sys::base_tm,
            }
            #[test]
            fn bindgen_test_layout_gmtime() {
                assert_eq!(
                    ::core::mem::size_of::<gmtime>(),
                    88usize,
                    concat!("Size of: ", stringify!(gmtime))
                );
                assert_eq!(
                    ::core::mem::align_of::<gmtime>(),
                    8usize,
                    concat!("Alignment of ", stringify!(gmtime))
                );
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct strptime {
                pub _base: root::octave::sys::base_tm,
                pub nchars: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_strptime() {
                assert_eq!(
                    ::core::mem::size_of::<strptime>(),
                    96usize,
                    concat!("Size of: ", stringify!(strptime))
                );
                assert_eq!(
                    ::core::mem::align_of::<strptime>(),
                    8usize,
                    concat!("Alignment of ", stringify!(strptime))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<strptime>())).nchars as *const _ as usize },
                    88usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(strptime),
                        "::",
                        stringify!(nchars)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct cpu_time {
                pub m_usr_sec: root::time_t,
                pub m_sys_sec: root::time_t,
                pub m_usr_usec: ::std::os::raw::c_long,
                pub m_sys_usec: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_cpu_time() {
                assert_eq!(
                    ::core::mem::size_of::<cpu_time>(),
                    32usize,
                    concat!("Size of: ", stringify!(cpu_time))
                );
                assert_eq!(
                    ::core::mem::align_of::<cpu_time>(),
                    8usize,
                    concat!("Alignment of ", stringify!(cpu_time))
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<cpu_time>())).m_usr_sec as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(cpu_time),
                        "::",
                        stringify!(m_usr_sec)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::core::ptr::null::<cpu_time>())).m_sys_sec as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(cpu_time),
                        "::",
                        stringify!(m_sys_sec)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<cpu_time>())).m_usr_usec as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(cpu_time),
                        "::",
                        stringify!(m_usr_usec)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<cpu_time>())).m_sys_usec as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(cpu_time),
                        "::",
                        stringify!(m_sys_usec)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys8cpu_time5stampEv"]
                pub fn cpu_time_stamp(this: *mut root::octave::sys::cpu_time);
            }
            impl cpu_time {
                #[inline]
                pub unsafe fn stamp(&mut self) {
                    cpu_time_stamp(self)
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct resource_usage {
                pub m_cpu: root::octave::sys::cpu_time,
                pub m_maxrss: ::std::os::raw::c_long,
                pub m_ixrss: ::std::os::raw::c_long,
                pub m_idrss: ::std::os::raw::c_long,
                pub m_isrss: ::std::os::raw::c_long,
                pub m_minflt: ::std::os::raw::c_long,
                pub m_majflt: ::std::os::raw::c_long,
                pub m_nswap: ::std::os::raw::c_long,
                pub m_inblock: ::std::os::raw::c_long,
                pub m_oublock: ::std::os::raw::c_long,
                pub m_msgsnd: ::std::os::raw::c_long,
                pub m_msgrcv: ::std::os::raw::c_long,
                pub m_nsignals: ::std::os::raw::c_long,
                pub m_nvcsw: ::std::os::raw::c_long,
                pub m_nivcsw: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_resource_usage() {
                assert_eq!(
                    ::core::mem::size_of::<resource_usage>(),
                    144usize,
                    concat!("Size of: ", stringify!(resource_usage))
                );
                assert_eq!(
                    ::core::mem::align_of::<resource_usage>(),
                    8usize,
                    concat!("Alignment of ", stringify!(resource_usage))
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_cpu as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_cpu)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_maxrss as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_maxrss)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_ixrss as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_ixrss)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_idrss as *const _ as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_idrss)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_isrss as *const _ as usize
                    },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_isrss)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_minflt as *const _ as usize
                    },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_minflt)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_majflt as *const _ as usize
                    },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_majflt)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_nswap as *const _ as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_nswap)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_inblock as *const _ as usize
                    },
                    88usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_inblock)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_oublock as *const _ as usize
                    },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_oublock)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_msgsnd as *const _ as usize
                    },
                    104usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_msgsnd)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_msgrcv as *const _ as usize
                    },
                    112usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_msgrcv)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_nsignals as *const _ as usize
                    },
                    120usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_nsignals)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_nvcsw as *const _ as usize
                    },
                    128usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_nvcsw)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::core::ptr::null::<resource_usage>())).m_nivcsw as *const _ as usize
                    },
                    136usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(resource_usage),
                        "::",
                        stringify!(m_nivcsw)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave3sys14resource_usage5stampEv"]
                pub fn resource_usage_stamp(this: *mut root::octave::sys::resource_usage);
            }
            impl resource_usage {
                #[inline]
                pub unsafe fn stamp(&mut self) {
                    resource_usage_stamp(self)
                }
            }
        }
        pub mod mach_info {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const float_format_flt_fmt_unknown: root::octave::mach_info::float_format = 0;
            pub const float_format_flt_fmt_ieee_little_endian:
                root::octave::mach_info::float_format = 1;
            pub const float_format_flt_fmt_ieee_big_endian: root::octave::mach_info::float_format =
                2;
            pub type float_format = u32;
            extern "C" {
                #[link_name = "\u{1}_ZN6octave9mach_info19native_float_formatEv"]
                pub fn native_float_format() -> root::octave::mach_info::float_format;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave9mach_info16words_big_endianEv"]
                pub fn words_big_endian() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave9mach_info19words_little_endianEv"]
                pub fn words_little_endian() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave9mach_info22string_to_float_formatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn string_to_float_format(
                    arg1: *const root::std::string,
                ) -> root::octave::mach_info::float_format;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN6octave9mach_info22float_format_as_stringB5cxx11ENS0_12float_formatE"]
                pub fn float_format_as_string(
                    arg1: root::octave::mach_info::float_format,
                ) -> root::std::string;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct interpreter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct scanf_format_elt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct scanf_format_list {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct printf_format_elt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct printf_format_list {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct base_stream__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct base_stream {
            pub vtable_: *const base_stream__bindgen_vtable,
            pub count: root::octave::refcount<root::octave_idx_type>,
            pub md: ::std::os::raw::c_int,
            pub flt_fmt: root::octave::mach_info::float_format,
            pub fail: bool,
            pub open_state: bool,
            pub errmsg: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_base_stream() {
            assert_eq!(
                ::core::mem::size_of::<base_stream>(),
                64usize,
                concat!("Size of: ", stringify!(base_stream))
            );
            assert_eq!(
                ::core::mem::align_of::<base_stream>(),
                8usize,
                concat!("Alignment of ", stringify!(base_stream))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).count as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(count)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).md as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(md)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).flt_fmt as *const _ as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(flt_fmt)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).fail as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(fail)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).open_state as *const _ as usize },
                25usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(open_state)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<base_stream>())).errmsg as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(base_stream),
                    "::",
                    stringify!(errmsg)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11base_stream5errorB5cxx11EbRi"]
            pub fn base_stream_error(
                this: *mut root::octave::base_stream,
                clear: bool,
                err_num: *mut ::std::os::raw::c_int,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11base_stream5errorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn base_stream_error1(
                this: *mut root::octave::base_stream,
                msg: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11base_stream5errorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn base_stream_error2(
                this: *mut root::octave::base_stream,
                who: *const root::std::string,
                msg: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11base_stream5clearEv"]
            pub fn base_stream_clear(this: *mut root::octave::base_stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11base_stream8clearerrEv"]
            pub fn base_stream_clearerr(this: *mut root::octave::base_stream);
        }
        impl base_stream {
            #[inline]
            pub unsafe fn error(
                &mut self,
                clear: bool,
                err_num: *mut ::std::os::raw::c_int,
            ) -> root::std::string {
                base_stream_error(self, clear, err_num)
            }
            #[inline]
            pub unsafe fn error1(&mut self, msg: *const root::std::string) {
                base_stream_error1(self, msg)
            }
            #[inline]
            pub unsafe fn error2(
                &mut self,
                who: *const root::std::string,
                msg: *const root::std::string,
            ) {
                base_stream_error2(self, who, msg)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                base_stream_clear(self)
            }
            #[inline]
            pub unsafe fn clearerr(&mut self) {
                base_stream_clearerr(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct stream {
            pub rep: *mut root::octave::base_stream,
        }
        #[test]
        fn bindgen_test_layout_stream() {
            assert_eq!(
                ::core::mem::size_of::<stream>(),
                8usize,
                concat!("Size of: ", stringify!(stream))
            );
            assert_eq!(
                ::core::mem::align_of::<stream>(),
                8usize,
                concat!("Alignment of ", stringify!(stream))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<stream>())).rep as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream),
                    "::",
                    stringify!(rep)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5flushEv"]
            pub fn stream_flush(this: *mut root::octave::stream) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4getlElRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_getl(
                this: *mut root::octave::stream,
                max_len: root::octave_idx_type,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4getlERK12octave_valueRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_getl1(
                this: *mut root::octave::stream,
                max_len: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4getsElRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_gets(
                this: *mut root::octave::stream,
                max_len: root::octave_idx_type,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4getsERK12octave_valueRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_gets1(
                this: *mut root::octave::stream,
                max_len: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5skiplElRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_skipl(
                this: *mut root::octave::stream,
                count: root::off_t,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::off_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5skiplERK12octave_valueRbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_skipl1(
                this: *mut root::octave::stream,
                count: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::off_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4seekEli"]
            pub fn stream_seek(
                this: *mut root::octave::stream,
                offset: root::off_t,
                origin: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4seekERK12octave_valueS3_"]
            pub fn stream_seek1(
                this: *mut root::octave::stream,
                offset: *const root::octave_value,
                origin: *const root::octave_value,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4tellEv"]
            pub fn stream_tell(this: *mut root::octave::stream) -> root::off_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream6rewindEv"]
            pub fn stream_rewind(this: *mut root::octave::stream) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave6stream7is_openEv"]
            pub fn stream_is_open(this: *const root::octave::stream) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5closeEv"]
            pub fn stream_close(this: *mut root::octave::stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4readERK5ArrayIdElN13oct_data_conv9data_typeES6_lNS_9mach_info12float_formatERl"]
            pub fn stream_read(
                this: *mut root::octave::stream,
                size: *const root::Array<f64>,
                block_size: root::octave_idx_type,
                input_type: root::oct_data_conv_data_type,
                output_type: root::oct_data_conv_data_type,
                skip: root::octave_idx_type,
                flt_fmt: root::octave::mach_info::float_format,
                count: *mut root::octave_idx_type,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5writeERK12octave_valuelN13oct_data_conv9data_typeElNS_9mach_info12float_formatE"]
            pub fn stream_write(
                this: *mut root::octave::stream,
                data: *const root::octave_value,
                block_size: root::octave_idx_type,
                output_type: root::oct_data_conv_data_type,
                skip: root::octave_idx_type,
                flt_fmt: root::octave::mach_info::float_format,
            ) -> root::octave_idx_type;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream11write_bytesEPKvm"]
            pub fn stream_write_bytes(
                this: *mut root::octave::stream,
                data: *const ::std::os::raw::c_void,
                n_elts: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream10skip_bytesEm"]
            pub fn stream_skip_bytes(this: *mut root::octave::stream, n_elts: usize) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5scanfERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK5ArrayIdERlS8_"]
            pub fn stream_scanf(
                this: *mut root::octave::stream,
                fmt: *const root::std::string,
                size: *const root::Array<f64>,
                count: *mut root::octave_idx_type,
                who: *const root::std::string,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5scanfERK12octave_valueRK5ArrayIdERlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_scanf1(
                this: *mut root::octave::stream,
                fmt: *const root::octave_value,
                size: *const root::Array<f64>,
                count: *mut root::octave_idx_type,
                who: *const root::std::string,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream6oscanfERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn stream_oscanf(
                this: *mut root::octave::stream,
                fmt: *const root::std::string,
                who: *const root::std::string,
            ) -> root::octave_value_list;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream6oscanfERK12octave_valueRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_oscanf1(
                this: *mut root::octave::stream,
                fmt: *const root::octave_value,
                who: *const root::std::string,
            ) -> root::octave_value_list;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream8textscanERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEElRK17octave_value_listS8_Rl"]
            pub fn stream_textscan(
                this: *mut root::octave::stream,
                fmt: *const root::std::string,
                ntimes: root::octave_idx_type,
                options: *const root::octave_value_list,
                who: *const root::std::string,
                count: *mut root::octave_idx_type,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream6printfERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK17octave_value_listS8_"]
            pub fn stream_printf(
                this: *mut root::octave::stream,
                fmt: *const root::std::string,
                args: *const root::octave_value_list,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream6printfERK12octave_valueRK17octave_value_listRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_printf1(
                this: *mut root::octave::stream,
                fmt: *const root::octave_value,
                args: *const root::octave_value_list,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4putsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn stream_puts(
                this: *mut root::octave::stream,
                s: *const root::std::string,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream4putsERK12octave_valueRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_puts1(
                this: *mut root::octave::stream,
                s: *const root::octave_value,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave6stream3eofEv"]
            pub fn stream_eof(this: *const root::octave::stream) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream5errorB5cxx11EbRi"]
            pub fn stream_error(
                this: *mut root::octave::stream,
                clear: bool,
                err_num: *mut ::std::os::raw::c_int,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave6stream4nameB5cxx11Ev"]
            pub fn stream_name(this: *const root::octave::stream) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave6stream4modeEv"]
            pub fn stream_mode(this: *const root::octave::stream) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave6stream12float_formatEv"]
            pub fn stream_float_format(
                this: *const root::octave::stream,
            ) -> root::octave::mach_info::float_format;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6stream14mode_as_stringB5cxx11Ei"]
            pub fn stream_mode_as_string(mode: ::std::os::raw::c_int) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6streamC1EPNS_11base_streamE"]
            pub fn stream_stream(
                this: *mut root::octave::stream,
                bs: *mut root::octave::base_stream,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6streamC1ERKS0_"]
            pub fn stream_stream1(
                this: *mut root::octave::stream,
                arg1: *const root::octave::stream,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6streamD1Ev"]
            pub fn stream_stream_destructor(this: *mut root::octave::stream);
        }
        impl stream {
            #[inline]
            pub unsafe fn flush(&mut self) -> ::std::os::raw::c_int {
                stream_flush(self)
            }
            #[inline]
            pub unsafe fn getl(
                &mut self,
                max_len: root::octave_idx_type,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string {
                stream_getl(self, max_len, err, who)
            }
            #[inline]
            pub unsafe fn getl1(
                &mut self,
                max_len: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string {
                stream_getl1(self, max_len, err, who)
            }
            #[inline]
            pub unsafe fn gets(
                &mut self,
                max_len: root::octave_idx_type,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string {
                stream_gets(self, max_len, err, who)
            }
            #[inline]
            pub unsafe fn gets1(
                &mut self,
                max_len: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::std::string {
                stream_gets1(self, max_len, err, who)
            }
            #[inline]
            pub unsafe fn skipl(
                &mut self,
                count: root::off_t,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::off_t {
                stream_skipl(self, count, err, who)
            }
            #[inline]
            pub unsafe fn skipl1(
                &mut self,
                count: *const root::octave_value,
                err: *mut bool,
                who: *const root::std::string,
            ) -> root::off_t {
                stream_skipl1(self, count, err, who)
            }
            #[inline]
            pub unsafe fn seek(
                &mut self,
                offset: root::off_t,
                origin: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                stream_seek(self, offset, origin)
            }
            #[inline]
            pub unsafe fn seek1(
                &mut self,
                offset: *const root::octave_value,
                origin: *const root::octave_value,
            ) -> ::std::os::raw::c_int {
                stream_seek1(self, offset, origin)
            }
            #[inline]
            pub unsafe fn tell(&mut self) -> root::off_t {
                stream_tell(self)
            }
            #[inline]
            pub unsafe fn rewind(&mut self) -> ::std::os::raw::c_int {
                stream_rewind(self)
            }
            #[inline]
            pub unsafe fn is_open(&self) -> bool {
                stream_is_open(self)
            }
            #[inline]
            pub unsafe fn close(&mut self) {
                stream_close(self)
            }
            #[inline]
            pub unsafe fn read(
                &mut self,
                size: *const root::Array<f64>,
                block_size: root::octave_idx_type,
                input_type: root::oct_data_conv_data_type,
                output_type: root::oct_data_conv_data_type,
                skip: root::octave_idx_type,
                flt_fmt: root::octave::mach_info::float_format,
                count: *mut root::octave_idx_type,
            ) -> root::octave_value {
                stream_read(
                    self,
                    size,
                    block_size,
                    input_type,
                    output_type,
                    skip,
                    flt_fmt,
                    count,
                )
            }
            #[inline]
            pub unsafe fn write(
                &mut self,
                data: *const root::octave_value,
                block_size: root::octave_idx_type,
                output_type: root::oct_data_conv_data_type,
                skip: root::octave_idx_type,
                flt_fmt: root::octave::mach_info::float_format,
            ) -> root::octave_idx_type {
                stream_write(self, data, block_size, output_type, skip, flt_fmt)
            }
            #[inline]
            pub unsafe fn write_bytes(
                &mut self,
                data: *const ::std::os::raw::c_void,
                n_elts: usize,
            ) -> bool {
                stream_write_bytes(self, data, n_elts)
            }
            #[inline]
            pub unsafe fn skip_bytes(&mut self, n_elts: usize) -> bool {
                stream_skip_bytes(self, n_elts)
            }
            #[inline]
            pub unsafe fn scanf(
                &mut self,
                fmt: *const root::std::string,
                size: *const root::Array<f64>,
                count: *mut root::octave_idx_type,
                who: *const root::std::string,
            ) -> root::octave_value {
                stream_scanf(self, fmt, size, count, who)
            }
            #[inline]
            pub unsafe fn scanf1(
                &mut self,
                fmt: *const root::octave_value,
                size: *const root::Array<f64>,
                count: *mut root::octave_idx_type,
                who: *const root::std::string,
            ) -> root::octave_value {
                stream_scanf1(self, fmt, size, count, who)
            }
            #[inline]
            pub unsafe fn oscanf(
                &mut self,
                fmt: *const root::std::string,
                who: *const root::std::string,
            ) -> root::octave_value_list {
                stream_oscanf(self, fmt, who)
            }
            #[inline]
            pub unsafe fn oscanf1(
                &mut self,
                fmt: *const root::octave_value,
                who: *const root::std::string,
            ) -> root::octave_value_list {
                stream_oscanf1(self, fmt, who)
            }
            #[inline]
            pub unsafe fn textscan(
                &mut self,
                fmt: *const root::std::string,
                ntimes: root::octave_idx_type,
                options: *const root::octave_value_list,
                who: *const root::std::string,
                count: *mut root::octave_idx_type,
            ) -> root::octave_value {
                stream_textscan(self, fmt, ntimes, options, who, count)
            }
            #[inline]
            pub unsafe fn printf(
                &mut self,
                fmt: *const root::std::string,
                args: *const root::octave_value_list,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_printf(self, fmt, args, who)
            }
            #[inline]
            pub unsafe fn printf1(
                &mut self,
                fmt: *const root::octave_value,
                args: *const root::octave_value_list,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_printf1(self, fmt, args, who)
            }
            #[inline]
            pub unsafe fn puts(
                &mut self,
                s: *const root::std::string,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_puts(self, s, who)
            }
            #[inline]
            pub unsafe fn puts1(
                &mut self,
                s: *const root::octave_value,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_puts1(self, s, who)
            }
            #[inline]
            pub unsafe fn eof(&self) -> bool {
                stream_eof(self)
            }
            #[inline]
            pub unsafe fn error(
                &mut self,
                clear: bool,
                err_num: *mut ::std::os::raw::c_int,
            ) -> root::std::string {
                stream_error(self, clear, err_num)
            }
            #[inline]
            pub unsafe fn name(&self) -> root::std::string {
                stream_name(self)
            }
            #[inline]
            pub unsafe fn mode(&self) -> ::std::os::raw::c_int {
                stream_mode(self)
            }
            #[inline]
            pub unsafe fn float_format(&self) -> root::octave::mach_info::float_format {
                stream_float_format(self)
            }
            #[inline]
            pub unsafe fn mode_as_string(mode: ::std::os::raw::c_int) -> root::std::string {
                stream_mode_as_string(mode)
            }
            #[inline]
            pub unsafe fn new(bs: *mut root::octave::base_stream) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                stream_stream(&mut __bindgen_tmp, bs);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::octave::stream) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                stream_stream1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                stream_stream_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct stream_list {
            pub list: root::octave::stream_list_ostrl_map,
            pub lookup_cache: u64,
            pub m_stdin_file: ::std::os::raw::c_int,
            pub m_stdout_file: ::std::os::raw::c_int,
            pub m_stderr_file: ::std::os::raw::c_int,
        }
        pub type stream_list_ostrl_map = [u64; 6usize];
        #[test]
        fn bindgen_test_layout_stream_list() {
            assert_eq!(
                ::core::mem::size_of::<stream_list>(),
                72usize,
                concat!("Size of: ", stringify!(stream_list))
            );
            assert_eq!(
                ::core::mem::align_of::<stream_list>(),
                8usize,
                concat!("Alignment of ", stringify!(stream_list))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<stream_list>())).list as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream_list),
                    "::",
                    stringify!(list)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<stream_list>())).lookup_cache as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream_list),
                    "::",
                    stringify!(lookup_cache)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<stream_list>())).m_stdin_file as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream_list),
                    "::",
                    stringify!(m_stdin_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<stream_list>())).m_stdout_file as *const _ as usize
                },
                60usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream_list),
                    "::",
                    stringify!(m_stdout_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<stream_list>())).m_stderr_file as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(stream_list),
                    "::",
                    stringify!(m_stderr_file)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_list6insertERNS_6streamE"]
            pub fn stream_list_insert(
                this: *mut root::octave::stream_list,
                os: *mut root::octave::stream,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list6lookupEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_list_lookup(
                this: *const root::octave::stream_list,
                fid: ::std::os::raw::c_int,
                who: *const root::std::string,
            ) -> root::octave::stream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list6lookupERK12octave_valueRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_list_lookup1(
                this: *const root::octave::stream_list,
                fid: *const root::octave_value,
                who: *const root::std::string,
            ) -> root::octave::stream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_list6removeEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_list_remove(
                this: *mut root::octave::stream_list,
                fid: ::std::os::raw::c_int,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_list6removeERK12octave_valueRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn stream_list_remove1(
                this: *mut root::octave::stream_list,
                fid: *const root::octave_value,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_list5clearEb"]
            pub fn stream_list_clear(this: *mut root::octave::stream_list, flush: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list8get_infoEi"]
            pub fn stream_list_get_info(
                this: *const root::octave::stream_list,
                fid: ::std::os::raw::c_int,
            ) -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list8get_infoERK12octave_value"]
            pub fn stream_list_get_info1(
                this: *const root::octave::stream_list,
                fid: *const root::octave_value,
            ) -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list15list_open_filesB5cxx11Ev"]
            pub fn stream_list_list_open_files(
                this: *const root::octave::stream_list,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list17open_file_numbersEv"]
            pub fn stream_list_open_file_numbers(
                this: *const root::octave::stream_list,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list15get_file_numberERK12octave_value"]
            pub fn stream_list_get_file_number(
                this: *const root::octave::stream_list,
                fid: *const root::octave_value,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list10stdin_fileEv"]
            pub fn stream_list_stdin_file(
                this: *const root::octave::stream_list,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list11stdout_fileEv"]
            pub fn stream_list_stdout_file(
                this: *const root::octave::stream_list,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11stream_list11stderr_fileEv"]
            pub fn stream_list_stderr_file(
                this: *const root::octave::stream_list,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_listC1ERNS_11interpreterE"]
            pub fn stream_list_stream_list(
                this: *mut root::octave::stream_list,
                interp: *mut root::octave::interpreter,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11stream_listD1Ev"]
            pub fn stream_list_stream_list_destructor(this: *mut root::octave::stream_list);
        }
        impl stream_list {
            #[inline]
            pub unsafe fn insert(
                &mut self,
                os: *mut root::octave::stream,
            ) -> ::std::os::raw::c_int {
                stream_list_insert(self, os)
            }
            #[inline]
            pub unsafe fn lookup(
                &self,
                fid: ::std::os::raw::c_int,
                who: *const root::std::string,
            ) -> root::octave::stream {
                stream_list_lookup(self, fid, who)
            }
            #[inline]
            pub unsafe fn lookup1(
                &self,
                fid: *const root::octave_value,
                who: *const root::std::string,
            ) -> root::octave::stream {
                stream_list_lookup1(self, fid, who)
            }
            #[inline]
            pub unsafe fn remove(
                &mut self,
                fid: ::std::os::raw::c_int,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_list_remove(self, fid, who)
            }
            #[inline]
            pub unsafe fn remove1(
                &mut self,
                fid: *const root::octave_value,
                who: *const root::std::string,
            ) -> ::std::os::raw::c_int {
                stream_list_remove1(self, fid, who)
            }
            #[inline]
            pub unsafe fn clear(&mut self, flush: bool) {
                stream_list_clear(self, flush)
            }
            #[inline]
            pub unsafe fn get_info(&self, fid: ::std::os::raw::c_int) -> root::string_vector {
                stream_list_get_info(self, fid)
            }
            #[inline]
            pub unsafe fn get_info1(&self, fid: *const root::octave_value) -> root::string_vector {
                stream_list_get_info1(self, fid)
            }
            #[inline]
            pub unsafe fn list_open_files(&self) -> root::std::string {
                stream_list_list_open_files(self)
            }
            #[inline]
            pub unsafe fn open_file_numbers(&self) -> root::octave_value {
                stream_list_open_file_numbers(self)
            }
            #[inline]
            pub unsafe fn get_file_number(
                &self,
                fid: *const root::octave_value,
            ) -> ::std::os::raw::c_int {
                stream_list_get_file_number(self, fid)
            }
            #[inline]
            pub unsafe fn stdin_file(&self) -> root::octave_value {
                stream_list_stdin_file(self)
            }
            #[inline]
            pub unsafe fn stdout_file(&self) -> root::octave_value {
                stream_list_stdout_file(self)
            }
            #[inline]
            pub unsafe fn stderr_file(&self) -> root::octave_value {
                stream_list_stderr_file(self)
            }
            #[inline]
            pub unsafe fn new(interp: *mut root::octave::interpreter) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                stream_list_stream_list(&mut __bindgen_tmp, interp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                stream_list_stream_list_destructor(self)
            }
        }
        #[repr(C)]
        pub struct action_container__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct action_container {
            pub vtable_: *const action_container__bindgen_vtable,
        }
        #[repr(C)]
        pub struct action_container_elem__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct action_container_elem {
            pub vtable_: *const action_container_elem__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_action_container_elem() {
            assert_eq!(
                ::core::mem::size_of::<action_container_elem>(),
                8usize,
                concat!("Size of: ", stringify!(action_container_elem))
            );
            assert_eq!(
                ::core::mem::align_of::<action_container_elem>(),
                8usize,
                concat!("Alignment of ", stringify!(action_container_elem))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct action_container_fcn_elem {
            pub _base: root::octave::action_container_elem,
            pub m_fcn: [u64; 4usize],
        }
        #[test]
        fn bindgen_test_layout_action_container_fcn_elem() {
            assert_eq!(
                ::core::mem::size_of::<action_container_fcn_elem>(),
                40usize,
                concat!("Size of: ", stringify!(action_container_fcn_elem))
            );
            assert_eq!(
                ::core::mem::align_of::<action_container_fcn_elem>(),
                8usize,
                concat!("Alignment of ", stringify!(action_container_fcn_elem))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<action_container_fcn_elem>())).m_fcn as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(action_container_fcn_elem),
                    "::",
                    stringify!(m_fcn)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct action_container_restore_var_elem<T> {
            pub _base: root::octave::action_container_elem,
            pub e_ptr: *mut T,
            pub e_val: T,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct action_container_delete_ptr_elem<T> {
            pub _base: root::octave::action_container_elem,
            pub e_ptr: *mut T,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
        }
        #[test]
        fn bindgen_test_layout_action_container() {
            assert_eq!(
                ::core::mem::size_of::<action_container>(),
                8usize,
                concat!("Size of: ", stringify!(action_container))
            );
            assert_eq!(
                ::core::mem::align_of::<action_container>(),
                8usize,
                concat!("Alignment of ", stringify!(action_container))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct unwind_protect {
            pub _base: root::octave::action_container,
            pub lifo: [u64; 10usize],
        }
        #[test]
        fn bindgen_test_layout_unwind_protect() {
            assert_eq!(
                ::core::mem::size_of::<unwind_protect>(),
                88usize,
                concat!("Size of: ", stringify!(unwind_protect))
            );
            assert_eq!(
                ::core::mem::align_of::<unwind_protect>(),
                8usize,
                concat!("Alignment of ", stringify!(unwind_protect))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<unwind_protect>())).lifo as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(unwind_protect),
                    "::",
                    stringify!(lifo)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct unwind_protect_safe {
            pub _base: root::octave::unwind_protect,
        }
        #[test]
        fn bindgen_test_layout_unwind_protect_safe() {
            assert_eq!(
                ::core::mem::size_of::<unwind_protect_safe>(),
                88usize,
                concat!("Size of: ", stringify!(unwind_protect_safe))
            );
            assert_eq!(
                ::core::mem::align_of::<unwind_protect_safe>(),
                8usize,
                concat!("Alignment of ", stringify!(unwind_protect_safe))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17__get_type_info__ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn __get_type_info__(
                arg1: *const root::std::string,
            ) -> *mut root::octave::type_info;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct type_info {
            pub num_types: ::std::os::raw::c_int,
            pub types: root::Array<root::std::string>,
            pub vals: root::Array<*mut root::octave_value>,
            pub unary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub unary_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub non_const_unary_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub binary_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub compound_binary_class_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub compound_binary_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub cat_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub assign_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub assignany_ops: root::Array<*mut ::std::os::raw::c_void>,
            pub pref_assign_conv: root::Array<::std::os::raw::c_int>,
            pub widening_ops: root::Array<*mut ::std::os::raw::c_void>,
        }
        pub type type_info_unary_class_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(arg1: *const root::octave_value) -> root::octave_value,
        >;
        pub type type_info_unary_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(arg1: *const root::octave_base_value) -> root::octave_value,
        >;
        pub type type_info_non_const_unary_op_fcn =
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut root::octave_base_value)>;
        pub type type_info_binary_class_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const root::octave_value,
                arg2: *const root::octave_value,
            ) -> root::octave_value,
        >;
        pub type type_info_binary_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const root::octave_base_value,
                arg2: *const root::octave_base_value,
            ) -> root::octave_value,
        >;
        pub type type_info_cat_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::octave_base_value,
                arg2: *const root::octave_base_value,
                ra_idx: *const root::Array<root::octave_idx_type>,
            ) -> root::octave_value,
        >;
        pub type type_info_assign_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::octave_base_value,
                arg2: *const root::octave_value_list,
                arg3: *const root::octave_base_value,
            ) -> root::octave_value,
        >;
        pub type type_info_assignany_op_fcn = ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::octave_base_value,
                arg2: *const root::octave_value_list,
                arg3: *const root::octave_value,
            ) -> root::octave_value,
        >;
        #[test]
        fn bindgen_test_layout_type_info() {
            assert_eq!(
                ::core::mem::size_of::<type_info>(),
                568usize,
                concat!("Size of: ", stringify!(type_info))
            );
            assert_eq!(
                ::core::mem::align_of::<type_info>(),
                8usize,
                concat!("Alignment of ", stringify!(type_info))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).num_types as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(num_types)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).types as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(types)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).vals as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(vals)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).unary_class_ops as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(unary_class_ops)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).unary_ops as *const _ as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(unary_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).non_const_unary_ops as *const _ as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(non_const_unary_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).binary_class_ops as *const _ as usize
                },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(binary_class_ops)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).binary_ops as *const _ as usize },
                248usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(binary_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).compound_binary_class_ops as *const _
                        as usize
                },
                288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(compound_binary_class_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).compound_binary_ops as *const _ as usize
                },
                328usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(compound_binary_ops)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).cat_ops as *const _ as usize },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(cat_ops)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).assign_ops as *const _ as usize },
                408usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(assign_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).assignany_ops as *const _ as usize
                },
                448usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(assignany_ops)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<type_info>())).pref_assign_conv as *const _ as usize
                },
                488usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(pref_assign_conv)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<type_info>())).widening_ops as *const _ as usize },
                528usize,
                concat!(
                    "Offset of field: ",
                    stringify!(type_info),
                    "::",
                    stringify!(widening_ops)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info13register_typeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_RK12octave_valueb"]
            pub fn type_info_register_type(
                this: *mut root::octave::type_info,
                arg1: *const root::std::string,
                arg2: *const root::std::string,
                arg3: *const root::octave_value,
                abort_on_duplicate: bool,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info23register_unary_class_opEN12octave_value8unary_opEPFS1_RKS1_Eb"]
            pub fn type_info_register_unary_class_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
                arg2: root::octave::type_info_unary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info17register_unary_opEN12octave_value8unary_opEiPFS1_RK17octave_base_valueEb"]
            pub fn type_info_register_unary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_unary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info27register_non_const_unary_opEN12octave_value8unary_opEiPFvR17octave_base_valueEb"]
            pub fn type_info_register_non_const_unary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_non_const_unary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info24register_binary_class_opEN12octave_value9binary_opEPFS1_RKS1_S4_Eb"]
            pub fn type_info_register_binary_class_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_binary_op,
                arg2: root::octave::type_info_binary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info18register_binary_opEN12octave_value9binary_opEiiPFS1_RK17octave_base_valueS5_Eb"]
            pub fn type_info_register_binary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_binary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info24register_binary_class_opEN12octave_value18compound_binary_opEPFS1_RKS1_S4_Eb"]
            pub fn type_info_register_binary_class_op1(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_compound_binary_op,
                arg2: root::octave::type_info_binary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info18register_binary_opEN12octave_value18compound_binary_opEiiPFS1_RK17octave_base_valueS5_Eb"]
            pub fn type_info_register_binary_op1(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_compound_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_binary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info15register_cat_opEiiPF12octave_valueR17octave_base_valueRKS2_RK5ArrayIlEEb"]
            pub fn type_info_register_cat_op(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_cat_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info18register_assign_opEN12octave_value9assign_opEiiPFS1_R17octave_base_valueRK17octave_value_listRKS3_Eb"]
            pub fn type_info_register_assign_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_assign_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info21register_assignany_opEN12octave_value9assign_opEiPFS1_R17octave_base_valueRK17octave_value_listRKS1_Eb"]
            pub fn type_info_register_assignany_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_assignany_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info25register_pref_assign_convEiiib"]
            pub fn type_info_register_pref_assign_conv(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info20register_widening_opEiiPFP17octave_base_valueRKS1_Eb"]
            pub fn type_info_register_widening_op(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave_base_value_type_conv_fcn,
                abort_on_duplicate: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info11lookup_typeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn type_info_lookup_type(
                this: *mut root::octave::type_info,
                nm: *const root::std::string,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info21lookup_unary_class_opEN12octave_value8unary_opE"]
            pub fn type_info_lookup_unary_class_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
            ) -> root::octave::type_info_unary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info15lookup_unary_opEN12octave_value8unary_opEi"]
            pub fn type_info_lookup_unary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_unary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info25lookup_non_const_unary_opEN12octave_value8unary_opEi"]
            pub fn type_info_lookup_non_const_unary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_non_const_unary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info22lookup_binary_class_opEN12octave_value9binary_opE"]
            pub fn type_info_lookup_binary_class_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_binary_op,
            ) -> root::octave::type_info_binary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info16lookup_binary_opEN12octave_value9binary_opEii"]
            pub fn type_info_lookup_binary_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_binary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info22lookup_binary_class_opEN12octave_value18compound_binary_opE"]
            pub fn type_info_lookup_binary_class_op1(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_compound_binary_op,
            ) -> root::octave::type_info_binary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info16lookup_binary_opEN12octave_value18compound_binary_opEii"]
            pub fn type_info_lookup_binary_op1(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_compound_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_binary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info13lookup_cat_opEii"]
            pub fn type_info_lookup_cat_op(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_cat_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info16lookup_assign_opEN12octave_value9assign_opEii"]
            pub fn type_info_lookup_assign_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_assign_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info19lookup_assignany_opEN12octave_value9assign_opEi"]
            pub fn type_info_lookup_assignany_op(
                this: *mut root::octave::type_info,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_assignany_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info23lookup_pref_assign_convEii"]
            pub fn type_info_lookup_pref_assign_conv(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_info18lookup_widening_opEii"]
            pub fn type_info_lookup_widening_op(
                this: *mut root::octave::type_info,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave_base_value_type_conv_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info20installed_type_namesEv"]
            pub fn type_info_installed_type_names(
                this: *const root::octave::type_info,
            ) -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info19installed_type_infoEv"]
            pub fn type_info_installed_type_info(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info13unary_ops_mapEv"]
            pub fn type_info_unary_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info23non_const_unary_ops_mapEv"]
            pub fn type_info_non_const_unary_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info14binary_ops_mapEv"]
            pub fn type_info_binary_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info23compound_binary_ops_mapEv"]
            pub fn type_info_compound_binary_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info14assign_ops_mapEv"]
            pub fn type_info_assign_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave9type_info17assignany_ops_mapEv"]
            pub fn type_info_assignany_ops_map(
                this: *const root::octave::type_info,
            ) -> root::octave_scalar_map;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9type_infoC1Ei"]
            pub fn type_info_type_info(
                this: *mut root::octave::type_info,
                init_tab_sz: ::std::os::raw::c_int,
            );
        }
        impl type_info {
            #[inline]
            pub unsafe fn register_type(
                &mut self,
                arg1: *const root::std::string,
                arg2: *const root::std::string,
                arg3: *const root::octave_value,
                abort_on_duplicate: bool,
            ) -> ::std::os::raw::c_int {
                type_info_register_type(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_unary_class_op(
                &mut self,
                arg1: root::octave_value_unary_op,
                arg2: root::octave::type_info_unary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_unary_class_op(self, arg1, arg2, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_unary_op(
                &mut self,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_unary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_unary_op(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_non_const_unary_op(
                &mut self,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_non_const_unary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_non_const_unary_op(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_binary_class_op(
                &mut self,
                arg1: root::octave_value_binary_op,
                arg2: root::octave::type_info_binary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_binary_class_op(self, arg1, arg2, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_binary_op(
                &mut self,
                arg1: root::octave_value_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_binary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_binary_op(self, arg1, arg2, arg3, arg4, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_binary_class_op1(
                &mut self,
                arg1: root::octave_value_compound_binary_op,
                arg2: root::octave::type_info_binary_class_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_binary_class_op1(self, arg1, arg2, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_binary_op1(
                &mut self,
                arg1: root::octave_value_compound_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_binary_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_binary_op1(self, arg1, arg2, arg3, arg4, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_cat_op(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_cat_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_cat_op(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_assign_op(
                &mut self,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: root::octave::type_info_assign_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_assign_op(self, arg1, arg2, arg3, arg4, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_assignany_op(
                &mut self,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave::type_info_assignany_op_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_assignany_op(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_pref_assign_conv(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_pref_assign_conv(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn register_widening_op(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: root::octave_base_value_type_conv_fcn,
                abort_on_duplicate: bool,
            ) -> bool {
                type_info_register_widening_op(self, arg1, arg2, arg3, abort_on_duplicate)
            }
            #[inline]
            pub unsafe fn lookup_type(
                &mut self,
                nm: *const root::std::string,
            ) -> root::octave_value {
                type_info_lookup_type(self, nm)
            }
            #[inline]
            pub unsafe fn lookup_unary_class_op(
                &mut self,
                arg1: root::octave_value_unary_op,
            ) -> root::octave::type_info_unary_class_op_fcn {
                type_info_lookup_unary_class_op(self, arg1)
            }
            #[inline]
            pub unsafe fn lookup_unary_op(
                &mut self,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_unary_op_fcn {
                type_info_lookup_unary_op(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn lookup_non_const_unary_op(
                &mut self,
                arg1: root::octave_value_unary_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_non_const_unary_op_fcn {
                type_info_lookup_non_const_unary_op(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn lookup_binary_class_op(
                &mut self,
                arg1: root::octave_value_binary_op,
            ) -> root::octave::type_info_binary_class_op_fcn {
                type_info_lookup_binary_class_op(self, arg1)
            }
            #[inline]
            pub unsafe fn lookup_binary_op(
                &mut self,
                arg1: root::octave_value_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_binary_op_fcn {
                type_info_lookup_binary_op(self, arg1, arg2, arg3)
            }
            #[inline]
            pub unsafe fn lookup_binary_class_op1(
                &mut self,
                arg1: root::octave_value_compound_binary_op,
            ) -> root::octave::type_info_binary_class_op_fcn {
                type_info_lookup_binary_class_op1(self, arg1)
            }
            #[inline]
            pub unsafe fn lookup_binary_op1(
                &mut self,
                arg1: root::octave_value_compound_binary_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_binary_op_fcn {
                type_info_lookup_binary_op1(self, arg1, arg2, arg3)
            }
            #[inline]
            pub unsafe fn lookup_cat_op(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_cat_op_fcn {
                type_info_lookup_cat_op(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn lookup_assign_op(
                &mut self,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
            ) -> root::octave::type_info_assign_op_fcn {
                type_info_lookup_assign_op(self, arg1, arg2, arg3)
            }
            #[inline]
            pub unsafe fn lookup_assignany_op(
                &mut self,
                arg1: root::octave_value_assign_op,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave::type_info_assignany_op_fcn {
                type_info_lookup_assignany_op(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn lookup_pref_assign_conv(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                type_info_lookup_pref_assign_conv(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn lookup_widening_op(
                &mut self,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> root::octave_base_value_type_conv_fcn {
                type_info_lookup_widening_op(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn installed_type_names(&self) -> root::string_vector {
                type_info_installed_type_names(self)
            }
            #[inline]
            pub unsafe fn installed_type_info(&self) -> root::octave_scalar_map {
                type_info_installed_type_info(self)
            }
            #[inline]
            pub unsafe fn unary_ops_map(&self) -> root::octave_scalar_map {
                type_info_unary_ops_map(self)
            }
            #[inline]
            pub unsafe fn non_const_unary_ops_map(&self) -> root::octave_scalar_map {
                type_info_non_const_unary_ops_map(self)
            }
            #[inline]
            pub unsafe fn binary_ops_map(&self) -> root::octave_scalar_map {
                type_info_binary_ops_map(self)
            }
            #[inline]
            pub unsafe fn compound_binary_ops_map(&self) -> root::octave_scalar_map {
                type_info_compound_binary_ops_map(self)
            }
            #[inline]
            pub unsafe fn assign_ops_map(&self) -> root::octave_scalar_map {
                type_info_assign_ops_map(self)
            }
            #[inline]
            pub unsafe fn assignany_ops_map(&self) -> root::octave_scalar_map {
                type_info_assignany_ops_map(self)
            }
            #[inline]
            pub unsafe fn new(init_tab_sz: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                type_info_type_info(&mut __bindgen_tmp, init_tab_sz);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        pub struct base_list__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct base_list {
            pub vtable_: *const base_list__bindgen_vtable,
            pub m_lst: u8,
        }
        pub type base_list_iterator = u8;
        pub type base_list_const_iterator = u8;
        pub type base_list_reverse_iterator = u8;
        pub type base_list_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct regexp {
            pub pattern: root::std::string,
            pub options: root::octave::regexp_opts,
            pub data: *mut ::std::os::raw::c_void,
            pub m: root::std::string,
            pub named_pats: root::string_vector,
            pub nnames: ::std::os::raw::c_int,
            pub named_idx: root::Array<::std::os::raw::c_int>,
            pub who: root::std::string,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct regexp_opts {
            pub x_case_insensitive: bool,
            pub x_dotexceptnewline: bool,
            pub x_emptymatch: bool,
            pub x_freespacing: bool,
            pub x_lineanchors: bool,
            pub x_once: bool,
        }
        #[test]
        fn bindgen_test_layout_regexp_opts() {
            assert_eq!(
                ::core::mem::size_of::<regexp_opts>(),
                6usize,
                concat!("Size of: ", stringify!(regexp_opts))
            );
            assert_eq!(
                ::core::mem::align_of::<regexp_opts>(),
                1usize,
                concat!("Alignment of ", stringify!(regexp_opts))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_opts>())).x_case_insensitive as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_case_insensitive)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_opts>())).x_dotexceptnewline as *const _ as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_dotexceptnewline)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_opts>())).x_emptymatch as *const _ as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_emptymatch)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_opts>())).x_freespacing as *const _ as usize
                },
                3usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_freespacing)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_opts>())).x_lineanchors as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_lineanchors)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp_opts>())).x_once as *const _ as usize },
                5usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_opts),
                    "::",
                    stringify!(x_once)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct regexp_match_element {
            pub x_match_string: root::std::string,
            pub x_named_tokens: root::string_vector,
            pub x_tokens: root::string_vector,
            pub x_token_extents: root::Matrix,
            pub x_start: f64,
            pub x_end: f64,
        }
        #[test]
        fn bindgen_test_layout_regexp_match_element() {
            assert_eq!(
                ::core::mem::size_of::<regexp_match_element>(),
                168usize,
                concat!("Size of: ", stringify!(regexp_match_element))
            );
            assert_eq!(
                ::core::mem::align_of::<regexp_match_element>(),
                8usize,
                concat!("Alignment of ", stringify!(regexp_match_element))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_match_string as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_match_string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_named_tokens as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_named_tokens)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_tokens as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_tokens)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_token_extents as *const _
                        as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_token_extents)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_start as *const _ as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_start)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_element>())).x_end as *const _ as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_element),
                    "::",
                    stringify!(x_end)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct regexp_match_data {
            pub _base: root::octave::base_list,
            pub named_pats: root::string_vector,
        }
        #[test]
        fn bindgen_test_layout_regexp_match_data() {
            assert_eq!(
                ::core::mem::size_of::<regexp_match_data>(),
                72usize,
                concat!("Size of: ", stringify!(regexp_match_data))
            );
            assert_eq!(
                ::core::mem::align_of::<regexp_match_data>(),
                8usize,
                concat!("Alignment of ", stringify!(regexp_match_data))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<regexp_match_data>())).named_pats as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp_match_data),
                    "::",
                    stringify!(named_pats)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_regexp() {
            assert_eq!(
                ::core::mem::size_of::<regexp>(),
                200usize,
                concat!("Size of: ", stringify!(regexp))
            );
            assert_eq!(
                ::core::mem::align_of::<regexp>(),
                8usize,
                concat!("Alignment of ", stringify!(regexp))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).pattern as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(pattern)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).options as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(options)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).data as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).m as *const _ as usize },
                48usize,
                concat!("Offset of field: ", stringify!(regexp), "::", stringify!(m))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).named_pats as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(named_pats)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).nnames as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(nnames)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).named_idx as *const _ as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(named_idx)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<regexp>())).who as *const _ as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(regexp),
                    "::",
                    stringify!(who)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6regexp5matchERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn regexp_match(
                this: *mut root::octave::regexp,
                buffer: *const root::std::string,
            ) -> root::octave::regexp_match_data;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6regexp8is_matchERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn regexp_is_match(
                this: *mut root::octave::regexp,
                buffer: *const root::std::string,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6regexp8is_matchERK13string_vector"]
            pub fn regexp_is_match1(
                this: *mut root::octave::regexp,
                buffer: *const root::string_vector,
            ) -> root::Array<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6regexp7replaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn regexp_replace(
                this: *mut root::octave::regexp,
                buffer: *const root::std::string,
                replacement: *const root::std::string,
            ) -> root::std::string;
        }
        impl regexp {
            #[inline]
            pub unsafe fn match_(
                &mut self,
                buffer: *const root::std::string,
            ) -> root::octave::regexp_match_data {
                regexp_match(self, buffer)
            }
            #[inline]
            pub unsafe fn is_match(&mut self, buffer: *const root::std::string) -> bool {
                regexp_is_match(self, buffer)
            }
            #[inline]
            pub unsafe fn is_match1(
                &mut self,
                buffer: *const root::string_vector,
            ) -> root::Array<bool> {
                regexp_is_match1(self, buffer)
            }
            #[inline]
            pub unsafe fn replace(
                &mut self,
                buffer: *const root::std::string,
                replacement: *const root::std::string,
            ) -> root::std::string {
                regexp_replace(self, buffer, replacement)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct symbol_record {
            pub m_rep: [u64; 2usize],
        }
        pub type symbol_record_context_id = usize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct symbol_record_symbol_record_rep {
            pub m_storage_class: ::std::os::raw::c_uint,
            pub m_name: root::std::string,
            pub m_fwd_scope: [u64; 2usize],
            pub m_fwd_rep: [u64; 2usize],
            pub m_value_stack: [u64; 10usize],
        }
        #[test]
        fn bindgen_test_layout_symbol_record_symbol_record_rep() {
            assert_eq!(
                ::core::mem::size_of::<symbol_record_symbol_record_rep>(),
                152usize,
                concat!("Size of: ", stringify!(symbol_record_symbol_record_rep))
            );
            assert_eq!(
                ::core::mem::align_of::<symbol_record_symbol_record_rep>(),
                8usize,
                concat!("Alignment of ", stringify!(symbol_record_symbol_record_rep))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_record_symbol_record_rep>())).m_storage_class
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record_symbol_record_rep),
                    "::",
                    stringify!(m_storage_class)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_record_symbol_record_rep>())).m_name as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record_symbol_record_rep),
                    "::",
                    stringify!(m_name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_record_symbol_record_rep>())).m_fwd_scope
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record_symbol_record_rep),
                    "::",
                    stringify!(m_fwd_scope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_record_symbol_record_rep>())).m_fwd_rep
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record_symbol_record_rep),
                    "::",
                    stringify!(m_fwd_rep)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_record_symbol_record_rep>())).m_value_stack
                        as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record_symbol_record_rep),
                    "::",
                    stringify!(m_value_stack)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave13symbol_record17symbol_record_rep21get_fwd_scope_contextEv"]
            pub fn symbol_record_symbol_record_rep_get_fwd_scope_context(
                this: *const root::octave::symbol_record_symbol_record_rep,
            ) -> root::octave::symbol_record_context_id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13symbol_record17symbol_record_rep15init_persistentEv"]
            pub fn symbol_record_symbol_record_rep_init_persistent(
                this: *mut root::octave::symbol_record_symbol_record_rep,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave13symbol_record17symbol_record_rep3dupERKSt10shared_ptrINS_16symbol_scope_repEE"]
            pub fn symbol_record_symbol_record_rep_dup(
                this: *const root::octave::symbol_record_symbol_record_rep,
                new_scope: *const [u64; 2usize],
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave13symbol_record17symbol_record_rep4dumpEm"]
            pub fn symbol_record_symbol_record_rep_dump(
                this: *const root::octave::symbol_record_symbol_record_rep,
                context: root::octave::symbol_record_context_id,
            ) -> root::octave_value;
        }
        impl symbol_record_symbol_record_rep {
            #[inline]
            pub unsafe fn get_fwd_scope_context(&self) -> root::octave::symbol_record_context_id {
                symbol_record_symbol_record_rep_get_fwd_scope_context(self)
            }
            #[inline]
            pub unsafe fn init_persistent(&mut self) {
                symbol_record_symbol_record_rep_init_persistent(self)
            }
            #[inline]
            pub unsafe fn dup(&self, new_scope: *const [u64; 2usize]) -> [u64; 2usize] {
                symbol_record_symbol_record_rep_dup(self, new_scope)
            }
            #[inline]
            pub unsafe fn dump(
                &self,
                context: root::octave::symbol_record_context_id,
            ) -> root::octave_value {
                symbol_record_symbol_record_rep_dump(self, context)
            }
        }
        pub const symbol_record_local: ::std::os::raw::c_uint = 1;
        pub const symbol_record_automatic: ::std::os::raw::c_uint = 2;
        pub const symbol_record_formal: ::std::os::raw::c_uint = 4;
        pub const symbol_record_hidden: ::std::os::raw::c_uint = 8;
        pub const symbol_record_inherited: ::std::os::raw::c_uint = 16;
        pub const symbol_record_global: ::std::os::raw::c_uint = 32;
        pub const symbol_record_persistent: ::std::os::raw::c_uint = 64;
        pub const symbol_record_added_static: ::std::os::raw::c_uint = 128;
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13symbol_record18dummy_octave_valueE"]
            pub static mut symbol_record_dummy_octave_value: root::octave_value;
        }
        #[test]
        fn bindgen_test_layout_symbol_record() {
            assert_eq!(
                ::core::mem::size_of::<symbol_record>(),
                16usize,
                concat!("Size of: ", stringify!(symbol_record))
            );
            assert_eq!(
                ::core::mem::align_of::<symbol_record>(),
                8usize,
                concat!("Alignment of ", stringify!(symbol_record))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<symbol_record>())).m_rep as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_record),
                    "::",
                    stringify!(m_rep)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct symbol_scope_rep {
            pub _base: [u64; 2usize],
            #[doc = "! Name for this scope (usually the corresponding filename of the"]
            #[doc = "! function corresponding to the scope)."]
            pub m_name: root::std::string,
            #[doc = "! Map from symbol names to symbol info."]
            pub m_symbols: [u64; 6usize],
            #[doc = "! Map from symbol names to subfunctions."]
            pub m_subfunctions: [u64; 6usize],
            #[doc = "! The list of subfunctions (if any) in the order they appear in"]
            #[doc = "! the function file."]
            pub m_subfunction_names: [u64; 3usize],
            #[doc = "! The associated user code (may be null)."]
            pub m_fcn: *mut root::octave_user_function,
            #[doc = "! Parent of nested function (may be null)."]
            pub m_parent: [u64; 2usize],
            #[doc = "! Primary (top) parent of nested function (may be null).  Used"]
            #[doc = "! to determine whether two nested functions are related."]
            pub m_primary_parent: [u64; 2usize],
            #[doc = "! Child nested functions."]
            pub m_children: [u64; 3usize],
            #[doc = "! If true, then this scope belongs to a nested function."]
            pub m_nesting_depth: usize,
            #[doc = "! If true then no variables can be added."]
            pub m_is_static: bool,
            pub m_context: root::octave::symbol_record_context_id,
        }
        pub type symbol_scope_rep_table_const_iterator = u64;
        pub type symbol_scope_rep_table_iterator = u64;
        pub type symbol_scope_rep_subfunctions_const_iterator = u64;
        pub type symbol_scope_rep_subfunctions_iterator = u64;
        #[test]
        fn bindgen_test_layout_symbol_scope_rep() {
            assert_eq!(
                ::core::mem::size_of::<symbol_scope_rep>(),
                256usize,
                concat!("Size of: ", stringify!(symbol_scope_rep))
            );
            assert_eq!(
                ::core::mem::align_of::<symbol_scope_rep>(),
                8usize,
                concat!("Alignment of ", stringify!(symbol_scope_rep))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_name as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_symbols as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_symbols)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_subfunctions as *const _
                        as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_subfunctions)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_subfunction_names as *const _
                        as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_subfunction_names)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<symbol_scope_rep>())).m_fcn as *const _ as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_fcn)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_parent as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_primary_parent as *const _
                        as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_primary_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_children as *const _ as usize
                },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_children)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_nesting_depth as *const _
                        as usize
                },
                232usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_nesting_depth)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_is_static as *const _ as usize
                },
                240usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_is_static)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<symbol_scope_rep>())).m_context as *const _ as usize
                },
                248usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope_rep),
                    "::",
                    stringify!(m_context)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep21install_auto_fcn_varsEv"]
            pub fn symbol_scope_rep_install_auto_fcn_vars(
                this: *mut root::octave::symbol_scope_rep,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep20install_auto_fcn_varERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn symbol_scope_rep_install_auto_fcn_var(
                this: *mut root::octave::symbol_scope_rep,
                name: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep4findERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn symbol_scope_rep_find(
                this: *mut root::octave::symbol_scope_rep,
                name: *const root::std::string,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep6insertERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
            pub fn symbol_scope_rep_insert(
                this: *mut root::octave::symbol_scope_rep,
                name: *const root::std::string,
                force_add: bool,
            ) -> *mut root::octave::symbol_record;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave16symbol_scope_rep16find_subfunctionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn symbol_scope_rep_find_subfunction(
                this: *const root::octave::symbol_scope_rep,
                name: *const root::std::string,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep37mark_subfunctions_in_scope_as_privateERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn symbol_scope_rep_mark_subfunctions_in_scope_as_private(
                this: *mut root::octave::symbol_scope_rep,
                class_name: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave16symbol_scope_rep4dumpEv"]
            pub fn symbol_scope_rep_dump(
                this: *const root::octave::symbol_scope_rep,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep10set_parentERKSt10shared_ptrIS0_E"]
            pub fn symbol_scope_rep_set_parent(
                this: *mut root::octave::symbol_scope_rep,
                parent: *const [u64; 2usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep18set_primary_parentERKSt10shared_ptrIS0_E"]
            pub fn symbol_scope_rep_set_primary_parent(
                this: *mut root::octave::symbol_scope_rep,
                parent: *const [u64; 2usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave16symbol_scope_rep11is_relativeERKSt10shared_ptrIS0_E"]
            pub fn symbol_scope_rep_is_relative(
                this: *const root::octave::symbol_scope_rep,
                scope: *const [u64; 2usize],
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep11update_nestEv"]
            pub fn symbol_scope_rep_update_nest(this: *mut root::octave::symbol_scope_rep);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep13look_nonlocalERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERNS_13symbol_recordE"]
            pub fn symbol_scope_rep_look_nonlocal(
                this: *mut root::octave::symbol_scope_rep,
                name: *const root::std::string,
                result: *mut root::octave::symbol_record,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep19bind_script_symbolsERKSt10shared_ptrIS0_E"]
            pub fn symbol_scope_rep_bind_script_symbols(
                this: *mut root::octave::symbol_scope_rep,
                curr_scope: *const [u64; 2usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16symbol_scope_rep21unbind_script_symbolsEv"]
            pub fn symbol_scope_rep_unbind_script_symbols(
                this: *mut root::octave::symbol_scope_rep,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave16symbol_scope_rep16dump_symbols_mapEv"]
            pub fn symbol_scope_rep_dump_symbols_map(
                this: *const root::octave::symbol_scope_rep,
            ) -> root::octave_value;
        }
        impl symbol_scope_rep {
            #[inline]
            pub unsafe fn install_auto_fcn_vars(&mut self) {
                symbol_scope_rep_install_auto_fcn_vars(self)
            }
            #[inline]
            pub unsafe fn install_auto_fcn_var(&mut self, name: *const root::std::string) {
                symbol_scope_rep_install_auto_fcn_var(self, name)
            }
            #[inline]
            pub unsafe fn find(&mut self, name: *const root::std::string) -> root::octave_value {
                symbol_scope_rep_find(self, name)
            }
            #[inline]
            pub unsafe fn insert(
                &mut self,
                name: *const root::std::string,
                force_add: bool,
            ) -> *mut root::octave::symbol_record {
                symbol_scope_rep_insert(self, name, force_add)
            }
            #[inline]
            pub unsafe fn find_subfunction(
                &self,
                name: *const root::std::string,
            ) -> root::octave_value {
                symbol_scope_rep_find_subfunction(self, name)
            }
            #[inline]
            pub unsafe fn mark_subfunctions_in_scope_as_private(
                &mut self,
                class_name: *const root::std::string,
            ) {
                symbol_scope_rep_mark_subfunctions_in_scope_as_private(self, class_name)
            }
            #[inline]
            pub unsafe fn dump(&self) -> root::octave_value {
                symbol_scope_rep_dump(self)
            }
            #[inline]
            pub unsafe fn set_parent(&mut self, parent: *const [u64; 2usize]) {
                symbol_scope_rep_set_parent(self, parent)
            }
            #[inline]
            pub unsafe fn set_primary_parent(&mut self, parent: *const [u64; 2usize]) {
                symbol_scope_rep_set_primary_parent(self, parent)
            }
            #[inline]
            pub unsafe fn is_relative(&self, scope: *const [u64; 2usize]) -> bool {
                symbol_scope_rep_is_relative(self, scope)
            }
            #[inline]
            pub unsafe fn update_nest(&mut self) {
                symbol_scope_rep_update_nest(self)
            }
            #[inline]
            pub unsafe fn look_nonlocal(
                &mut self,
                name: *const root::std::string,
                result: *mut root::octave::symbol_record,
            ) -> bool {
                symbol_scope_rep_look_nonlocal(self, name, result)
            }
            #[inline]
            pub unsafe fn bind_script_symbols(&mut self, curr_scope: *const [u64; 2usize]) {
                symbol_scope_rep_bind_script_symbols(self, curr_scope)
            }
            #[inline]
            pub unsafe fn unbind_script_symbols(&mut self) {
                symbol_scope_rep_unbind_script_symbols(self)
            }
            #[inline]
            pub unsafe fn dump_symbols_map(&self) -> root::octave_value {
                symbol_scope_rep_dump_symbols_map(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct symbol_scope {
            pub m_rep: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout_symbol_scope() {
            assert_eq!(
                ::core::mem::size_of::<symbol_scope>(),
                16usize,
                concat!("Size of: ", stringify!(symbol_scope))
            );
            assert_eq!(
                ::core::mem::align_of::<symbol_scope>(),
                8usize,
                concat!("Alignment of ", stringify!(symbol_scope))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<symbol_scope>())).m_rep as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(symbol_scope),
                    "::",
                    stringify!(m_rep)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tree_evaluator {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tree_walker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct jit_type {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct dynamic_library {
            pub rep: *mut root::octave::dynamic_library_dynlib_rep,
        }
        pub type dynamic_library_name_mangler = ::core::option::Option<
            unsafe extern "C" fn(arg1: *const root::std::string) -> root::std::string,
        >;
        #[repr(C)]
        pub struct dynamic_library_dynlib_rep__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct dynamic_library_dynlib_rep {
            pub vtable_: *const dynamic_library_dynlib_rep__bindgen_vtable,
            pub count: root::octave::refcount<::std::os::raw::c_int>,
            pub file: root::std::string,
            pub tm_loaded: root::octave::sys::time,
            pub fcn_names: [u64; 6usize],
            pub search_all_loaded: bool,
        }
        pub type dynamic_library_dynlib_rep_fcn_names_iterator = u8;
        pub type dynamic_library_dynlib_rep_fcn_names_const_iterator = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep9instancesB5cxx11E"]
            pub static mut dynamic_library_dynlib_rep_instances: [u64; 6usize];
        }
        #[test]
        fn bindgen_test_layout_dynamic_library_dynlib_rep() {
            assert_eq!(
                ::core::mem::size_of::<dynamic_library_dynlib_rep>(),
                120usize,
                concat!("Size of: ", stringify!(dynamic_library_dynlib_rep))
            );
            assert_eq!(
                ::core::mem::align_of::<dynamic_library_dynlib_rep>(),
                8usize,
                concat!("Alignment of ", stringify!(dynamic_library_dynlib_rep))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<dynamic_library_dynlib_rep>())).count as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library_dynlib_rep),
                    "::",
                    stringify!(count)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<dynamic_library_dynlib_rep>())).file as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library_dynlib_rep),
                    "::",
                    stringify!(file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<dynamic_library_dynlib_rep>())).tm_loaded as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library_dynlib_rep),
                    "::",
                    stringify!(tm_loaded)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<dynamic_library_dynlib_rep>())).fcn_names as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library_dynlib_rep),
                    "::",
                    stringify!(fcn_names)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<dynamic_library_dynlib_rep>())).search_all_loaded
                        as *const _ as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library_dynlib_rep),
                    "::",
                    stringify!(search_all_loaded)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave15dynamic_library10dynlib_rep14is_out_of_dateEv"]
            pub fn dynamic_library_dynlib_rep_is_out_of_date(
                this: *const root::octave::dynamic_library_dynlib_rep,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep12new_instanceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn dynamic_library_dynlib_rep_new_instance(
                f: *const root::std::string,
            ) -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep12get_instanceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
            pub fn dynamic_library_dynlib_rep_get_instance(
                f: *const root::std::string,
                fake: bool,
            ) -> *mut root::octave::dynamic_library_dynlib_rep;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave15dynamic_library10dynlib_rep14function_namesB5cxx11Ev"]
            pub fn dynamic_library_dynlib_rep_function_names(
                this: *const root::octave::dynamic_library_dynlib_rep,
            ) -> [u64; 3usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep12add_fcn_nameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn dynamic_library_dynlib_rep_add_fcn_name(
                this: *mut root::octave::dynamic_library_dynlib_rep,
                arg1: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep15remove_fcn_nameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn dynamic_library_dynlib_rep_remove_fcn_name(
                this: *mut root::octave::dynamic_library_dynlib_rep,
                arg1: *const root::std::string,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_rep11fake_reloadEv"]
            pub fn dynamic_library_dynlib_rep_fake_reload(
                this: *mut root::octave::dynamic_library_dynlib_rep,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library10dynlib_repC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn dynamic_library_dynlib_rep_dynlib_rep(
                this: *mut root::octave::dynamic_library_dynlib_rep,
                f: *const root::std::string,
            );
        }
        impl dynamic_library_dynlib_rep {
            #[inline]
            pub unsafe fn is_out_of_date(&self) -> bool {
                dynamic_library_dynlib_rep_is_out_of_date(self)
            }
            #[inline]
            pub unsafe fn new_instance(
                f: *const root::std::string,
            ) -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_new_instance(f)
            }
            #[inline]
            pub unsafe fn get_instance(
                f: *const root::std::string,
                fake: bool,
            ) -> *mut root::octave::dynamic_library_dynlib_rep {
                dynamic_library_dynlib_rep_get_instance(f, fake)
            }
            #[inline]
            pub unsafe fn function_names(&self) -> [u64; 3usize] {
                dynamic_library_dynlib_rep_function_names(self)
            }
            #[inline]
            pub unsafe fn add_fcn_name(&mut self, arg1: *const root::std::string) {
                dynamic_library_dynlib_rep_add_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn remove_fcn_name(&mut self, arg1: *const root::std::string) -> bool {
                dynamic_library_dynlib_rep_remove_fcn_name(self, arg1)
            }
            #[inline]
            pub unsafe fn fake_reload(&mut self) {
                dynamic_library_dynlib_rep_fake_reload(self)
            }
            #[inline]
            pub unsafe fn new(f: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                dynamic_library_dynlib_rep_dynlib_rep(&mut __bindgen_tmp, f);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15dynamic_library7nil_repE"]
            pub static mut dynamic_library_nil_rep: root::octave::dynamic_library_dynlib_rep;
        }
        #[test]
        fn bindgen_test_layout_dynamic_library() {
            assert_eq!(
                ::core::mem::size_of::<dynamic_library>(),
                8usize,
                concat!("Size of: ", stringify!(dynamic_library))
            );
            assert_eq!(
                ::core::mem::align_of::<dynamic_library>(),
                8usize,
                concat!("Alignment of ", stringify!(dynamic_library))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<dynamic_library>())).rep as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(dynamic_library),
                    "::",
                    stringify!(rep)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct auto_shlib {
            pub _base: root::octave::dynamic_library,
        }
        #[test]
        fn bindgen_test_layout_auto_shlib() {
            assert_eq!(
                ::core::mem::size_of::<auto_shlib>(),
                8usize,
                concat!("Size of: ", stringify!(auto_shlib))
            );
            assert_eq!(
                ::core::mem::align_of::<auto_shlib>(),
                8usize,
                concat!("Alignment of ", stringify!(auto_shlib))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct help_system {
            pub m_interpreter: *mut root::octave::interpreter,
            pub m_built_in_docstrings_file: root::std::string,
            pub m_doc_cache_file: root::std::string,
            pub m_info_file: root::std::string,
            pub m_info_program: root::std::string,
            pub m_makeinfo_program: root::std::string,
            pub m_suppress_verbose_help_message: bool,
            pub m_texi_macros_file: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_help_system() {
            assert_eq!(
                ::core::mem::size_of::<help_system>(),
                208usize,
                concat!("Size of: ", stringify!(help_system))
            );
            assert_eq!(
                ::core::mem::align_of::<help_system>(),
                8usize,
                concat!("Alignment of ", stringify!(help_system))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_interpreter as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_interpreter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_built_in_docstrings_file as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_built_in_docstrings_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_doc_cache_file as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_doc_cache_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_info_file as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_info_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_info_program as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_info_program)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_makeinfo_program as *const _ as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_makeinfo_program)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_suppress_verbose_help_message
                        as *const _ as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_suppress_verbose_help_message)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<help_system>())).m_texi_macros_file as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(help_system),
                    "::",
                    stringify!(m_texi_macros_file)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system24built_in_docstrings_fileERK17octave_value_listi"]
            pub fn help_system_built_in_docstrings_file(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system14doc_cache_fileERK17octave_value_listi"]
            pub fn help_system_doc_cache_file(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system9info_fileERK17octave_value_listi"]
            pub fn help_system_info_file(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system12info_programERK17octave_value_listi"]
            pub fn help_system_info_program(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system16makeinfo_programERK17octave_value_listi"]
            pub fn help_system_makeinfo_program(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system29suppress_verbose_help_messageERK17octave_value_listi"]
            pub fn help_system_suppress_verbose_help_message(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave11help_system16texi_macros_fileERK17octave_value_listi"]
            pub fn help_system_texi_macros_file(
                this: *mut root::octave::help_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system8raw_helpERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERb"]
            pub fn help_system_raw_help(
                this: *const root::octave::help_system,
                arg1: *const root::std::string,
                arg2: *mut bool,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system5whichERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn help_system_which(
                this: *const root::octave::help_system,
                name: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system5whichERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS6_"]
            pub fn help_system_which1(
                this: *const root::octave::help_system,
                name: *const root::std::string,
                type_: *mut root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system14make_name_listEv"]
            pub fn help_system_make_name_list(
                this: *const root::octave::help_system,
            ) -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system13get_help_textERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS6_S9_"]
            pub fn help_system_get_help_text(
                this: *const root::octave::help_system,
                name: *const root::std::string,
                text: *mut root::std::string,
                format: *mut root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave11help_system23get_help_text_from_fileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS6_S9_"]
            pub fn help_system_get_help_text_from_file(
                this: *const root::octave::help_system,
                fname: *const root::std::string,
                text: *mut root::std::string,
                format: *mut root::std::string,
            );
        }
        impl help_system {
            #[inline]
            pub unsafe fn built_in_docstrings_file(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_built_in_docstrings_file(self, args, nargout)
            }
            #[inline]
            pub unsafe fn doc_cache_file(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_doc_cache_file(self, args, nargout)
            }
            #[inline]
            pub unsafe fn info_file(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_info_file(self, args, nargout)
            }
            #[inline]
            pub unsafe fn info_program(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_info_program(self, args, nargout)
            }
            #[inline]
            pub unsafe fn makeinfo_program(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_makeinfo_program(self, args, nargout)
            }
            #[inline]
            pub unsafe fn suppress_verbose_help_message(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_suppress_verbose_help_message(self, args, nargout)
            }
            #[inline]
            pub unsafe fn texi_macros_file(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                help_system_texi_macros_file(self, args, nargout)
            }
            #[inline]
            pub unsafe fn raw_help(
                &self,
                arg1: *const root::std::string,
                arg2: *mut bool,
            ) -> root::std::string {
                help_system_raw_help(self, arg1, arg2)
            }
            #[inline]
            pub unsafe fn which(&self, name: *const root::std::string) -> root::std::string {
                help_system_which(self, name)
            }
            #[inline]
            pub unsafe fn which1(
                &self,
                name: *const root::std::string,
                type_: *mut root::std::string,
            ) -> root::std::string {
                help_system_which1(self, name, type_)
            }
            #[inline]
            pub unsafe fn make_name_list(&self) -> root::string_vector {
                help_system_make_name_list(self)
            }
            #[inline]
            pub unsafe fn get_help_text(
                &self,
                name: *const root::std::string,
                text: *mut root::std::string,
                format: *mut root::std::string,
            ) {
                help_system_get_help_text(self, name, text, format)
            }
            #[inline]
            pub unsafe fn get_help_text_from_file(
                &self,
                fname: *const root::std::string,
                text: *mut root::std::string,
                format: *mut root::std::string,
            ) {
                help_system_get_help_text_from_file(self, fname, text, format)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave14make_name_listEv"]
            pub fn make_name_list() -> root::string_vector;
        }
        #[repr(C)]
        pub struct pager_buf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pager_buf {
            pub vtable_: *const pager_buf__bindgen_vtable,
            pub _base: root::std::stringbuf,
            pub diary_skip: usize,
        }
        #[test]
        fn bindgen_test_layout_pager_buf() {
            assert_eq!(
                ::core::mem::size_of::<pager_buf>(),
                112usize,
                concat!("Size of: ", stringify!(pager_buf))
            );
            assert_eq!(
                ::core::mem::align_of::<pager_buf>(),
                8usize,
                concat!("Alignment of ", stringify!(pager_buf))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<pager_buf>())).diary_skip as *const _ as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(pager_buf),
                    "::",
                    stringify!(diary_skip)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9pager_buf31flush_current_contents_to_diaryEv"]
            pub fn pager_buf_flush_current_contents_to_diary(this: *mut root::octave::pager_buf);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9pager_buf14set_diary_skipEv"]
            pub fn pager_buf_set_diary_skip(this: *mut root::octave::pager_buf);
        }
        impl pager_buf {
            #[inline]
            pub unsafe fn flush_current_contents_to_diary(&mut self) {
                pager_buf_flush_current_contents_to_diary(self)
            }
            #[inline]
            pub unsafe fn set_diary_skip(&mut self) {
                pager_buf_set_diary_skip(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9pager_buf4syncEv"]
            pub fn pager_buf_sync(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        pub struct pager_stream__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct pager_stream {
            pub vtable_: *const pager_stream__bindgen_vtable,
            pub _base: root::std::ostream,
            pub pb: *mut root::octave::pager_buf,
        }
        #[test]
        fn bindgen_test_layout_pager_stream() {
            assert_eq!(
                ::core::mem::size_of::<pager_stream>(),
                280usize,
                concat!("Size of: ", stringify!(pager_stream))
            );
            assert_eq!(
                ::core::mem::align_of::<pager_stream>(),
                8usize,
                concat!("Alignment of ", stringify!(pager_stream))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<pager_stream>())).pb as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(pager_stream),
                    "::",
                    stringify!(pb)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_stream31flush_current_contents_to_diaryEv"]
            pub fn pager_stream_flush_current_contents_to_diary(
                this: *mut root::octave::pager_stream,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_stream14set_diary_skipEv"]
            pub fn pager_stream_set_diary_skip(this: *mut root::octave::pager_stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_stream6streamEv"]
            pub fn pager_stream_stream(
                this: *mut root::octave::pager_stream,
            ) -> *mut root::std::ostream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_stream5resetEv"]
            pub fn pager_stream_reset(this: *mut root::octave::pager_stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_streamC1Ev"]
            pub fn pager_stream_pager_stream(this: *mut root::octave::pager_stream);
        }
        impl pager_stream {
            #[inline]
            pub unsafe fn flush_current_contents_to_diary(&mut self) {
                pager_stream_flush_current_contents_to_diary(self)
            }
            #[inline]
            pub unsafe fn set_diary_skip(&mut self) {
                pager_stream_set_diary_skip(self)
            }
            #[inline]
            pub unsafe fn stream(&mut self) -> *mut root::std::ostream {
                pager_stream_stream(self)
            }
            #[inline]
            pub unsafe fn reset(&mut self) {
                pager_stream_reset(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                pager_stream_pager_stream(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12pager_streamD1Ev"]
            pub fn pager_stream_pager_stream_destructor(this: *mut root::octave::pager_stream);
        }
        #[repr(C)]
        pub struct diary_buf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct diary_buf {
            pub vtable_: *const diary_buf__bindgen_vtable,
            pub _base: root::std::stringbuf,
        }
        #[test]
        fn bindgen_test_layout_diary_buf() {
            assert_eq!(
                ::core::mem::size_of::<diary_buf>(),
                104usize,
                concat!("Size of: ", stringify!(diary_buf))
            );
            assert_eq!(
                ::core::mem::align_of::<diary_buf>(),
                8usize,
                concat!("Alignment of ", stringify!(diary_buf))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9diary_buf4syncEv"]
            pub fn diary_buf_sync(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        pub struct diary_stream__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct diary_stream {
            pub vtable_: *const diary_stream__bindgen_vtable,
            pub _base: root::std::ostream,
            pub db: *mut root::octave::diary_buf,
        }
        #[test]
        fn bindgen_test_layout_diary_stream() {
            assert_eq!(
                ::core::mem::size_of::<diary_stream>(),
                280usize,
                concat!("Size of: ", stringify!(diary_stream))
            );
            assert_eq!(
                ::core::mem::align_of::<diary_stream>(),
                8usize,
                concat!("Alignment of ", stringify!(diary_stream))
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<diary_stream>())).db as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(diary_stream),
                    "::",
                    stringify!(db)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12diary_stream6streamEv"]
            pub fn diary_stream_stream(
                this: *mut root::octave::diary_stream,
            ) -> *mut root::std::ostream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12diary_stream5resetEv"]
            pub fn diary_stream_reset(this: *mut root::octave::diary_stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12diary_streamC1Ev"]
            pub fn diary_stream_diary_stream(this: *mut root::octave::diary_stream);
        }
        impl diary_stream {
            #[inline]
            pub unsafe fn stream(&mut self) -> *mut root::std::ostream {
                diary_stream_stream(self)
            }
            #[inline]
            pub unsafe fn reset(&mut self) {
                diary_stream_reset(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                diary_stream_diary_stream(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12diary_streamD1Ev"]
            pub fn diary_stream_diary_stream_destructor(this: *mut root::octave::diary_stream);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12flush_stdoutEv"]
            pub fn flush_stdout();
        }
        #[repr(C)]
        pub struct output_system {
            pub m_interpreter: *mut root::octave::interpreter,
            pub m_pager_stream: root::octave::pager_stream,
            pub m_diary_stream: root::octave::diary_stream,
            pub m_external_pager: *mut root::oprocstream,
            pub m_external_diary_file: root::std::ofstream,
            pub m_diary_file_name: root::std::string,
            pub m_PAGER: root::std::string,
            pub m_PAGER_FLAGS: root::std::string,
            pub m_page_output_immediately: bool,
            pub m_page_screen_output: bool,
            pub m_write_to_diary_file: bool,
            pub m_really_flush_to_pager: bool,
            pub m_flushing_output_to_pager: bool,
        }
        #[test]
        fn bindgen_test_layout_output_system() {
            assert_eq!(
                ::core::mem::size_of::<output_system>(),
                1192usize,
                concat!("Size of: ", stringify!(output_system))
            );
            assert_eq!(
                ::core::mem::align_of::<output_system>(),
                8usize,
                concat!("Alignment of ", stringify!(output_system))
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_interpreter as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_interpreter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_pager_stream as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_pager_stream)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_diary_stream as *const _ as usize
                },
                288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_diary_stream)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_external_pager as *const _ as usize
                },
                568usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_external_pager)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_external_diary_file as *const _
                        as usize
                },
                576usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_external_diary_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_diary_file_name as *const _
                        as usize
                },
                1088usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_diary_file_name)
                )
            );
            assert_eq!(
                unsafe { &(*(::core::ptr::null::<output_system>())).m_PAGER as *const _ as usize },
                1120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_PAGER)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_PAGER_FLAGS as *const _ as usize
                },
                1152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_PAGER_FLAGS)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_page_output_immediately as *const _
                        as usize
                },
                1184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_page_output_immediately)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_page_screen_output as *const _
                        as usize
                },
                1185usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_page_screen_output)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_write_to_diary_file as *const _
                        as usize
                },
                1186usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_write_to_diary_file)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_really_flush_to_pager as *const _
                        as usize
                },
                1187usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_really_flush_to_pager)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::core::ptr::null::<output_system>())).m_flushing_output_to_pager
                        as *const _ as usize
                },
                1188usize,
                concat!(
                    "Offset of field: ",
                    stringify!(output_system),
                    "::",
                    stringify!(m_flushing_output_to_pager)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system5PAGERERK17octave_value_listi"]
            pub fn output_system_PAGER(
                this: *mut root::octave::output_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system11PAGER_FLAGSERK17octave_value_listi"]
            pub fn output_system_PAGER_FLAGS(
                this: *mut root::octave::output_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system23page_output_immediatelyERK17octave_value_listi"]
            pub fn output_system_page_output_immediately(
                this: *mut root::octave::output_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system18page_screen_outputERK17octave_value_listi"]
            pub fn output_system_page_screen_output(
                this: *mut root::octave::output_system,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK6octave13output_system13pager_commandB5cxx11Ev"]
            pub fn output_system_pager_command(
                this: *const root::octave::output_system,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system5resetEv"]
            pub fn output_system_reset(this: *mut root::octave::output_system);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system12flush_stdoutEv"]
            pub fn output_system_flush_stdout(this: *mut root::octave::output_system);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system4syncEPKci"]
            pub fn output_system_sync(
                this: *mut root::octave::output_system,
                msg: *const ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system20clear_external_pagerEv"]
            pub fn output_system_clear_external_pager(this: *mut root::octave::output_system);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system10open_diaryEv"]
            pub fn output_system_open_diary(this: *mut root::octave::output_system);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_system11close_diaryEv"]
            pub fn output_system_close_diary(this: *mut root::octave::output_system);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13output_systemC1ERNS_11interpreterE"]
            pub fn output_system_output_system(
                this: *mut root::octave::output_system,
                interp: *mut root::octave::interpreter,
            );
        }
        impl output_system {
            #[inline]
            pub unsafe fn PAGER(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                output_system_PAGER(self, args, nargout)
            }
            #[inline]
            pub unsafe fn PAGER_FLAGS(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                output_system_PAGER_FLAGS(self, args, nargout)
            }
            #[inline]
            pub unsafe fn page_output_immediately(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                output_system_page_output_immediately(self, args, nargout)
            }
            #[inline]
            pub unsafe fn page_screen_output(
                &mut self,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value {
                output_system_page_screen_output(self, args, nargout)
            }
            #[inline]
            pub unsafe fn pager_command(&self) -> root::std::string {
                output_system_pager_command(self)
            }
            #[inline]
            pub unsafe fn reset(&mut self) {
                output_system_reset(self)
            }
            #[inline]
            pub unsafe fn flush_stdout(&mut self) {
                output_system_flush_stdout(self)
            }
            #[inline]
            pub unsafe fn sync(
                &mut self,
                msg: *const ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
            ) -> bool {
                output_system_sync(self, msg, len)
            }
            #[inline]
            pub unsafe fn clear_external_pager(&mut self) {
                output_system_clear_external_pager(self)
            }
            #[inline]
            pub unsafe fn open_diary(&mut self) {
                output_system_open_diary(self)
            }
            #[inline]
            pub unsafe fn close_diary(&mut self) {
                output_system_close_diary(self)
            }
            #[inline]
            pub unsafe fn new(interp: *mut root::octave::interpreter) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                output_system_output_system(&mut __bindgen_tmp, interp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave10__stdout__Ev"]
            pub fn __stdout__() -> *mut root::std::ostream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9__diary__Ev"]
            pub fn __diary__() -> *mut root::std::ostream;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16valid_identifierEPKc"]
            pub fn valid_identifier(s: *const ::std::os::raw::c_char) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16valid_identifierERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn valid_identifier1(s: *const root::std::string) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9same_fileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_"]
            pub fn same_file(f: *const root::std::string, g: *const root::std::string) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12almost_matchERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ii"]
            pub fn almost_match(
                std: *const root::std::string,
                s: *const root::std::string,
                min_match_len: ::std::os::raw::c_int,
                case_sens: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave20keyword_almost_matchEPKPKcPiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEii"]
            pub fn keyword_almost_match(
                std: *const *const ::std::os::raw::c_char,
                min_len: *mut ::std::os::raw::c_int,
                s: *const root::std::string,
                min_toks_to_match: ::std::os::raw::c_int,
                max_toks: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave20search_path_for_fileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK13string_vector"]
            pub fn search_path_for_file(
                arg1: *const root::std::string,
                arg2: *const root::string_vector,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave25search_path_for_all_filesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK13string_vector"]
            pub fn search_path_for_all_files(
                arg1: *const root::std::string,
                arg2: *const root::string_vector,
            ) -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave12file_in_pathERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_"]
            pub fn file_in_path(
                arg1: *const root::std::string,
                arg2: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave27find_data_file_in_load_pathERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_b"]
            pub fn find_data_file_in_load_path(
                fcn: *const root::std::string,
                file: *const root::std::string,
                require_regular_file: bool,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave21contents_file_in_pathERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn contents_file_in_path(arg1: *const root::std::string) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16fcn_file_in_pathERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn fcn_file_in_path(arg1: *const root::std::string) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17do_string_escapesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn do_string_escapes(s: *const root::std::string) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave18undo_string_escapeEc"]
            pub fn undo_string_escape(c: ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave19undo_string_escapesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn undo_string_escapes(s: *const root::std::string) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave16check_dimensionsER10dim_vectorPKc"]
            pub fn check_dimensions(
                dim: *mut root::dim_vector,
                warnfor: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave14get_dimensionsERK12octave_valuePKcR10dim_vector"]
            pub fn get_dimensions(
                a: *const root::octave_value,
                warn_for: *const ::std::os::raw::c_char,
                dim: *mut root::dim_vector,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave14get_dimensionsERK12octave_valueS2_PKcRlS5_"]
            pub fn get_dimensions1(
                a: *const root::octave_value,
                b: *const root::octave_value,
                warn_for: *const ::std::os::raw::c_char,
                nr: *mut root::octave_idx_type,
                nc: *mut root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave14get_dimensionsERK12octave_valuePKcRlS5_"]
            pub fn get_dimensions2(
                a: *const root::octave_value,
                warn_for: *const ::std::os::raw::c_char,
                nr: *mut root::octave_idx_type,
                nc: *mut root::octave_idx_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave13dims_to_numelERK10dim_vectorRK17octave_value_list"]
            pub fn dims_to_numel(
                dims: *const root::dim_vector,
                idx: *const root::octave_value_list,
            ) -> root::octave_idx_type;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave15identity_matrixEll"]
            pub fn identity_matrix(
                nr: root::octave_idx_type,
                nc: root::octave_idx_type,
            ) -> root::Matrix;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave21float_identity_matrixEll"]
            pub fn float_identity_matrix(
                nr: root::octave_idx_type,
                nc: root::octave_idx_type,
            ) -> root::FloatMatrix;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave6formatERSoPKcz"]
            pub fn format(
                os: *mut root::std::ostream,
                fmt: *const ::std::os::raw::c_char,
                ...
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave7vformatERSoPKcP13__va_list_tag"]
            pub fn vformat(
                os: *mut root::std::ostream,
                fmt: *const ::std::os::raw::c_char,
                args: *mut root::__va_list_tag,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave9vasprintfB5cxx11EPKcP13__va_list_tag"]
            pub fn vasprintf(
                fmt: *const ::std::os::raw::c_char,
                args: *mut root::__va_list_tag,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave8asprintfB5cxx11EPKcz"]
            pub fn asprintf(fmt: *const ::std::os::raw::c_char, ...) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave5sleepEdb"]
            pub fn sleep(seconds: f64, do_graphics_events: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17do_simple_cellfunEPF17octave_value_listRKS0_iEPKcS2_i"]
            pub fn do_simple_cellfun(
                fun: ::core::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const root::octave_value_list,
                        arg2: ::std::os::raw::c_int,
                    ) -> root::octave_value_list,
                >,
                fun_name: *const ::std::os::raw::c_char,
                args: *const root::octave_value_list,
                nargout: ::std::os::raw::c_int,
            ) -> root::octave_value_list;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6octave17do_simple_cellfunEPF17octave_value_listRKS0_iEPKcS2_"]
            pub fn do_simple_cellfun1(
                fun: ::core::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const root::octave_value_list,
                        arg2: ::std::os::raw::c_int,
                    ) -> root::octave_value_list,
                >,
                fun_name: *const ::std::os::raw::c_char,
                args: *const root::octave_value_list,
            ) -> root::octave_value;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tree_identifier {
            _unused: [u8; 0],
        }
    }
    pub type octave_refcount = u8;
    #[doc = "! Vector representing the dimensions (size) of an Array."]
    #[doc = "!"]
    #[doc = "! A dim_vector is used to represent dimensions of an Array.  It is used"]
    #[doc = "! on its constructor to specify its size, or when reshaping it."]
    #[doc = "!"]
    #[doc = "! @code{.cc}"]
    #[doc = "! // Matrix with 10 rows and 20 columns."]
    #[doc = "! Matrix m Matrix (dim_vector (10, 20));"]
    #[doc = "!"]
    #[doc = "! // Change its size to 5 rows and 40 columns."]
    #[doc = "! Matrix m2 = m.reshape (dim_vector (5, 40));"]
    #[doc = "!"]
    #[doc = "! // Five dimensional Array of length 10, 20, 3, 8, 7 on each dimension."]
    #[doc = "! NDArray a (dim_vector (10, 20, 3, 8, 7));"]
    #[doc = "!"]
    #[doc = "! // Uninitialized array of same size as other."]
    #[doc = "! NDArray b (a.dims ());"]
    #[doc = "! @endcode"]
    #[doc = "!"]
    #[doc = "! The main thing to understand about this class, is that methods such as"]
    #[doc = "! ndims() and numel(), return the value for an Array of these dimensions,"]
    #[doc = "! not the actual number of elements in the dim_vector."]
    #[doc = "!"]
    #[doc = "! @code{.cc}"]
    #[doc = "! dim_vector d (10, 5, 3);"]
    #[doc = "! octave_idx_type n = d.numel (); // returns 150"]
    #[doc = "! octave_idx_type nd = d.ndims (); // returns 3"]
    #[doc = "! @endcode"]
    #[doc = "!"]
    #[doc = "! ## Implementation details ##"]
    #[doc = "!"]
    #[doc = "! This implementation is more tricky than Array, but the big plus is that"]
    #[doc = "! dim_vector requires only one allocation instead of two.  It is (slightly)"]
    #[doc = "! patterned after GCC's basic_string implementation.  rep is a pointer to an"]
    #[doc = "! array of memory, comprising count, length, and the data:"]
    #[doc = "!"]
    #[doc = "! @verbatim"]
    #[doc = "!        <count>"]
    #[doc = "!        <ndims>"]
    #[doc = "! rep --> <dims[0]>"]
    #[doc = "!        <dims[1]>"]
    #[doc = "!        ..."]
    #[doc = "! @endverbatim"]
    #[doc = "!"]
    #[doc = "! The inlines count(), ndims() recover this data from the rep.  Note"]
    #[doc = "! that rep points to the beginning of dims to grant faster access"]
    #[doc = "! (reinterpret_cast is assumed to be an inexpensive operation)."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dim_vector {
        pub rep: *mut root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_dim_vector() {
        assert_eq!(
            ::core::mem::size_of::<dim_vector>(),
            8usize,
            concat!("Size of: ", stringify!(dim_vector))
        );
        assert_eq!(
            ::core::mem::align_of::<dim_vector>(),
            8usize,
            concat!("Alignment of ", stringify!(dim_vector))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dim_vector>())).rep as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dim_vector),
                "::",
                stringify!(rep)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10dim_vector19chop_all_singletonsEv"]
        pub fn dim_vector_chop_all_singletons(this: *mut root::dim_vector);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10dim_vector7dim_maxEv"]
        pub fn dim_vector_dim_max() -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10dim_vector3strB5cxx11Ec"]
        pub fn dim_vector_str(
            this: *const root::dim_vector,
            sep: ::std::os::raw::c_char,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10dim_vector8num_onesEv"]
        pub fn dim_vector_num_ones(this: *const root::dim_vector) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = "! The following function will throw a std::bad_alloc ()"]
        #[doc = "! exception if the requested size is larger than can be indexed by"]
        #[doc = "! octave_idx_type.  This may be smaller than the actual amount of"]
        #[doc = "! memory that can be safely allocated on a system.  However, if we"]
        #[doc = "! don't fail here, we can end up with a mysterious crash inside a"]
        #[doc = "! function that is iterating over an array using octave_idx_type"]
        #[doc = "! indices."]
        #[link_name = "\u{1}_ZNK10dim_vector10safe_numelEv"]
        pub fn dim_vector_safe_numel(this: *const root::dim_vector) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10dim_vector7squeezeEv"]
        pub fn dim_vector_squeeze(this: *const root::dim_vector) -> root::dim_vector;
    }
    extern "C" {
        #[doc = "! This corresponds to cat()."]
        #[link_name = "\u{1}_ZN10dim_vector6concatERKS_i"]
        pub fn dim_vector_concat(
            this: *mut root::dim_vector,
            dvb: *const root::dim_vector,
            dim: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[doc = "! This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1)."]
        #[link_name = "\u{1}_ZN10dim_vector5hvcatERKS_i"]
        pub fn dim_vector_hvcat(
            this: *mut root::dim_vector,
            dvb: *const root::dim_vector,
            dim: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[doc = "! Force certain dimensionality, preserving numel ().  Missing"]
        #[doc = "! dimensions are set to 1, redundant are folded into the trailing"]
        #[doc = "! one.  If n = 1, the result is 2d and the second dim is 1"]
        #[doc = "! (dim_vectors are always at least 2D)."]
        #[link_name = "\u{1}_ZNK10dim_vector5redimEi"]
        pub fn dim_vector_redim(
            this: *const root::dim_vector,
            n: ::std::os::raw::c_int,
        ) -> root::dim_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10dim_vector8as_arrayEv"]
        pub fn dim_vector_as_array(
            this: *const root::dim_vector,
        ) -> root::Array<root::octave_idx_type>;
    }
    impl dim_vector {
        #[inline]
        pub unsafe fn chop_all_singletons(&mut self) {
            dim_vector_chop_all_singletons(self)
        }
        #[inline]
        pub unsafe fn dim_max() -> root::octave_idx_type {
            dim_vector_dim_max()
        }
        #[inline]
        pub unsafe fn str(&self, sep: ::std::os::raw::c_char) -> root::std::string {
            dim_vector_str(self, sep)
        }
        #[inline]
        pub unsafe fn num_ones(&self) -> ::std::os::raw::c_int {
            dim_vector_num_ones(self)
        }
        #[inline]
        pub unsafe fn safe_numel(&self) -> root::octave_idx_type {
            dim_vector_safe_numel(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::dim_vector {
            dim_vector_squeeze(self)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            dvb: *const root::dim_vector,
            dim: ::std::os::raw::c_int,
        ) -> bool {
            dim_vector_concat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn hvcat(
            &mut self,
            dvb: *const root::dim_vector,
            dim: ::std::os::raw::c_int,
        ) -> bool {
            dim_vector_hvcat(self, dvb, dim)
        }
        #[inline]
        pub unsafe fn redim(&self, n: ::std::os::raw::c_int) -> root::dim_vector {
            dim_vector_redim(self, n)
        }
        #[inline]
        pub unsafe fn as_array(&self) -> root::Array<root::octave_idx_type> {
            dim_vector_as_array(self)
        }
    }
    pub type octave_int8 = root::octave_int<i8>;
    pub type octave_int16 = root::octave_int<i16>;
    pub type octave_int32 = root::octave_int<i32>;
    pub type octave_int64 = root::octave_int<i64>;
    pub type octave_uint8 = root::octave_int<u8>;
    pub type octave_uint16 = root::octave_int<u16>;
    pub type octave_uint32 = root::octave_int<u32>;
    pub type octave_uint64 = root::octave_int<u64>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector {
        pub rep: *mut root::idx_vector_idx_base_rep,
    }
    pub const idx_vector_idx_class_type_class_invalid: root::idx_vector_idx_class_type = -1;
    pub const idx_vector_idx_class_type_class_colon: root::idx_vector_idx_class_type = 0;
    pub const idx_vector_idx_class_type_class_range: root::idx_vector_idx_class_type = 1;
    pub const idx_vector_idx_class_type_class_scalar: root::idx_vector_idx_class_type = 2;
    pub const idx_vector_idx_class_type_class_vector: root::idx_vector_idx_class_type = 3;
    pub const idx_vector_idx_class_type_class_mask: root::idx_vector_idx_class_type = 4;
    pub type idx_vector_idx_class_type = i32;
    #[repr(C)]
    pub struct idx_vector_idx_base_rep__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_base_rep {
        pub vtable_: *const idx_vector_idx_base_rep__bindgen_vtable,
        pub count: root::octave::refcount<::std::os::raw::c_int>,
        pub err: bool,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_base_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_base_rep>(),
            16usize,
            concat!("Size of: ", stringify!(idx_vector_idx_base_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_base_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_base_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_base_rep>())).count as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_base_rep),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_base_rep>())).err as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_base_rep),
                "::",
                stringify!(err)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_colon_rep {
        pub _base: root::idx_vector_idx_base_rep,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_colon_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_colon_rep>(),
            16usize,
            concat!("Size of: ", stringify!(idx_vector_idx_colon_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_colon_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_colon_rep))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_colon_repC1Ec"]
        pub fn idx_vector_idx_colon_rep_idx_colon_rep(
            this: *mut root::idx_vector_idx_colon_rep,
            c: ::std::os::raw::c_char,
        );
    }
    impl idx_vector_idx_colon_rep {
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_colon_rep_idx_colon_rep(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
    }
    pub const idx_vector_direct_DIRECT: root::idx_vector_direct = 0;
    pub type idx_vector_direct = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_range_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub start: root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub step: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_range_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_range_rep>(),
            40usize,
            concat!("Size of: ", stringify!(idx_vector_idx_range_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_range_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_range_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_range_rep>())).start as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_range_rep),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_range_rep>())).len as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_range_rep),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_range_rep>())).step as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_range_rep),
                "::",
                stringify!(step)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13idx_range_rep9unconvertEv"]
        pub fn idx_vector_idx_range_rep_unconvert(
            this: *const root::idx_vector_idx_range_rep,
        ) -> root::Range;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_range_repC1Elll"]
        pub fn idx_vector_idx_range_rep_idx_range_rep(
            this: *mut root::idx_vector_idx_range_rep,
            _start: root::octave_idx_type,
            _limit: root::octave_idx_type,
            _step: root::octave_idx_type,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_range_repC1ERK5Range"]
        pub fn idx_vector_idx_range_rep_idx_range_rep1(
            this: *mut root::idx_vector_idx_range_rep,
            arg1: *const root::Range,
        );
    }
    impl idx_vector_idx_range_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Range {
            idx_vector_idx_range_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(
            _start: root::octave_idx_type,
            _limit: root::octave_idx_type,
            _step: root::octave_idx_type,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep(&mut __bindgen_tmp, _start, _limit, _step);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Range) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_range_rep_idx_range_rep1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_scalar_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: root::octave_idx_type,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_scalar_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_scalar_rep>(),
            24usize,
            concat!("Size of: ", stringify!(idx_vector_idx_scalar_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_scalar_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_scalar_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_scalar_rep>())).data as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_scalar_rep),
                "::",
                stringify!(data)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_scalar_rep9unconvertEv"]
        pub fn idx_vector_idx_scalar_rep_unconvert(
            this: *const root::idx_vector_idx_scalar_rep,
        ) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_scalar_repC1El"]
        pub fn idx_vector_idx_scalar_rep_idx_scalar_rep(
            this: *mut root::idx_vector_idx_scalar_rep,
            i: root::octave_idx_type,
        );
    }
    impl idx_vector_idx_scalar_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> f64 {
            idx_vector_idx_scalar_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(i: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_scalar_rep_idx_scalar_rep(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_vector_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const root::octave_idx_type,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub aowner: *mut root::Array<root::octave_idx_type>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_vector_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_vector_rep>(),
            56usize,
            concat!("Size of: ", stringify!(idx_vector_idx_vector_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_vector_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_vector_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_vector_rep>())).data as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_vector_rep),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_vector_rep>())).len as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_vector_rep),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_vector_rep>())).ext as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_vector_rep),
                "::",
                stringify!(ext)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_vector_rep>())).aowner as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_vector_rep),
                "::",
                stringify!(aowner)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_vector_rep>())).orig_dims as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_vector_rep),
                "::",
                stringify!(orig_dims)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_vector_rep9unconvertEv"]
        pub fn idx_vector_idx_vector_rep_unconvert(
            this: *const root::idx_vector_idx_vector_rep,
        ) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repC1ERK5ArrayIlE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep(
            this: *mut root::idx_vector_idx_vector_rep,
            inda: *const root::Array<root::octave_idx_type>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repC1ERK5ArrayIlElNS_6directE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep1(
            this: *mut root::idx_vector_idx_vector_rep,
            inda: *const root::Array<root::octave_idx_type>,
            _ext: root::octave_idx_type,
            arg1: root::idx_vector_direct,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repC1Eb"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep2(
            this: *mut root::idx_vector_idx_vector_rep,
            arg1: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repC1ERK5ArrayIbEl"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep3(
            this: *mut root::idx_vector_idx_vector_rep,
            arg1: *const root::Array<bool>,
            arg2: root::octave_idx_type,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repC1ERK6SparseIbE"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep4(
            this: *mut root::idx_vector_idx_vector_rep,
            arg1: *const root::Sparse<bool>,
        );
    }
    impl idx_vector_idx_vector_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<f64> {
            idx_vector_idx_vector_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(inda: *const root::Array<root::octave_idx_type>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            inda: *const root::Array<root::octave_idx_type>,
            _ext: root::octave_idx_type,
            arg1: root::idx_vector_direct,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep1(&mut __bindgen_tmp, inda, _ext, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep2(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(arg1: *const root::Array<bool>, arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep3(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(arg1: *const root::Sparse<bool>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector_rep_idx_vector_rep4(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct idx_vector_idx_mask_rep {
        pub _base: root::idx_vector_idx_base_rep,
        pub data: *const bool,
        pub len: root::octave_idx_type,
        pub ext: root::octave_idx_type,
        pub lsti: root::octave_idx_type,
        pub lste: root::octave_idx_type,
        pub aowner: *mut root::Array<bool>,
        pub orig_dims: root::dim_vector,
    }
    #[test]
    fn bindgen_test_layout_idx_vector_idx_mask_rep() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector_idx_mask_rep>(),
            72usize,
            concat!("Size of: ", stringify!(idx_vector_idx_mask_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector_idx_mask_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector_idx_mask_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).data as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).len as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).ext as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(ext)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).lsti as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(lsti)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).lste as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(lste)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).aowner as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(aowner)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<idx_vector_idx_mask_rep>())).orig_dims as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector_idx_mask_rep),
                "::",
                stringify!(orig_dims)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector12idx_mask_rep9unconvertEv"]
        pub fn idx_vector_idx_mask_rep_unconvert(
            this: *const root::idx_vector_idx_mask_rep,
        ) -> root::Array<bool>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_mask_repC1Eb"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep(
            this: *mut root::idx_vector_idx_mask_rep,
            arg1: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_mask_repC1ERK5ArrayIbEl"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep1(
            this: *mut root::idx_vector_idx_mask_rep,
            arg1: *const root::Array<bool>,
            arg2: root::octave_idx_type,
        );
    }
    impl idx_vector_idx_mask_rep {
        #[inline]
        pub unsafe fn unconvert(&self) -> root::Array<bool> {
            idx_vector_idx_mask_rep_unconvert(self)
        }
        #[inline]
        pub unsafe fn new(arg1: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::Array<bool>, arg2: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_mask_rep_idx_mask_rep1(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector5colonE"]
        pub static idx_vector_colon: root::idx_vector;
    }
    #[test]
    fn bindgen_test_layout_idx_vector() {
        assert_eq!(
            ::core::mem::size_of::<idx_vector>(),
            8usize,
            concat!("Size of: ", stringify!(idx_vector))
        );
        assert_eq!(
            ::core::mem::align_of::<idx_vector>(),
            8usize,
            concat!("Alignment of ", stringify!(idx_vector))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<idx_vector>())).rep as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(idx_vector),
                "::",
                stringify!(rep)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12maybe_reduceElRKS_l"]
        pub fn idx_vector_maybe_reduce(
            this: *mut root::idx_vector,
            n: root::octave_idx_type,
            j: *const root::idx_vector,
            nj: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13is_cont_rangeElRlS0_"]
        pub fn idx_vector_is_cont_range(
            this: *const root::idx_vector,
            n: root::octave_idx_type,
            l: *mut root::octave_idx_type,
            u: *mut root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector9incrementEv"]
        pub fn idx_vector_increment(this: *const root::idx_vector) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector10complementEl"]
        pub fn idx_vector_complement(
            this: *const root::idx_vector,
            n: root::octave_idx_type,
        ) -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14is_permutationEl"]
        pub fn idx_vector_is_permutation(
            this: *const root::idx_vector,
            n: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector19inverse_permutationEl"]
        pub fn idx_vector_inverse_permutation(
            this: *const root::idx_vector,
            n: root::octave_idx_type,
        ) -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector9copy_dataEPl"]
        pub fn idx_vector_copy_data(
            this: *const root::idx_vector,
            data: *mut root::octave_idx_type,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector6unmaskEv"]
        pub fn idx_vector_unmask(this: *const root::idx_vector) -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector9unconvertERNS_14idx_class_typeERdR5RangeR5ArrayIdERS5_IbE"]
        pub fn idx_vector_unconvert(
            this: *const root::idx_vector,
            iclass: *mut root::idx_vector_idx_class_type,
            scalar: *mut f64,
            range: *mut root::Range,
            array: *mut root::Array<f64>,
            mask: *mut root::Array<bool>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector8as_arrayEv"]
        pub fn idx_vector_as_array(
            this: *const root::idx_vector,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector3rawEv"]
        pub fn idx_vector_raw(this: *mut root::idx_vector) -> *const root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector8isvectorEv"]
        pub fn idx_vector_isvector(this: *const root::idx_vector) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector6freezeElPKcb"]
        pub fn idx_vector_freeze(
            this: *mut root::idx_vector,
            z_len: root::octave_idx_type,
            tag: *const ::std::os::raw::c_char,
            resize_ok: bool,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector10ones_countEv"]
        pub fn idx_vector_ones_count(this: *const root::idx_vector) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vectorC1ERK5ArrayIbE"]
        pub fn idx_vector_idx_vector(this: *mut root::idx_vector, nda: *const root::Array<bool>);
    }
    impl idx_vector {
        #[inline]
        pub unsafe fn maybe_reduce(
            &mut self,
            n: root::octave_idx_type,
            j: *const root::idx_vector,
            nj: root::octave_idx_type,
        ) -> bool {
            idx_vector_maybe_reduce(self, n, j, nj)
        }
        #[inline]
        pub unsafe fn is_cont_range(
            &self,
            n: root::octave_idx_type,
            l: *mut root::octave_idx_type,
            u: *mut root::octave_idx_type,
        ) -> bool {
            idx_vector_is_cont_range(self, n, l, u)
        }
        #[inline]
        pub unsafe fn increment(&self) -> root::octave_idx_type {
            idx_vector_increment(self)
        }
        #[inline]
        pub unsafe fn complement(&self, n: root::octave_idx_type) -> root::idx_vector {
            idx_vector_complement(self, n)
        }
        #[inline]
        pub unsafe fn is_permutation(&self, n: root::octave_idx_type) -> bool {
            idx_vector_is_permutation(self, n)
        }
        #[inline]
        pub unsafe fn inverse_permutation(&self, n: root::octave_idx_type) -> root::idx_vector {
            idx_vector_inverse_permutation(self, n)
        }
        #[inline]
        pub unsafe fn copy_data(&self, data: *mut root::octave_idx_type) {
            idx_vector_copy_data(self, data)
        }
        #[inline]
        pub unsafe fn unmask(&self) -> root::idx_vector {
            idx_vector_unmask(self)
        }
        #[inline]
        pub unsafe fn unconvert(
            &self,
            iclass: *mut root::idx_vector_idx_class_type,
            scalar: *mut f64,
            range: *mut root::Range,
            array: *mut root::Array<f64>,
            mask: *mut root::Array<bool>,
        ) {
            idx_vector_unconvert(self, iclass, scalar, range, array, mask)
        }
        #[inline]
        pub unsafe fn as_array(&self) -> root::Array<root::octave_idx_type> {
            idx_vector_as_array(self)
        }
        #[inline]
        pub unsafe fn raw(&mut self) -> *const root::octave_idx_type {
            idx_vector_raw(self)
        }
        #[inline]
        pub unsafe fn isvector(&self) -> bool {
            idx_vector_isvector(self)
        }
        #[inline]
        pub unsafe fn freeze(
            &mut self,
            z_len: root::octave_idx_type,
            tag: *const ::std::os::raw::c_char,
            resize_ok: bool,
        ) -> root::octave_idx_type {
            idx_vector_freeze(self, z_len, tag, resize_ok)
        }
        #[inline]
        pub unsafe fn ones_count(&self) -> root::octave_idx_type {
            idx_vector_ones_count(self)
        }
        #[inline]
        pub unsafe fn new(nda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            idx_vector_idx_vector(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_base_rep8as_arrayEv"]
        pub fn idx_vector_idx_base_rep_as_array(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13idx_colon_rep9checkelemEl"]
        pub fn idx_vector_idx_colon_rep_checkelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_colon_rep8sort_idxER5ArrayIlE"]
        pub fn idx_vector_idx_colon_rep_sort_idx(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::Array<root::octave_idx_type>,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13idx_colon_rep5printERSo"]
        pub fn idx_vector_idx_colon_rep_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13idx_range_rep9checkelemEl"]
        pub fn idx_vector_idx_range_rep_checkelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_range_rep15sort_uniq_cloneEb"]
        pub fn idx_vector_idx_range_rep_sort_uniq_clone(
            this: *mut ::std::os::raw::c_void,
            uniq: bool,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_range_rep8sort_idxER5ArrayIlE"]
        pub fn idx_vector_idx_range_rep_sort_idx(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::Array<root::octave_idx_type>,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector13idx_range_rep5printERSo"]
        pub fn idx_vector_idx_range_rep_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector13idx_range_rep8as_arrayEv"]
        pub fn idx_vector_idx_range_rep_as_array(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_scalar_rep9checkelemEl"]
        pub fn idx_vector_idx_scalar_rep_checkelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_scalar_rep8sort_idxER5ArrayIlE"]
        pub fn idx_vector_idx_scalar_rep_sort_idx(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::Array<root::octave_idx_type>,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_scalar_rep5printERSo"]
        pub fn idx_vector_idx_scalar_rep_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_scalar_rep8as_arrayEv"]
        pub fn idx_vector_idx_scalar_rep_as_array(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_repD1Ev"]
        pub fn idx_vector_idx_vector_rep_idx_vector_rep_destructor(
            this: *mut root::idx_vector_idx_vector_rep,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_vector_rep9checkelemEl"]
        pub fn idx_vector_idx_vector_rep_checkelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_rep15sort_uniq_cloneEb"]
        pub fn idx_vector_idx_vector_rep_sort_uniq_clone(
            this: *mut ::std::os::raw::c_void,
            uniq: bool,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_rep8sort_idxER5ArrayIlE"]
        pub fn idx_vector_idx_vector_rep_sort_idx(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::Array<root::octave_idx_type>,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector14idx_vector_rep5printERSo"]
        pub fn idx_vector_idx_vector_rep_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector14idx_vector_rep8as_arrayEv"]
        pub fn idx_vector_idx_vector_rep_as_array(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_mask_repD1Ev"]
        pub fn idx_vector_idx_mask_rep_idx_mask_rep_destructor(
            this: *mut root::idx_vector_idx_mask_rep,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector12idx_mask_rep5xelemEl"]
        pub fn idx_vector_idx_mask_rep_xelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector12idx_mask_rep9checkelemEl"]
        pub fn idx_vector_idx_mask_rep_checkelem(
            this: *mut ::std::os::raw::c_void,
            i: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_mask_rep8sort_idxER5ArrayIlE"]
        pub fn idx_vector_idx_mask_rep_sort_idx(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::Array<root::octave_idx_type>,
        ) -> *mut root::idx_vector_idx_base_rep;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10idx_vector12idx_mask_rep5printERSo"]
        pub fn idx_vector_idx_mask_rep_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10idx_vector12idx_mask_rep8as_arrayEv"]
        pub fn idx_vector_idx_mask_rep_as_array(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::octave_idx_type>;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ref_param {
        pub _address: u8,
    }
    pub type ref_param_type = u8;
    extern "C" {
        pub fn octave_qsort(
            base: *mut ::std::os::raw::c_void,
            n: usize,
            size: usize,
            cmp: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn octave_strcasecmp(
            s1: *const ::std::os::raw::c_char,
            s2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn octave_strncasecmp(
            s1: *const ::std::os::raw::c_char,
            s2: *const ::std::os::raw::c_char,
            n: usize,
        ) -> ::std::os::raw::c_int;
    }
    pub type Complex = [u64; 2usize];
    pub type FloatComplex = [u32; 2usize];
    pub const octave_exception_octave_no_exception: root::octave_exception = 0;
    pub const octave_exception_octave_exec_exception: root::octave_exception = 1;
    pub const octave_exception_octave_alloc_exception: root::octave_exception = 3;
    pub const octave_exception_octave_quit_exception: root::octave_exception = 4;
    pub type octave_exception = u32;
    extern "C" {
        pub fn octave_handle_signal();
    }
    extern "C" {
        pub fn octave_throw_interrupt_exception();
    }
    extern "C" {
        pub fn octave_throw_execution_exception();
    }
    extern "C" {
        pub fn octave_throw_bad_alloc();
    }
    extern "C" {
        pub fn octave_throw_exit_exception(
            exit_status: ::std::os::raw::c_int,
            safe_to_return: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn octave_rethrow_exception();
    }
    extern "C" {
        #[link_name = "\u{1}_Z12octave_fgetsB5cxx11P8_IO_FILE"]
        pub fn octave_fgets(arg1: *mut root::FILE) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12octave_fgetlB5cxx11P8_IO_FILE"]
        pub fn octave_fgetl(arg1: *mut root::FILE) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12octave_fgetsB5cxx11P8_IO_FILERb"]
        pub fn octave_fgets1(arg1: *mut root::FILE, eof: *mut bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12octave_fgetlB5cxx11P8_IO_FILERb"]
        pub fn octave_fgetl1(arg1: *mut root::FILE, eof: *mut bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17octave_read_valueIdET_RSi"]
        pub fn octave_read_value(is: *mut root::std::istream) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17octave_read_valueISt7complexIdEET_RSi"]
        pub fn octave_read_value1(is: *mut root::std::istream) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17octave_read_valueIfET_RSi"]
        pub fn octave_read_value2(is: *mut root::std::istream) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17octave_read_valueISt7complexIfEET_RSi"]
        pub fn octave_read_value3(is: *mut root::std::istream) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19octave_write_doubleRSod"]
        pub fn octave_write_double(os: *mut root::std::ostream, dval: f64);
    }
    extern "C" {
        #[link_name = "\u{1}_Z20octave_write_complexRSoRKSt7complexIdE"]
        pub fn octave_write_complex(os: *mut root::std::ostream, cval: *const root::Complex);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18octave_write_floatRSof"]
        pub fn octave_write_float(os: *mut root::std::ostream, dval: f32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z26octave_write_float_complexRSoRKSt7complexIfE"]
        pub fn octave_write_float_complex(
            os: *mut root::std::ostream,
            cval: *const root::FloatComplex,
        );
    }
    pub const sortmode_UNSORTED: root::sortmode = 0;
    pub const sortmode_ASCENDING: root::sortmode = 1;
    pub const sortmode_DESCENDING: root::sortmode = 2;
    pub type sortmode = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_sort<T> {
        pub compare: root::octave_sort_compare_fcn_type,
        pub ms: *mut root::octave_sort_MergeState<T>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type octave_sort_compare_fcn_type = ::core::option::Option<
        unsafe extern "C" fn(arg1: root::ref_param, arg2: root::ref_param) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_sort_s_slice {
        pub base: root::octave_idx_type,
        pub len: root::octave_idx_type,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_sort_MergeState<T> {
        pub min_gallop: root::octave_idx_type,
        pub a: *mut T,
        pub ia: *mut root::octave_idx_type,
        pub alloced: root::octave_idx_type,
        pub n: root::octave_idx_type,
        pub pending: *mut root::octave_sort_s_slice,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    pub struct Array__bindgen_vtable(::std::os::raw::c_void);
    #[doc = "! N Dimensional Array with copy-on-write semantics."]
    #[doc = "!"]
    #[doc = "! The Array class is at the root of Octave.  It provides a container"]
    #[doc = "! with an arbitrary number of dimensions.  The operator () provides"]
    #[doc = "! access to individual elements via subscript and linear indexing."]
    #[doc = "! Indexing starts at 0.  Arrays are column-major order as in Fortran."]
    #[doc = "!"]
    #[doc = "! @code{.cc}"]
    #[doc = "! // 3 D Array with 10 rows, 20 columns, and 5 pages, filled with 7.0"]
    #[doc = "! Array<double> A Array<double (dim_vector (10, 20, 5), 7.0);"]
    #[doc = "!"]
    #[doc = "! // set value for row 0, column 10, and page 3"]
    #[doc = "! A(0, 10, 3) = 2.5;"]
    #[doc = "!"]
    #[doc = "! // get value for row 1, column 2, and page 0"]
    #[doc = "! double v = A(1, 2, 0);"]
    #[doc = "!"]
    #[doc = "! // get value for 25th element (row 4, column 3, page 1)"]
    #[doc = "! double v = A(24);"]
    #[doc = "! @endcode"]
    #[doc = "!"]
    #[doc = "! ## Notes on STL compatibility"]
    #[doc = "!"]
    #[doc = "! ### size() and length()"]
    #[doc = "!"]
    #[doc = "! To access the total number of elements in an Array, use numel()"]
    #[doc = "! which is short for number of elements and is equivalent to the"]
    #[doc = "! Octave function with same name."]
    #[doc = "!"]
    #[doc = "! @code{.cc}"]
    #[doc = "! Array<int> A (dim_vector (10, 20, 4), 1);"]
    #[doc = "!"]
    #[doc = "! octave_idx_type n = A.numel (); // returns 800 (10x20x4)"]
    #[doc = "!"]
    #[doc = "! octave_idx_type nr = A.size (0); // returns 10 (number of rows/dimension 0)"]
    #[doc = "! octave_idx_type nc = A.size (1); // returns 20 (number of columns)"]
    #[doc = "! octave_idx_type nc = A.size (2); // returns 4 (size of dimension 3)"]
    #[doc = "! octave_idx_type l6 = A.size (6); // returns 1 (implicit singleton dimension)"]
    #[doc = "!"]
    #[doc = "! // Alternatively, get a dim_vector which represents the dimensions."]
    #[doc = "! dim_vector dims = A.dims ();"]
    #[doc = "! @endcode"]
    #[doc = "!"]
    #[doc = "! The methods size() and length() as they exist in the STL cause"]
    #[doc = "! confusion in the context of a N dimensional array."]
    #[doc = "!"]
    #[doc = "! The size() of an array is the length of all dimensions.  In Octave,"]
    #[doc = "! the size() function returns a row vector with the length of each"]
    #[doc = "! dimension, or the size of a specific dimension.  Only the latter is"]
    #[doc = "! present in liboctave."]
    #[doc = "!"]
    #[doc = "! Since there is more than 1 dimension, length() would not make sense"]
    #[doc = "! without expliciting which dimension.  If the function existed, which"]
    #[doc = "! length should it return?  Octave length() function returns the length"]
    #[doc = "! of the longest dimension which is an odd definition, only useful for"]
    #[doc = "! vectors and square matrices.  The alternatives numel(), rows(),"]
    #[doc = "! columns(), and size(d) are more explict and recommended."]
    #[doc = "!"]
    #[doc = "! ### size_type"]
    #[doc = "!"]
    #[doc = "! Array::size_type is `octave_idx_type` which is a typedef for `int`"]
    #[doc = "! or `long int`, depending whether Octave was configured for 64-bit"]
    #[doc = "! indexing."]
    #[doc = "!"]
    #[doc = "! This is a signed integer which may cause problems when mixed with"]
    #[doc = "! STL containers.  The reason is that Octave interacts with Fortran"]
    #[doc = "! routines, providing an interface many Fortran numeric libraries."]
    #[doc = "!"]
    #[doc = "! ## Subclasses"]
    #[doc = "!"]
    #[doc = "! The following subclasses specializations, will be of most use:"]
    #[doc = "!   - Matrix: Array<double> with only 2 dimensions"]
    #[doc = "!   - ComplexMatrix: Array<std::complex<double>> with only 2 dimensions"]
    #[doc = "!   - boolNDArray: N dimensional Array<bool>"]
    #[doc = "!   - ColumnVector: Array<double> with 1 column"]
    #[doc = "!   - string_vector: Array<std::string> with 1 column"]
    #[doc = "!   - Cell: Array<octave_value>, equivalent to an Octave cell."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array<T> {
        pub vtable_: *const Array__bindgen_vtable,
        pub dimensions: root::dim_vector,
        pub rep: *mut root::Array_ArrayRep<T>,
        pub slice_data: *mut T,
        pub slice_len: root::octave_idx_type,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[doc = "! The real representation of all arrays."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct Array_ArrayRep<T> {
        pub data: *mut T,
        pub len: root::octave_idx_type,
        pub count: root::octave::refcount<::std::os::raw::c_int>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type Array_element_type<T> = T;
    pub type Array_value_type<T> = T;
    #[doc = "! Used for operator(), and returned by numel() and size()"]
    #[doc = "! (beware: signed integer)"]
    pub type Array_size_type = root::octave_idx_type;
    pub type Array_crefT = root::ref_param;
    pub type Array_compare_fcn_type = ::core::option::Option<
        unsafe extern "C" fn(arg1: root::ref_param, arg2: root::ref_param) -> bool,
    >;
    extern "C" {
        pub fn octave_ieee_init();
    }
    pub const query_integer_type_registered: bool = false;
    pub type query_integer_type_type = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_prom {
        pub _address: u8,
    }
    pub type octave_int_cmp_op_prom_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_lt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_lt_ltval: bool = true;
    pub const octave_int_cmp_op_lt_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_lt() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_lt>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_lt))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_lt>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_lt))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_le {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_le_ltval: bool = true;
    pub const octave_int_cmp_op_le_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_le() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_le>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_le))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_le>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_le))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_gt {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_gt_ltval: bool = false;
    pub const octave_int_cmp_op_gt_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_gt() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_gt>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_gt))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_gt>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_gt))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_ge {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ge_ltval: bool = false;
    pub const octave_int_cmp_op_ge_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ge() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_ge>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_ge))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_ge>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_ge))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_eq {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_eq_ltval: bool = false;
    pub const octave_int_cmp_op_eq_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_eq() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_eq>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_eq))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_eq>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_eq))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_ne {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ne_ltval: bool = true;
    pub const octave_int_cmp_op_ne_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ne() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_ne>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_ne))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_ne>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_ne))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_ct {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_ct_ltval: bool = true;
    pub const octave_int_cmp_op_ct_gtval: bool = true;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_ct() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_ct>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_ct))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_ct>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_ct))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_cmp_op_cf {
        pub _address: u8,
    }
    pub const octave_int_cmp_op_cf_ltval: bool = false;
    pub const octave_int_cmp_op_cf_gtval: bool = false;
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op_cf() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op_cf>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op_cf))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op_cf>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op_cf))
        );
    }
    #[test]
    fn bindgen_test_layout_octave_int_cmp_op() {
        assert_eq!(
            ::core::mem::size_of::<octave_int_cmp_op>(),
            1usize,
            concat!("Size of: ", stringify!(octave_int_cmp_op))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_int_cmp_op>(),
            1usize,
            concat!("Alignment of ", stringify!(octave_int_cmp_op))
        );
    }
    pub type octave_int_cmp_op_uiop_utype = u8;
    pub type octave_int_cmp_op_uiop_stype = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_base {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int_arith {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_int<T> {
        pub ival: T,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type octave_int_val_type<T> = T;
    #[doc = "! Template for N-dimensional array classes with like-type math operators."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct MArray<T> {
        pub _base: root::Array<T>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    pub struct Sparse__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse<T> {
        pub vtable_: *const Sparse__bindgen_vtable,
        pub rep: *mut root::Sparse_SparseRep<T>,
        pub dimensions: root::dim_vector,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type Sparse_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Sparse_SparseRep<T> {
        pub d: *mut T,
        pub r: *mut root::octave_idx_type,
        pub c: *mut root::octave_idx_type,
        pub nzmx: root::octave_idx_type,
        pub nrows: root::octave_idx_type,
        pub ncols: root::octave_idx_type,
        pub count: root::octave::refcount<::std::os::raw::c_int>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MSparse<T> {
        pub _base: root::Sparse<T>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct MatrixType {
        pub typ: root::MatrixType_matrix_type,
        pub sp_bandden: f64,
        pub bandden: f64,
        pub upper_band: root::octave_idx_type,
        pub lower_band: root::octave_idx_type,
        pub dense: bool,
        pub full: bool,
        pub nperm: root::octave_idx_type,
        pub perm: *mut root::octave_idx_type,
    }
    pub const MatrixType_matrix_type_Unknown: root::MatrixType_matrix_type = 0;
    pub const MatrixType_matrix_type_Full: root::MatrixType_matrix_type = 1;
    pub const MatrixType_matrix_type_Diagonal: root::MatrixType_matrix_type = 2;
    pub const MatrixType_matrix_type_Permuted_Diagonal: root::MatrixType_matrix_type = 3;
    pub const MatrixType_matrix_type_Upper: root::MatrixType_matrix_type = 4;
    pub const MatrixType_matrix_type_Lower: root::MatrixType_matrix_type = 5;
    pub const MatrixType_matrix_type_Permuted_Upper: root::MatrixType_matrix_type = 6;
    pub const MatrixType_matrix_type_Permuted_Lower: root::MatrixType_matrix_type = 7;
    pub const MatrixType_matrix_type_Banded: root::MatrixType_matrix_type = 8;
    pub const MatrixType_matrix_type_Hermitian: root::MatrixType_matrix_type = 9;
    pub const MatrixType_matrix_type_Banded_Hermitian: root::MatrixType_matrix_type = 10;
    pub const MatrixType_matrix_type_Tridiagonal: root::MatrixType_matrix_type = 11;
    pub const MatrixType_matrix_type_Tridiagonal_Hermitian: root::MatrixType_matrix_type = 12;
    pub const MatrixType_matrix_type_Rectangular: root::MatrixType_matrix_type = 13;
    pub type MatrixType_matrix_type = u32;
    #[test]
    fn bindgen_test_layout_MatrixType() {
        assert_eq!(
            ::core::mem::size_of::<MatrixType>(),
            64usize,
            concat!("Size of: ", stringify!(MatrixType))
        );
        assert_eq!(
            ::core::mem::align_of::<MatrixType>(),
            8usize,
            concat!("Alignment of ", stringify!(MatrixType))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).typ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(typ)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).sp_bandden as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(sp_bandden)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).bandden as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(bandden)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).upper_band as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(upper_band)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).lower_band as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(lower_band)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).dense as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(dense)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).full as *const _ as usize },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(full)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).nperm as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(nperm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<MatrixType>())).perm as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(MatrixType),
                "::",
                stringify!(perm)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeEb"]
        pub fn MatrixType_type(this: *mut root::MatrixType, quiet: bool) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK6Matrix"]
        pub fn MatrixType_type1(
            this: *mut root::MatrixType,
            a: *const root::Matrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK13ComplexMatrix"]
        pub fn MatrixType_type2(
            this: *mut root::MatrixType,
            a: *const root::ComplexMatrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK11FloatMatrix"]
        pub fn MatrixType_type3(
            this: *mut root::MatrixType,
            a: *const root::FloatMatrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK18FloatComplexMatrix"]
        pub fn MatrixType_type4(
            this: *mut root::MatrixType,
            a: *const root::FloatComplexMatrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK12SparseMatrix"]
        pub fn MatrixType_type5(
            this: *mut root::MatrixType,
            a: *const root::SparseMatrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType4typeERK19SparseComplexMatrix"]
        pub fn MatrixType_type6(
            this: *mut root::MatrixType,
            a: *const root::SparseComplexMatrix,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10MatrixType4infoEv"]
        pub fn MatrixType_info(this: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType17mark_as_symmetricEv"]
        pub fn MatrixType_mark_as_symmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType19mark_as_unsymmetricEv"]
        pub fn MatrixType_mark_as_unsymmetric(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType16mark_as_permutedElPKl"]
        pub fn MatrixType_mark_as_permuted(
            this: *mut root::MatrixType,
            np: root::octave_idx_type,
            p: *const root::octave_idx_type,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixType18mark_as_unpermutedEv"]
        pub fn MatrixType_mark_as_unpermuted(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10MatrixType9transposeEv"]
        pub fn MatrixType_transpose(this: *const root::MatrixType) -> root::MatrixType;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1Ev"]
        pub fn MatrixType_MatrixType(this: *mut root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ERKS_"]
        pub fn MatrixType_MatrixType1(this: *mut root::MatrixType, a: *const root::MatrixType);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ERK6Matrix"]
        pub fn MatrixType_MatrixType2(this: *mut root::MatrixType, a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ERK13ComplexMatrix"]
        pub fn MatrixType_MatrixType3(this: *mut root::MatrixType, a: *const root::ComplexMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ERK11FloatMatrix"]
        pub fn MatrixType_MatrixType4(this: *mut root::MatrixType, a: *const root::FloatMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ERK18FloatComplexMatrix"]
        pub fn MatrixType_MatrixType5(
            this: *mut root::MatrixType,
            a: *const root::FloatComplexMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ENS_11matrix_typeEb"]
        pub fn MatrixType_MatrixType6(
            this: *mut root::MatrixType,
            t: root::MatrixType_matrix_type,
            _full: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ENS_11matrix_typeElPKlb"]
        pub fn MatrixType_MatrixType7(
            this: *mut root::MatrixType,
            t: root::MatrixType_matrix_type,
            np: root::octave_idx_type,
            p: *const root::octave_idx_type,
            _full: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeC1ENS_11matrix_typeEllb"]
        pub fn MatrixType_MatrixType8(
            this: *mut root::MatrixType,
            t: root::MatrixType_matrix_type,
            ku: root::octave_idx_type,
            kl: root::octave_idx_type,
            _full: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10MatrixTypeD1Ev"]
        pub fn MatrixType_MatrixType_destructor(this: *mut root::MatrixType);
    }
    impl MatrixType {
        #[inline]
        pub unsafe fn type_(&mut self, quiet: bool) -> ::std::os::raw::c_int {
            MatrixType_type(self, quiet)
        }
        #[inline]
        pub unsafe fn type1(&mut self, a: *const root::Matrix) -> ::std::os::raw::c_int {
            MatrixType_type1(self, a)
        }
        #[inline]
        pub unsafe fn type2(&mut self, a: *const root::ComplexMatrix) -> ::std::os::raw::c_int {
            MatrixType_type2(self, a)
        }
        #[inline]
        pub unsafe fn type3(&mut self, a: *const root::FloatMatrix) -> ::std::os::raw::c_int {
            MatrixType_type3(self, a)
        }
        #[inline]
        pub unsafe fn type4(
            &mut self,
            a: *const root::FloatComplexMatrix,
        ) -> ::std::os::raw::c_int {
            MatrixType_type4(self, a)
        }
        #[inline]
        pub unsafe fn type5(&mut self, a: *const root::SparseMatrix) -> ::std::os::raw::c_int {
            MatrixType_type5(self, a)
        }
        #[inline]
        pub unsafe fn type6(
            &mut self,
            a: *const root::SparseComplexMatrix,
        ) -> ::std::os::raw::c_int {
            MatrixType_type6(self, a)
        }
        #[inline]
        pub unsafe fn info(&self) {
            MatrixType_info(self)
        }
        #[inline]
        pub unsafe fn mark_as_symmetric(&mut self) {
            MatrixType_mark_as_symmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_unsymmetric(&mut self) {
            MatrixType_mark_as_unsymmetric(self)
        }
        #[inline]
        pub unsafe fn mark_as_permuted(
            &mut self,
            np: root::octave_idx_type,
            p: *const root::octave_idx_type,
        ) {
            MatrixType_mark_as_permuted(self, np, p)
        }
        #[inline]
        pub unsafe fn mark_as_unpermuted(&mut self) {
            MatrixType_mark_as_unpermuted(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::MatrixType {
            MatrixType_transpose(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::ComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::FloatComplexMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(t: root::MatrixType_matrix_type, _full: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType6(&mut __bindgen_tmp, t, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(
            t: root::MatrixType_matrix_type,
            np: root::octave_idx_type,
            p: *const root::octave_idx_type,
            _full: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType7(&mut __bindgen_tmp, t, np, p, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(
            t: root::MatrixType_matrix_type,
            ku: root::octave_idx_type,
            kl: root::octave_idx_type,
            _full: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            MatrixType_MatrixType8(&mut __bindgen_tmp, t, ku, kl, _full);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            MatrixType_MatrixType_destructor(self)
        }
    }
    pub const blas_trans_type_blas_no_trans: root::blas_trans_type = 78;
    pub const blas_trans_type_blas_trans: root::blas_trans_type = 84;
    pub const blas_trans_type_blas_conj_trans: root::blas_trans_type = 67;
    pub type blas_trans_type = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolNDArray {
        pub _base: root::Array<bool>,
    }
    pub type boolNDArray_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_boolNDArray() {
        assert_eq!(
            ::core::mem::size_of::<boolNDArray>(),
            40usize,
            concat!("Size of: ", stringify!(boolNDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<boolNDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(boolNDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray6invertEv"]
        pub fn boolNDArray_invert(this: *mut root::boolNDArray) -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray3allEi"]
        pub fn boolNDArray_all(
            this: *const root::boolNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray3anyEi"]
        pub fn boolNDArray_any(
            this: *const root::boolNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray3sumEi"]
        pub fn boolNDArray_sum(
            this: *const root::boolNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray6cumsumEi"]
        pub fn boolNDArray_cumsum(
            this: *const root::boolNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray6concatERKS_RK5ArrayIlE"]
        pub fn boolNDArray_concat(
            this: *mut root::boolNDArray,
            rb: *const root::boolNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray6insertERKS_ll"]
        pub fn boolNDArray_insert(
            this: *mut root::boolNDArray,
            a: *const root::boolNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray6insertERKS_RK5ArrayIlE"]
        pub fn boolNDArray_insert1(
            this: *mut root::boolNDArray,
            a: *const root::boolNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn boolNDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11boolNDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn boolNDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray4diagEl"]
        pub fn boolNDArray_diag(
            this: *const root::boolNDArray,
            k: root::octave_idx_type,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11boolNDArray4diagEll"]
        pub fn boolNDArray_diag1(
            this: *const root::boolNDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::boolNDArray;
    }
    impl boolNDArray {
        #[inline]
        pub unsafe fn invert(&mut self) -> *mut root::boolNDArray {
            boolNDArray_invert(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            boolNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            boolNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            boolNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            boolNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::boolNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::boolNDArray {
            boolNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::boolNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::boolNDArray {
            boolNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::boolNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::boolNDArray {
            boolNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            boolNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            boolNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::boolNDArray {
            boolNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::boolNDArray {
            boolNDArray_diag1(self, m, n)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct boolMatrix {
        pub _base: root::boolNDArray,
    }
    #[test]
    fn bindgen_test_layout_boolMatrix() {
        assert_eq!(
            ::core::mem::size_of::<boolMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(boolMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<boolMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(boolMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10boolMatrix6insertERKS_ll"]
        pub fn boolMatrix_insert(
            this: *mut root::boolMatrix,
            a: *const root::boolMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10boolMatrix4diagEl"]
        pub fn boolMatrix_diag(
            this: *const root::boolMatrix,
            k: root::octave_idx_type,
        ) -> root::boolMatrix;
    }
    impl boolMatrix {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::boolMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::boolMatrix {
            boolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::boolMatrix {
            boolMatrix_diag(self, k)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct string_vector {
        pub _base: root::Array<root::std::string>,
    }
    #[test]
    fn bindgen_test_layout_string_vector() {
        assert_eq!(
            ::core::mem::size_of::<string_vector>(),
            40usize,
            concat!("Size of: ", stringify!(string_vector))
        );
        assert_eq!(
            ::core::mem::align_of::<string_vector>(),
            8usize,
            concat!("Alignment of ", stringify!(string_vector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vector4sortEb"]
        pub fn string_vector_sort(
            this: *mut root::string_vector,
            make_uniq: bool,
        ) -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vector4uniqEv"]
        pub fn string_vector_uniq(this: *mut root::string_vector) -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vector6appendERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn string_vector_append(
            this: *mut root::string_vector,
            s: *const root::std::string,
        ) -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vector6appendERKS_"]
        pub fn string_vector_append1(
            this: *mut root::string_vector,
            sv: *const root::string_vector,
        ) -> *mut root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13string_vector4joinERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn string_vector_join(
            this: *const root::string_vector,
            sep: *const root::std::string,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13string_vector9c_str_vecEv"]
        pub fn string_vector_c_str_vec(
            this: *const root::string_vector,
        ) -> *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13string_vector8std_listB5cxx11Ev"]
        pub fn string_vector_std_list(this: *const root::string_vector) -> [u64; 3usize];
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vector16delete_c_str_vecEPKPKc"]
        pub fn string_vector_delete_c_str_vec(arg1: *const *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13string_vector15list_in_columnsERSoiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn string_vector_list_in_columns(
            this: *const root::string_vector,
            arg1: *mut root::std::ostream,
            width: ::std::os::raw::c_int,
            prefix: *const root::std::string,
        ) -> *mut root::std::ostream;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vectorC1EPKPKc"]
        pub fn string_vector_string_vector(
            this: *mut root::string_vector,
            s: *const *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13string_vectorC1EPKPKcl"]
        pub fn string_vector_string_vector1(
            this: *mut root::string_vector,
            s: *const *const ::std::os::raw::c_char,
            n: root::octave_idx_type,
        );
    }
    impl string_vector {
        #[inline]
        pub unsafe fn sort(&mut self, make_uniq: bool) -> *mut root::string_vector {
            string_vector_sort(self, make_uniq)
        }
        #[inline]
        pub unsafe fn uniq(&mut self) -> *mut root::string_vector {
            string_vector_uniq(self)
        }
        #[inline]
        pub unsafe fn append(&mut self, s: *const root::std::string) -> *mut root::string_vector {
            string_vector_append(self, s)
        }
        #[inline]
        pub unsafe fn append1(
            &mut self,
            sv: *const root::string_vector,
        ) -> *mut root::string_vector {
            string_vector_append1(self, sv)
        }
        #[inline]
        pub unsafe fn join(&self, sep: *const root::std::string) -> root::std::string {
            string_vector_join(self, sep)
        }
        #[inline]
        pub unsafe fn c_str_vec(&self) -> *mut *mut ::std::os::raw::c_char {
            string_vector_c_str_vec(self)
        }
        #[inline]
        pub unsafe fn std_list(&self) -> [u64; 3usize] {
            string_vector_std_list(self)
        }
        #[inline]
        pub unsafe fn delete_c_str_vec(arg1: *const *const ::std::os::raw::c_char) {
            string_vector_delete_c_str_vec(arg1)
        }
        #[inline]
        pub unsafe fn list_in_columns(
            &self,
            arg1: *mut root::std::ostream,
            width: ::std::os::raw::c_int,
            prefix: *const root::std::string,
        ) -> *mut root::std::ostream {
            string_vector_list_in_columns(self, arg1, width, prefix)
        }
        #[inline]
        pub unsafe fn new(s: *const *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            string_vector_string_vector(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            s: *const *const ::std::os::raw::c_char,
            n: root::octave_idx_type,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            string_vector_string_vector1(&mut __bindgen_tmp, s, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charNDArray {
        pub _base: root::Array<::std::os::raw::c_char>,
    }
    pub type charNDArray_matrix_type = root::charMatrix;
    #[test]
    fn bindgen_test_layout_charNDArray() {
        assert_eq!(
            ::core::mem::size_of::<charNDArray>(),
            40usize,
            concat!("Size of: ", stringify!(charNDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<charNDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(charNDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3allEi"]
        pub fn charNDArray_all(
            this: *const root::charNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3anyEi"]
        pub fn charNDArray_any(
            this: *const root::charNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray6concatERKS_RK5ArrayIlE"]
        pub fn charNDArray_concat(
            this: *mut root::charNDArray,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray6concatERK7NDArrayRK5ArrayIlE"]
        pub fn charNDArray_concat1(
            this: *mut root::charNDArray,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3maxEi"]
        pub fn charNDArray_max(
            this: *const root::charNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3maxER5ArrayIlEi"]
        pub fn charNDArray_max1(
            this: *const root::charNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3minEi"]
        pub fn charNDArray_min(
            this: *const root::charNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray3minER5ArrayIlEi"]
        pub fn charNDArray_min1(
            this: *const root::charNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray6insertERKS_ll"]
        pub fn charNDArray_insert(
            this: *mut root::charNDArray,
            a: *const root::charNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray6insertERKS_RK5ArrayIlE"]
        pub fn charNDArray_insert1(
            this: *mut root::charNDArray,
            a: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn charNDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn charNDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray4diagEl"]
        pub fn charNDArray_diag(
            this: *const root::charNDArray,
            k: root::octave_idx_type,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11charNDArray4diagEll"]
        pub fn charNDArray_diag1(
            this: *const root::charNDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArrayC1Ec"]
        pub fn charNDArray_charNDArray(this: *mut root::charNDArray, c: ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArrayC1EPKc"]
        pub fn charNDArray_charNDArray1(
            this: *mut root::charNDArray,
            s: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArrayC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn charNDArray_charNDArray2(this: *mut root::charNDArray, s: *const root::std::string);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11charNDArrayC1ERK13string_vectorc"]
        pub fn charNDArray_charNDArray3(
            this: *mut root::charNDArray,
            s: *const root::string_vector,
            fill_value: ::std::os::raw::c_char,
        );
    }
    impl charNDArray {
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            charNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            charNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray {
            charNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray {
            charNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray {
            charNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::charNDArray {
            charNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::charNDArray {
            charNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::charNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charNDArray {
            charNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::charNDArray {
            charNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            charNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            charNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::charNDArray {
            charNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::charNDArray {
            charNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(c: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            charNDArray_charNDArray(&mut __bindgen_tmp, c);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(s: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            charNDArray_charNDArray1(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(s: *const root::std::string) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            charNDArray_charNDArray2(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(
            s: *const root::string_vector,
            fill_value: ::std::os::raw::c_char,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            charNDArray_charNDArray3(&mut __bindgen_tmp, s, fill_value);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct charMatrix {
        pub _base: root::charNDArray,
    }
    #[test]
    fn bindgen_test_layout_charMatrix() {
        assert_eq!(
            ::core::mem::size_of::<charMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(charMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<charMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(charMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10charMatrix6insertEPKcll"]
        pub fn charMatrix_insert(
            this: *mut root::charMatrix,
            s: *const ::std::os::raw::c_char,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10charMatrix6insertERKS_ll"]
        pub fn charMatrix_insert1(
            this: *mut root::charMatrix,
            a: *const root::charMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10charMatrix13row_as_stringB5cxx11Elb"]
        pub fn charMatrix_row_as_string(
            this: *const root::charMatrix,
            arg1: root::octave_idx_type,
            strip_ws: bool,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10charMatrix7extractEllll"]
        pub fn charMatrix_extract(
            this: *const root::charMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::charMatrix;
    }
    impl charMatrix {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            s: *const ::std::os::raw::c_char,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charMatrix {
            charMatrix_insert(self, s, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::charMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::charMatrix {
            charMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn row_as_string(
            &self,
            arg1: root::octave_idx_type,
            strip_ws: bool,
        ) -> root::std::string {
            charMatrix_row_as_string(self, arg1, strip_ws)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::charMatrix {
            charMatrix_extract(self, r1, c1, r2, c2)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct base_det<T> {
        pub c2: T,
        pub e2: ::std::os::raw::c_int,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type DET = root::base_det<f64>;
    pub type FloatDET = root::base_det<f32>;
    pub type ComplexDET = root::base_det<root::Complex>;
    pub type FloatComplexDET = root::base_det<root::FloatComplex>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagArray2<T> {
        pub _base: root::Array<T>,
        pub d1: root::octave_idx_type,
        pub d2: root::octave_idx_type,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[doc = "! Template for two dimensional diagonal array with math operators."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct MDiagArray2<T> {
        pub _base: root::DiagArray2<T>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct NDArray {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_NDArray() {
        assert_eq!(
            ::core::mem::size_of::<NDArray>(),
            40usize,
            concat!("Size of: ", stringify!(NDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<NDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(NDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray23any_element_is_negativeEb"]
        pub fn NDArray_any_element_is_negative(this: *const root::NDArray, arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray23any_element_is_positiveEb"]
        pub fn NDArray_any_element_is_positive(this: *const root::NDArray, arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray18any_element_is_nanEv"]
        pub fn NDArray_any_element_is_nan(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray25any_element_is_inf_or_nanEv"]
        pub fn NDArray_any_element_is_inf_or_nan(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray27any_element_not_one_or_zeroEv"]
        pub fn NDArray_any_element_not_one_or_zero(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray21all_elements_are_zeroEv"]
        pub fn NDArray_all_elements_are_zero(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn NDArray_all_elements_are_int_or_inf_or_nan(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray12all_integersERdS0_"]
        pub fn NDArray_all_integers(
            this: *const root::NDArray,
            max_val: *mut f64,
            min_val: *mut f64,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray12all_integersEv"]
        pub fn NDArray_all_integers1(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray19too_large_for_floatEv"]
        pub fn NDArray_too_large_for_float(this: *const root::NDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3allEi"]
        pub fn NDArray_all(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3anyEi"]
        pub fn NDArray_any(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray7cumprodEi"]
        pub fn NDArray_cumprod(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray6cumsumEi"]
        pub fn NDArray_cumsum(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray4prodEi"]
        pub fn NDArray_prod(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3sumEi"]
        pub fn NDArray_sum(this: *const root::NDArray, dim: ::std::os::raw::c_int)
            -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray4xsumEi"]
        pub fn NDArray_xsum(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray5sumsqEi"]
        pub fn NDArray_sumsq(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray6concatERKS_RK5ArrayIlE"]
        pub fn NDArray_concat(
            this: *mut root::NDArray,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray6concatERK14ComplexNDArrayRK5ArrayIlE"]
        pub fn NDArray_concat1(
            this: *mut root::NDArray,
            rb: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray6concatERK11charNDArrayRK5ArrayIlE"]
        pub fn NDArray_concat2(
            this: *mut root::NDArray,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3maxEi"]
        pub fn NDArray_max(this: *const root::NDArray, dim: ::std::os::raw::c_int)
            -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3maxER5ArrayIlEi"]
        pub fn NDArray_max1(
            this: *const root::NDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3minEi"]
        pub fn NDArray_min(this: *const root::NDArray, dim: ::std::os::raw::c_int)
            -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3minER5ArrayIlEi"]
        pub fn NDArray_min1(
            this: *const root::NDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray6cummaxEi"]
        pub fn NDArray_cummax(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray6cummaxER5ArrayIlEi"]
        pub fn NDArray_cummax1(
            this: *const root::NDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray6cumminEi"]
        pub fn NDArray_cummin(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray6cumminER5ArrayIlEi"]
        pub fn NDArray_cummin1(
            this: *const root::NDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray4diffEli"]
        pub fn NDArray_diff(
            this: *const root::NDArray,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray6insertERKS_ll"]
        pub fn NDArray_insert(
            this: *mut root::NDArray,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray6insertERKS_RK5ArrayIlE"]
        pub fn NDArray_insert1(
            this: *mut root::NDArray,
            a: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray3absEv"]
        pub fn NDArray_abs(this: *const root::NDArray) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray5isnanEv"]
        pub fn NDArray_isnan(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray5isinfEv"]
        pub fn NDArray_isinf(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray8isfiniteEv"]
        pub fn NDArray_isfinite(this: *const root::NDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray7fourierEi"]
        pub fn NDArray_fourier(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray8ifourierEi"]
        pub fn NDArray_ifourier(
            this: *const root::NDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray9fourier2dEv"]
        pub fn NDArray_fourier2d(this: *const root::NDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray10ifourier2dEv"]
        pub fn NDArray_ifourier2d(this: *const root::NDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray9fourierNdEv"]
        pub fn NDArray_fourierNd(this: *const root::NDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray10ifourierNdEv"]
        pub fn NDArray_ifourierNd(this: *const root::NDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn NDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn NDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray4diagEl"]
        pub fn NDArray_diag(this: *const root::NDArray, k: root::octave_idx_type) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK7NDArray4diagEll"]
        pub fn NDArray_diag1(
            this: *const root::NDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArrayC1ERK5ArrayIlEbb"]
        pub fn NDArray_NDArray(
            this: *mut root::NDArray,
            a: *const root::Array<root::octave_idx_type>,
            zero_based: bool,
            negative_to_nan: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7NDArrayC1ERK11charNDArray"]
        pub fn NDArray_NDArray1(this: *mut root::NDArray, arg1: *const root::charNDArray);
    }
    impl NDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            NDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            NDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            NDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            NDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            NDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            NDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            NDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64) -> bool {
            NDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            NDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            NDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            NDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            NDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::NDArray {
            NDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray {
            NDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(
            &mut self,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray {
            NDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray {
            NDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray {
            NDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray {
            NDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            NDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray {
            NDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(
            &self,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray {
            NDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::NDArray {
            NDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::NDArray {
            NDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray {
            NDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            NDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            NDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            NDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            NDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            NDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            NDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            NDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            NDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            NDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            NDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            NDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::NDArray {
            NDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::NDArray {
            NDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(
            a: *const root::Array<root::octave_idx_type>,
            zero_based: bool,
            negative_to_nan: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            NDArray_NDArray(&mut __bindgen_tmp, a, zero_based, negative_to_nan);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            NDArray_NDArray1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Matrix {
        pub _base: root::NDArray,
    }
    pub type Matrix_column_vector_type = root::ColumnVector;
    pub type Matrix_row_vector_type = root::RowVector;
    pub type Matrix_real_column_vector_type = root::ColumnVector;
    pub type Matrix_real_row_vector_type = root::RowVector;
    pub type Matrix_real_matrix_type = root::Matrix;
    pub type Matrix_complex_matrix_type = root::ComplexMatrix;
    pub type Matrix_real_diag_matrix_type = root::DiagMatrix;
    pub type Matrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type Matrix_real_elt_type = f64;
    pub type Matrix_complex_elt_type = root::Complex;
    pub type Matrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_Matrix() {
        assert_eq!(
            ::core::mem::size_of::<Matrix>(),
            40usize,
            concat!("Size of: ", stringify!(Matrix))
        );
        assert_eq!(
            ::core::mem::align_of::<Matrix>(),
            8usize,
            concat!("Alignment of ", stringify!(Matrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix11issymmetricEv"]
        pub fn Matrix_issymmetric(this: *const root::Matrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix6insertERKS_ll"]
        pub fn Matrix_insert(
            this: *mut root::Matrix,
            a: *const root::Matrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix6insertERK9RowVectorll"]
        pub fn Matrix_insert1(
            this: *mut root::Matrix,
            a: *const root::RowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix6insertERK12ColumnVectorll"]
        pub fn Matrix_insert2(
            this: *mut root::Matrix,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix6insertERK10DiagMatrixll"]
        pub fn Matrix_insert3(
            this: *mut root::Matrix,
            a: *const root::DiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix4fillEd"]
        pub fn Matrix_fill(this: *mut root::Matrix, val: f64) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6Matrix4fillEdllll"]
        pub fn Matrix_fill1(
            this: *mut root::Matrix,
            val: f64,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6appendERKS_"]
        pub fn Matrix_append(this: *const root::Matrix, a: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6appendERK9RowVector"]
        pub fn Matrix_append1(this: *const root::Matrix, a: *const root::RowVector)
            -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6appendERK12ColumnVector"]
        pub fn Matrix_append2(
            this: *const root::Matrix,
            a: *const root::ColumnVector,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6appendERK10DiagMatrix"]
        pub fn Matrix_append3(
            this: *const root::Matrix,
            a: *const root::DiagMatrix,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5stackERKS_"]
        pub fn Matrix_stack(this: *const root::Matrix, a: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5stackERK9RowVector"]
        pub fn Matrix_stack1(this: *const root::Matrix, a: *const root::RowVector) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5stackERK12ColumnVector"]
        pub fn Matrix_stack2(
            this: *const root::Matrix,
            a: *const root::ColumnVector,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5stackERK10DiagMatrix"]
        pub fn Matrix_stack3(this: *const root::Matrix, a: *const root::DiagMatrix)
            -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7extractEllll"]
        pub fn Matrix_extract(
            this: *const root::Matrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix9extract_nEllll"]
        pub fn Matrix_extract_n(
            this: *const root::Matrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix3rowEl"]
        pub fn Matrix_row(this: *const root::Matrix, i: root::octave_idx_type) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6columnEl"]
        pub fn Matrix_column(
            this: *const root::Matrix,
            i: root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseEv"]
        pub fn Matrix_inverse(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseERl"]
        pub fn Matrix_inverse1(
            this: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseERlRdbb"]
        pub fn Matrix_inverse2(
            this: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseER10MatrixType"]
        pub fn Matrix_inverse3(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseER10MatrixTypeRl"]
        pub fn Matrix_inverse4(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7inverseER10MatrixTypeRlRdbb"]
        pub fn Matrix_inverse5(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix14pseudo_inverseEd"]
        pub fn Matrix_pseudo_inverse(this: *const root::Matrix, tol: f64) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7fourierEv"]
        pub fn Matrix_fourier(this: *const root::Matrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix8ifourierEv"]
        pub fn Matrix_ifourier(this: *const root::Matrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix9fourier2dEv"]
        pub fn Matrix_fourier2d(this: *const root::Matrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix10ifourier2dEv"]
        pub fn Matrix_ifourier2d(this: *const root::Matrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix11determinantEv"]
        pub fn Matrix_determinant(this: *const root::Matrix) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix11determinantERl"]
        pub fn Matrix_determinant1(
            this: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix11determinantERlRdb"]
        pub fn Matrix_determinant2(
            this: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix11determinantER10MatrixTypeRlRdb"]
        pub fn Matrix_determinant3(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5rcondEv"]
        pub fn Matrix_rcond(this: *const root::Matrix) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5rcondER10MatrixType"]
        pub fn Matrix_rcond1(this: *const root::Matrix, mattype: *mut root::MatrixType) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRKS_"]
        pub fn Matrix_solve(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRKS_Rl"]
        pub fn Matrix_solve1(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRKS_RlRd"]
        pub fn Matrix_solve2(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRKS_RlRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve3(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn Matrix_solve4(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRl"]
        pub fn Matrix_solve5(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRlRd"]
        pub fn Matrix_solve6(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK13ComplexMatrixRlRdPFvdEb15blas_trans_type"]
        pub fn Matrix_solve7(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn Matrix_solve8(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRl"]
        pub fn Matrix_solve9(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRlRd"]
        pub fn Matrix_solve10(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK12ColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve11(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn Matrix_solve12(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRl"]
        pub fn Matrix_solve13(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRd"]
        pub fn Matrix_solve14(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve15(
            this: *const root::Matrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERKS_"]
        pub fn Matrix_solve16(this: *const root::Matrix, b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERKS_Rl"]
        pub fn Matrix_solve17(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERKS_RlRd"]
        pub fn Matrix_solve18(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERKS_RlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve19(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK13ComplexMatrix"]
        pub fn Matrix_solve20(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK13ComplexMatrixRl"]
        pub fn Matrix_solve21(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK13ComplexMatrixRlRd"]
        pub fn Matrix_solve22(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK13ComplexMatrixRlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve23(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK12ColumnVector"]
        pub fn Matrix_solve24(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK12ColumnVectorRl"]
        pub fn Matrix_solve25(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK12ColumnVectorRlRd"]
        pub fn Matrix_solve26(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK12ColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve27(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK19ComplexColumnVector"]
        pub fn Matrix_solve28(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK19ComplexColumnVectorRl"]
        pub fn Matrix_solve29(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK19ComplexColumnVectorRlRd"]
        pub fn Matrix_solve30(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5solveERK19ComplexColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn Matrix_solve31(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERKS_"]
        pub fn Matrix_lssolve(this: *const root::Matrix, b: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERKS_Rl"]
        pub fn Matrix_lssolve1(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERKS_RlS2_"]
        pub fn Matrix_lssolve2(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERKS_RlS2_Rd"]
        pub fn Matrix_lssolve3(
            this: *const root::Matrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK13ComplexMatrix"]
        pub fn Matrix_lssolve4(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK13ComplexMatrixRl"]
        pub fn Matrix_lssolve5(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK13ComplexMatrixRlS3_"]
        pub fn Matrix_lssolve6(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK13ComplexMatrixRlS3_Rd"]
        pub fn Matrix_lssolve7(
            this: *const root::Matrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK12ColumnVector"]
        pub fn Matrix_lssolve8(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK12ColumnVectorRl"]
        pub fn Matrix_lssolve9(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK12ColumnVectorRlS3_"]
        pub fn Matrix_lssolve10(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK12ColumnVectorRlS3_Rd"]
        pub fn Matrix_lssolve11(
            this: *const root::Matrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK19ComplexColumnVector"]
        pub fn Matrix_lssolve12(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK19ComplexColumnVectorRl"]
        pub fn Matrix_lssolve13(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK19ComplexColumnVectorRlS3_"]
        pub fn Matrix_lssolve14(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7lssolveERK19ComplexColumnVectorRlS3_Rd"]
        pub fn Matrix_lssolve15(
            this: *const root::Matrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix3allEi"]
        pub fn Matrix_all(
            this: *const root::Matrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix3anyEi"]
        pub fn Matrix_any(
            this: *const root::Matrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7cumprodEi"]
        pub fn Matrix_cumprod(
            this: *const root::Matrix,
            dim: ::std::os::raw::c_int,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix6cumsumEi"]
        pub fn Matrix_cumsum(this: *const root::Matrix, dim: ::std::os::raw::c_int)
            -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix4prodEi"]
        pub fn Matrix_prod(this: *const root::Matrix, dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix3sumEi"]
        pub fn Matrix_sum(this: *const root::Matrix, dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix5sumsqEi"]
        pub fn Matrix_sumsq(this: *const root::Matrix, dim: ::std::os::raw::c_int) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix3absEv"]
        pub fn Matrix_abs(this: *const root::Matrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix4diagEl"]
        pub fn Matrix_diag(this: *const root::Matrix, k: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix4diagEll"]
        pub fn Matrix_diag1(
            this: *const root::Matrix,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7row_minEv"]
        pub fn Matrix_row_min(this: *const root::Matrix) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7row_maxEv"]
        pub fn Matrix_row_max(this: *const root::Matrix) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7row_minER5ArrayIlE"]
        pub fn Matrix_row_min1(
            this: *const root::Matrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix7row_maxER5ArrayIlE"]
        pub fn Matrix_row_max1(
            this: *const root::Matrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix10column_minEv"]
        pub fn Matrix_column_min(this: *const root::Matrix) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix10column_maxEv"]
        pub fn Matrix_column_max(this: *const root::Matrix) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix10column_minER5ArrayIlE"]
        pub fn Matrix_column_min1(
            this: *const root::Matrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6Matrix10column_maxER5ArrayIlE"]
        pub fn Matrix_column_max1(
            this: *const root::Matrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK9RowVector"]
        pub fn Matrix_Matrix(this: *mut root::Matrix, rv: *const root::RowVector);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK12ColumnVector"]
        pub fn Matrix_Matrix1(this: *mut root::Matrix, cv: *const root::ColumnVector);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK10DiagMatrix"]
        pub fn Matrix_Matrix2(this: *mut root::Matrix, a: *const root::DiagMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK11MDiagArray2IdE"]
        pub fn Matrix_Matrix3(this: *mut root::Matrix, a: *const root::MDiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK10DiagArray2IdE"]
        pub fn Matrix_Matrix4(this: *mut root::Matrix, a: *const root::DiagArray2<f64>);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK10PermMatrix"]
        pub fn Matrix_Matrix5(this: *mut root::Matrix, a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK10boolMatrix"]
        pub fn Matrix_Matrix6(this: *mut root::Matrix, a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6MatrixC1ERK10charMatrix"]
        pub fn Matrix_Matrix7(this: *mut root::Matrix, a: *const root::charMatrix);
    }
    impl Matrix {
        #[inline]
        pub unsafe fn issymmetric(&self) -> bool {
            Matrix_issymmetric(self)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::Matrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix {
            Matrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::RowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix {
            Matrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix {
            Matrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(
            &mut self,
            a: *const root::DiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Matrix {
            Matrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::Matrix {
            Matrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f64,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::Matrix {
            Matrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector) -> root::Matrix {
            Matrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector) -> root::Matrix {
            Matrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix) -> root::Matrix {
            Matrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix) -> root::Matrix {
            Matrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector) -> root::Matrix {
            Matrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector) -> root::Matrix {
            Matrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix) -> root::Matrix {
            Matrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::RowVector {
            Matrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ColumnVector {
            Matrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::Matrix {
            Matrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type) -> root::Matrix {
            Matrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::Matrix {
            Matrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType) -> root::Matrix {
            Matrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::Matrix {
            Matrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::Matrix {
            Matrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            Matrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            Matrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            Matrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            Matrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            Matrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type) -> root::DET {
            Matrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::DET {
            Matrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::DET {
            Matrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 {
            Matrix_rcond(self)
        }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            Matrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::Matrix {
            Matrix_solve(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_solve1(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix {
            Matrix_solve2(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::Matrix {
            Matrix_solve3(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix {
            Matrix_solve4(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            Matrix_solve5(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            Matrix_solve6(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            Matrix_solve7(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector {
            Matrix_solve8(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            Matrix_solve9(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector {
            Matrix_solve10(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ColumnVector {
            Matrix_solve11(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            Matrix_solve12(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            Matrix_solve13(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            Matrix_solve14(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            Matrix_solve15(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix {
            Matrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::Matrix {
            Matrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            Matrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            Matrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            Matrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            Matrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector) -> root::ColumnVector {
            Matrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            Matrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector {
            Matrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ColumnVector {
            Matrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            Matrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            Matrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            Matrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::Matrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            Matrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix) -> root::Matrix {
            Matrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::Matrix {
            Matrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::Matrix {
            Matrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            Matrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            Matrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            Matrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            Matrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector) -> root::ColumnVector {
            Matrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            Matrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            Matrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ColumnVector {
            Matrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            Matrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            Matrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            Matrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            Matrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            Matrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            Matrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::Matrix {
            Matrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix {
            Matrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Matrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::DiagMatrix {
            Matrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ColumnVector {
            Matrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ColumnVector {
            Matrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ColumnVector {
            Matrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ColumnVector {
            Matrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::RowVector {
            Matrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::RowVector {
            Matrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::RowVector {
            Matrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::RowVector {
            Matrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Matrix_Matrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexNDArray {
        pub _base: root::MArray<root::Complex>,
    }
    #[test]
    fn bindgen_test_layout_ComplexNDArray() {
        assert_eq!(
            ::core::mem::size_of::<ComplexNDArray>(),
            40usize,
            concat!("Size of: ", stringify!(ComplexNDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<ComplexNDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(ComplexNDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray18any_element_is_nanEv"]
        pub fn ComplexNDArray_any_element_is_nan(this: *const root::ComplexNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn ComplexNDArray_any_element_is_inf_or_nan(this: *const root::ComplexNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray21all_elements_are_realEv"]
        pub fn ComplexNDArray_all_elements_are_real(this: *const root::ComplexNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray12all_integersERdS0_"]
        pub fn ComplexNDArray_all_integers(
            this: *const root::ComplexNDArray,
            max_val: *mut f64,
            min_val: *mut f64,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray19too_large_for_floatEv"]
        pub fn ComplexNDArray_too_large_for_float(this: *const root::ComplexNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3allEi"]
        pub fn ComplexNDArray_all(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3anyEi"]
        pub fn ComplexNDArray_any(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray7cumprodEi"]
        pub fn ComplexNDArray_cumprod(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray6cumsumEi"]
        pub fn ComplexNDArray_cumsum(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray4prodEi"]
        pub fn ComplexNDArray_prod(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3sumEi"]
        pub fn ComplexNDArray_sum(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray4xsumEi"]
        pub fn ComplexNDArray_xsum(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray5sumsqEi"]
        pub fn ComplexNDArray_sumsq(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray6concatERKS_RK5ArrayIlE"]
        pub fn ComplexNDArray_concat(
            this: *mut root::ComplexNDArray,
            rb: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray6concatERK7NDArrayRK5ArrayIlE"]
        pub fn ComplexNDArray_concat1(
            this: *mut root::ComplexNDArray,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3maxEi"]
        pub fn ComplexNDArray_max(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3maxER5ArrayIlEi"]
        pub fn ComplexNDArray_max1(
            this: *const root::ComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3minEi"]
        pub fn ComplexNDArray_min(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3minER5ArrayIlEi"]
        pub fn ComplexNDArray_min1(
            this: *const root::ComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray6cummaxEi"]
        pub fn ComplexNDArray_cummax(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray6cummaxER5ArrayIlEi"]
        pub fn ComplexNDArray_cummax1(
            this: *const root::ComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray6cumminEi"]
        pub fn ComplexNDArray_cummin(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray6cumminER5ArrayIlEi"]
        pub fn ComplexNDArray_cummin1(
            this: *const root::ComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray4diffEli"]
        pub fn ComplexNDArray_diff(
            this: *const root::ComplexNDArray,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray6insertERK7NDArrayll"]
        pub fn ComplexNDArray_insert(
            this: *mut root::ComplexNDArray,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray6insertERKS_ll"]
        pub fn ComplexNDArray_insert1(
            this: *mut root::ComplexNDArray,
            a: *const root::ComplexNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray6insertERKS_RK5ArrayIlE"]
        pub fn ComplexNDArray_insert2(
            this: *mut root::ComplexNDArray,
            a: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray3absEv"]
        pub fn ComplexNDArray_abs(this: *const root::ComplexNDArray) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray5isnanEv"]
        pub fn ComplexNDArray_isnan(this: *const root::ComplexNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray5isinfEv"]
        pub fn ComplexNDArray_isinf(this: *const root::ComplexNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray8isfiniteEv"]
        pub fn ComplexNDArray_isfinite(this: *const root::ComplexNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray7fourierEi"]
        pub fn ComplexNDArray_fourier(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray8ifourierEi"]
        pub fn ComplexNDArray_ifourier(
            this: *const root::ComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray9fourier2dEv"]
        pub fn ComplexNDArray_fourier2d(this: *const root::ComplexNDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray10ifourier2dEv"]
        pub fn ComplexNDArray_ifourier2d(this: *const root::ComplexNDArray)
            -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray9fourierNdEv"]
        pub fn ComplexNDArray_fourierNd(this: *const root::ComplexNDArray) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray10ifourierNdEv"]
        pub fn ComplexNDArray_ifourierNd(this: *const root::ComplexNDArray)
            -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn ComplexNDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn ComplexNDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray4diagEl"]
        pub fn ComplexNDArray_diag(
            this: *const root::ComplexNDArray,
            k: root::octave_idx_type,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14ComplexNDArray4diagEll"]
        pub fn ComplexNDArray_diag1(
            this: *const root::ComplexNDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14ComplexNDArrayC1ERK11charNDArray"]
        pub fn ComplexNDArray_ComplexNDArray(
            this: *mut root::ComplexNDArray,
            arg1: *const root::charNDArray,
        );
    }
    impl ComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            ComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            ComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64) -> bool {
            ComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            ComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            ComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            ComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn xsum(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_xsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray {
            ComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::NDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::ComplexNDArray {
            ComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray {
            ComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray {
            ComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray {
            ComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray {
            ComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(
            &self,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray {
            ComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexNDArray {
            ComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::ComplexNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexNDArray {
            ComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::ComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::ComplexNDArray {
            ComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::NDArray {
            ComplexNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            ComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            ComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            ComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            ComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::ComplexNDArray {
            ComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            ComplexNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            ComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::ComplexNDArray {
            ComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexNDArray {
            ComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexNDArray_ComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexMatrix {
        pub _base: root::ComplexNDArray,
    }
    pub type ComplexMatrix_column_vector_type = root::ComplexColumnVector;
    pub type ComplexMatrix_row_vector_type = root::ComplexRowVector;
    pub type ComplexMatrix_real_column_vector_type = root::ColumnVector;
    pub type ComplexMatrix_real_row_vector_type = root::RowVector;
    pub type ComplexMatrix_real_matrix_type = root::Matrix;
    pub type ComplexMatrix_complex_matrix_type = root::ComplexMatrix;
    pub type ComplexMatrix_real_diag_matrix_type = root::DiagMatrix;
    pub type ComplexMatrix_complex_diag_matrix_type = root::ComplexDiagMatrix;
    pub type ComplexMatrix_real_elt_type = f64;
    pub type ComplexMatrix_complex_elt_type = root::Complex;
    pub type ComplexMatrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcon: f64)>;
    #[test]
    fn bindgen_test_layout_ComplexMatrix() {
        assert_eq!(
            ::core::mem::size_of::<ComplexMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(ComplexMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<ComplexMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(ComplexMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix11ishermitianEv"]
        pub fn ComplexMatrix_ishermitian(this: *const root::ComplexMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK6Matrixll"]
        pub fn ComplexMatrix_insert(
            this: *mut root::ComplexMatrix,
            a: *const root::Matrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK9RowVectorll"]
        pub fn ComplexMatrix_insert1(
            this: *mut root::ComplexMatrix,
            a: *const root::RowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK12ColumnVectorll"]
        pub fn ComplexMatrix_insert2(
            this: *mut root::ComplexMatrix,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK10DiagMatrixll"]
        pub fn ComplexMatrix_insert3(
            this: *mut root::ComplexMatrix,
            a: *const root::DiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERKS_ll"]
        pub fn ComplexMatrix_insert4(
            this: *mut root::ComplexMatrix,
            a: *const root::ComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK16ComplexRowVectorll"]
        pub fn ComplexMatrix_insert5(
            this: *mut root::ComplexMatrix,
            a: *const root::ComplexRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK19ComplexColumnVectorll"]
        pub fn ComplexMatrix_insert6(
            this: *mut root::ComplexMatrix,
            a: *const root::ComplexColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix6insertERK17ComplexDiagMatrixll"]
        pub fn ComplexMatrix_insert7(
            this: *mut root::ComplexMatrix,
            a: *const root::ComplexDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix4fillEd"]
        pub fn ComplexMatrix_fill(
            this: *mut root::ComplexMatrix,
            val: f64,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix4fillERKSt7complexIdE"]
        pub fn ComplexMatrix_fill1(
            this: *mut root::ComplexMatrix,
            val: *const root::Complex,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix4fillEdllll"]
        pub fn ComplexMatrix_fill2(
            this: *mut root::ComplexMatrix,
            val: f64,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrix4fillERKSt7complexIdEllll"]
        pub fn ComplexMatrix_fill3(
            this: *mut root::ComplexMatrix,
            val: *const root::Complex,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK6Matrix"]
        pub fn ComplexMatrix_append(
            this: *const root::ComplexMatrix,
            a: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK9RowVector"]
        pub fn ComplexMatrix_append1(
            this: *const root::ComplexMatrix,
            a: *const root::RowVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK12ColumnVector"]
        pub fn ComplexMatrix_append2(
            this: *const root::ComplexMatrix,
            a: *const root::ColumnVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK10DiagMatrix"]
        pub fn ComplexMatrix_append3(
            this: *const root::ComplexMatrix,
            a: *const root::DiagMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERKS_"]
        pub fn ComplexMatrix_append4(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK16ComplexRowVector"]
        pub fn ComplexMatrix_append5(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexRowVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK19ComplexColumnVector"]
        pub fn ComplexMatrix_append6(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexColumnVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6appendERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_append7(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexDiagMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK6Matrix"]
        pub fn ComplexMatrix_stack(
            this: *const root::ComplexMatrix,
            a: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK9RowVector"]
        pub fn ComplexMatrix_stack1(
            this: *const root::ComplexMatrix,
            a: *const root::RowVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK12ColumnVector"]
        pub fn ComplexMatrix_stack2(
            this: *const root::ComplexMatrix,
            a: *const root::ColumnVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK10DiagMatrix"]
        pub fn ComplexMatrix_stack3(
            this: *const root::ComplexMatrix,
            a: *const root::DiagMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERKS_"]
        pub fn ComplexMatrix_stack4(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK16ComplexRowVector"]
        pub fn ComplexMatrix_stack5(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexRowVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK19ComplexColumnVector"]
        pub fn ComplexMatrix_stack6(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexColumnVector,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5stackERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_stack7(
            this: *const root::ComplexMatrix,
            a: *const root::ComplexDiagMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7extractEllll"]
        pub fn ComplexMatrix_extract(
            this: *const root::ComplexMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix9extract_nEllll"]
        pub fn ComplexMatrix_extract_n(
            this: *const root::ComplexMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix3rowEl"]
        pub fn ComplexMatrix_row(
            this: *const root::ComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6columnEl"]
        pub fn ComplexMatrix_column(
            this: *const root::ComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseEv"]
        pub fn ComplexMatrix_inverse(this: *const root::ComplexMatrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseERl"]
        pub fn ComplexMatrix_inverse1(
            this: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseERlRdbb"]
        pub fn ComplexMatrix_inverse2(
            this: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseER10MatrixType"]
        pub fn ComplexMatrix_inverse3(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseER10MatrixTypeRl"]
        pub fn ComplexMatrix_inverse4(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7inverseER10MatrixTypeRlRdbb"]
        pub fn ComplexMatrix_inverse5(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix14pseudo_inverseEd"]
        pub fn ComplexMatrix_pseudo_inverse(
            this: *const root::ComplexMatrix,
            tol: f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7fourierEv"]
        pub fn ComplexMatrix_fourier(this: *const root::ComplexMatrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix8ifourierEv"]
        pub fn ComplexMatrix_ifourier(this: *const root::ComplexMatrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix9fourier2dEv"]
        pub fn ComplexMatrix_fourier2d(this: *const root::ComplexMatrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix10ifourier2dEv"]
        pub fn ComplexMatrix_ifourier2d(this: *const root::ComplexMatrix) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix11determinantEv"]
        pub fn ComplexMatrix_determinant(this: *const root::ComplexMatrix) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix11determinantERl"]
        pub fn ComplexMatrix_determinant1(
            this: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix11determinantERlRdb"]
        pub fn ComplexMatrix_determinant2(
            this: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix11determinantER10MatrixTypeRlRdb"]
        pub fn ComplexMatrix_determinant3(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5rcondEv"]
        pub fn ComplexMatrix_rcond(this: *const root::ComplexMatrix) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5rcondER10MatrixType"]
        pub fn ComplexMatrix_rcond1(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
        ) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn ComplexMatrix_solve(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRl"]
        pub fn ComplexMatrix_solve1(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRlRd"]
        pub fn ComplexMatrix_solve2(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK6MatrixRlRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve3(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn ComplexMatrix_solve4(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_Rl"]
        pub fn ComplexMatrix_solve5(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RlRd"]
        pub fn ComplexMatrix_solve6(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRKS_RlRdPFvdEb15blas_trans_type"]
        pub fn ComplexMatrix_solve7(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn ComplexMatrix_solve8(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRl"]
        pub fn ComplexMatrix_solve9(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRlRd"]
        pub fn ComplexMatrix_solve10(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve11(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve12(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRl"]
        pub fn ComplexMatrix_solve13(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRd"]
        pub fn ComplexMatrix_solve14(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve15(
            this: *const root::ComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK6Matrix"]
        pub fn ComplexMatrix_solve16(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK6MatrixRl"]
        pub fn ComplexMatrix_solve17(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK6MatrixRlRd"]
        pub fn ComplexMatrix_solve18(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK6MatrixRlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve19(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERKS_"]
        pub fn ComplexMatrix_solve20(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERKS_Rl"]
        pub fn ComplexMatrix_solve21(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERKS_RlRd"]
        pub fn ComplexMatrix_solve22(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERKS_RlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve23(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK12ColumnVector"]
        pub fn ComplexMatrix_solve24(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK12ColumnVectorRl"]
        pub fn ComplexMatrix_solve25(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK12ColumnVectorRlRd"]
        pub fn ComplexMatrix_solve26(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK12ColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve27(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_solve28(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRl"]
        pub fn ComplexMatrix_solve29(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRlRd"]
        pub fn ComplexMatrix_solve30(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5solveERK19ComplexColumnVectorRlRdPFvdE15blas_trans_type"]
        pub fn ComplexMatrix_solve31(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK6Matrix"]
        pub fn ComplexMatrix_lssolve(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK6MatrixRl"]
        pub fn ComplexMatrix_lssolve1(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK6MatrixRlS3_"]
        pub fn ComplexMatrix_lssolve2(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK6MatrixRlS3_Rd"]
        pub fn ComplexMatrix_lssolve3(
            this: *const root::ComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERKS_"]
        pub fn ComplexMatrix_lssolve4(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERKS_Rl"]
        pub fn ComplexMatrix_lssolve5(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERKS_RlS2_"]
        pub fn ComplexMatrix_lssolve6(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERKS_RlS2_Rd"]
        pub fn ComplexMatrix_lssolve7(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK12ColumnVector"]
        pub fn ComplexMatrix_lssolve8(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRl"]
        pub fn ComplexMatrix_lssolve9(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRlS3_"]
        pub fn ComplexMatrix_lssolve10(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK12ColumnVectorRlS3_Rd"]
        pub fn ComplexMatrix_lssolve11(
            this: *const root::ComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVector"]
        pub fn ComplexMatrix_lssolve12(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRl"]
        pub fn ComplexMatrix_lssolve13(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRlS3_"]
        pub fn ComplexMatrix_lssolve14(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7lssolveERK19ComplexColumnVectorRlS3_Rd"]
        pub fn ComplexMatrix_lssolve15(
            this: *const root::ComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix3allEi"]
        pub fn ComplexMatrix_all(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix3anyEi"]
        pub fn ComplexMatrix_any(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7cumprodEi"]
        pub fn ComplexMatrix_cumprod(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix6cumsumEi"]
        pub fn ComplexMatrix_cumsum(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix4prodEi"]
        pub fn ComplexMatrix_prod(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix3sumEi"]
        pub fn ComplexMatrix_sum(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix5sumsqEi"]
        pub fn ComplexMatrix_sumsq(
            this: *const root::ComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix3absEv"]
        pub fn ComplexMatrix_abs(this: *const root::ComplexMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix4diagEl"]
        pub fn ComplexMatrix_diag(
            this: *const root::ComplexMatrix,
            k: root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix4diagEll"]
        pub fn ComplexMatrix_diag1(
            this: *const root::ComplexMatrix,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix16row_is_real_onlyEl"]
        pub fn ComplexMatrix_row_is_real_only(
            this: *const root::ComplexMatrix,
            arg1: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix19column_is_real_onlyEl"]
        pub fn ComplexMatrix_column_is_real_only(
            this: *const root::ComplexMatrix,
            arg1: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7row_minEv"]
        pub fn ComplexMatrix_row_min(this: *const root::ComplexMatrix)
            -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7row_maxEv"]
        pub fn ComplexMatrix_row_max(this: *const root::ComplexMatrix)
            -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7row_minER5ArrayIlE"]
        pub fn ComplexMatrix_row_min1(
            this: *const root::ComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix7row_maxER5ArrayIlE"]
        pub fn ComplexMatrix_row_max1(
            this: *const root::ComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix10column_minEv"]
        pub fn ComplexMatrix_column_min(this: *const root::ComplexMatrix)
            -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix10column_maxEv"]
        pub fn ComplexMatrix_column_max(this: *const root::ComplexMatrix)
            -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix10column_minER5ArrayIlE"]
        pub fn ComplexMatrix_column_min1(
            this: *const root::ComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13ComplexMatrix10column_maxER5ArrayIlE"]
        pub fn ComplexMatrix_column_max1(
            this: *const root::ComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK6MatrixS2_"]
        pub fn ComplexMatrix_ComplexMatrix(
            this: *mut root::ComplexMatrix,
            re: *const root::Matrix,
            im: *const root::Matrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK6Matrix"]
        pub fn ComplexMatrix_ComplexMatrix1(this: *mut root::ComplexMatrix, a: *const root::Matrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK9RowVector"]
        pub fn ComplexMatrix_ComplexMatrix2(
            this: *mut root::ComplexMatrix,
            rv: *const root::RowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK12ColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix3(
            this: *mut root::ComplexMatrix,
            cv: *const root::ColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK10DiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix4(
            this: *mut root::ComplexMatrix,
            a: *const root::DiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK11MDiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix5(
            this: *mut root::ComplexMatrix,
            a: *const root::MDiagArray2<f64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK10DiagArray2IdE"]
        pub fn ComplexMatrix_ComplexMatrix6(
            this: *mut root::ComplexMatrix,
            a: *const root::DiagArray2<f64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK16ComplexRowVector"]
        pub fn ComplexMatrix_ComplexMatrix7(
            this: *mut root::ComplexMatrix,
            rv: *const root::ComplexRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK19ComplexColumnVector"]
        pub fn ComplexMatrix_ComplexMatrix8(
            this: *mut root::ComplexMatrix,
            cv: *const root::ComplexColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn ComplexMatrix_ComplexMatrix9(
            this: *mut root::ComplexMatrix,
            a: *const root::ComplexDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK11MDiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix10(
            this: *mut root::ComplexMatrix,
            a: *const root::MDiagArray2<root::Complex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn ComplexMatrix_ComplexMatrix11(
            this: *mut root::ComplexMatrix,
            a: *const root::DiagArray2<root::Complex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK10boolMatrix"]
        pub fn ComplexMatrix_ComplexMatrix12(
            this: *mut root::ComplexMatrix,
            a: *const root::boolMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13ComplexMatrixC1ERK10charMatrix"]
        pub fn ComplexMatrix_ComplexMatrix13(
            this: *mut root::ComplexMatrix,
            a: *const root::charMatrix,
        );
    }
    impl ComplexMatrix {
        #[inline]
        pub unsafe fn ishermitian(&self) -> bool {
            ComplexMatrix_ishermitian(self)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::Matrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::RowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(
            &mut self,
            a: *const root::DiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(
            &mut self,
            a: *const root::ComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(
            &mut self,
            a: *const root::ComplexRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(
            &mut self,
            a: *const root::ComplexColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(
            &mut self,
            a: *const root::ComplexDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f64,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::Complex,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexMatrix {
            ComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::RowVector) -> root::ComplexMatrix {
            ComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::ColumnVector) -> root::ComplexMatrix {
            ComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::DiagMatrix) -> root::ComplexMatrix {
            ComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(&self, a: *const root::ComplexMatrix) -> root::ComplexMatrix {
            ComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(&self, a: *const root::ComplexRowVector) -> root::ComplexMatrix {
            ComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(&self, a: *const root::ComplexColumnVector) -> root::ComplexMatrix {
            ComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(&self, a: *const root::ComplexDiagMatrix) -> root::ComplexMatrix {
            ComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::RowVector) -> root::ComplexMatrix {
            ComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::ColumnVector) -> root::ComplexMatrix {
            ComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::DiagMatrix) -> root::ComplexMatrix {
            ComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(&self, a: *const root::ComplexMatrix) -> root::ComplexMatrix {
            ComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(&self, a: *const root::ComplexRowVector) -> root::ComplexMatrix {
            ComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(&self, a: *const root::ComplexColumnVector) -> root::ComplexMatrix {
            ComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(&self, a: *const root::ComplexDiagMatrix) -> root::ComplexMatrix {
            ComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::ComplexRowVector {
            ComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ComplexColumnVector {
            ComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::ComplexMatrix {
            ComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type) -> root::ComplexMatrix {
            ComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::ComplexMatrix {
            ComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType) -> root::ComplexMatrix {
            ComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::ComplexMatrix {
            ComplexMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::ComplexMatrix {
            ComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::ComplexMatrix {
            ComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type) -> root::ComplexDET {
            ComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET {
            ComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET {
            ComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 {
            ComplexMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f64 {
            ComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve1(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve2(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve3(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve4(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve5(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve6(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve7(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve8(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve9(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve10(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve11(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve12(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve13(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve14(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve15(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            ComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::ColumnVector) -> root::ComplexColumnVector {
            ComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f64,
            sing_handler: root::ComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::Matrix) -> root::ComplexMatrix {
            ComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            ComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexMatrix {
            ComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(&self, b: *const root::ColumnVector) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f64,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            ComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            ComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::ComplexMatrix {
            ComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::ComplexMatrix {
            ComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::ComplexMatrix {
            ComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::ComplexMatrix {
            ComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::ComplexMatrix {
            ComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::Matrix {
            ComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::ComplexMatrix {
            ComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexDiagMatrix {
            ComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type) -> bool {
            ComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type) -> bool {
            ComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::ComplexColumnVector {
            ComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexColumnVector {
            ComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::ComplexRowVector {
            ComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexRowVector {
            ComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::ComplexRowVector {
            ComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(re: *const root::Matrix, im: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix(&mut __bindgen_tmp, re, im);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::Matrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(rv: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix2(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(cv: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix3(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::MDiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(rv: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix7(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(cv: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix8(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a: *const root::MDiagArray2<root::Complex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::DiagArray2<root::Complex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexMatrix_ComplexMatrix13(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatNDArray {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatNDArray() {
        assert_eq!(
            ::core::mem::size_of::<FloatNDArray>(),
            40usize,
            concat!("Size of: ", stringify!(FloatNDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatNDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatNDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray23any_element_is_negativeEb"]
        pub fn FloatNDArray_any_element_is_negative(
            this: *const root::FloatNDArray,
            arg1: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray23any_element_is_positiveEb"]
        pub fn FloatNDArray_any_element_is_positive(
            this: *const root::FloatNDArray,
            arg1: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray18any_element_is_nanEv"]
        pub fn FloatNDArray_any_element_is_nan(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatNDArray_any_element_is_inf_or_nan(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray27any_element_not_one_or_zeroEv"]
        pub fn FloatNDArray_any_element_not_one_or_zero(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray21all_elements_are_zeroEv"]
        pub fn FloatNDArray_all_elements_are_zero(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray34all_elements_are_int_or_inf_or_nanEv"]
        pub fn FloatNDArray_all_elements_are_int_or_inf_or_nan(
            this: *const root::FloatNDArray,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray12all_integersERfS0_"]
        pub fn FloatNDArray_all_integers(
            this: *const root::FloatNDArray,
            max_val: *mut f32,
            min_val: *mut f32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray12all_integersEv"]
        pub fn FloatNDArray_all_integers1(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray19too_large_for_floatEv"]
        pub fn FloatNDArray_too_large_for_float(this: *const root::FloatNDArray) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3allEi"]
        pub fn FloatNDArray_all(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3anyEi"]
        pub fn FloatNDArray_any(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray7cumprodEi"]
        pub fn FloatNDArray_cumprod(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray6cumsumEi"]
        pub fn FloatNDArray_cumsum(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray4prodEi"]
        pub fn FloatNDArray_prod(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray5dprodEi"]
        pub fn FloatNDArray_dprod(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3sumEi"]
        pub fn FloatNDArray_sum(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray4dsumEi"]
        pub fn FloatNDArray_dsum(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray5sumsqEi"]
        pub fn FloatNDArray_sumsq(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray6concatERKS_RK5ArrayIlE"]
        pub fn FloatNDArray_concat(
            this: *mut root::FloatNDArray,
            rb: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray6concatERK19FloatComplexNDArrayRK5ArrayIlE"]
        pub fn FloatNDArray_concat1(
            this: *mut root::FloatNDArray,
            rb: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray6concatERK11charNDArrayRK5ArrayIlE"]
        pub fn FloatNDArray_concat2(
            this: *mut root::FloatNDArray,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3maxEi"]
        pub fn FloatNDArray_max(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3maxER5ArrayIlEi"]
        pub fn FloatNDArray_max1(
            this: *const root::FloatNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3minEi"]
        pub fn FloatNDArray_min(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3minER5ArrayIlEi"]
        pub fn FloatNDArray_min1(
            this: *const root::FloatNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray6cummaxEi"]
        pub fn FloatNDArray_cummax(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray6cummaxER5ArrayIlEi"]
        pub fn FloatNDArray_cummax1(
            this: *const root::FloatNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray6cumminEi"]
        pub fn FloatNDArray_cummin(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray6cumminER5ArrayIlEi"]
        pub fn FloatNDArray_cummin1(
            this: *const root::FloatNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray4diffEli"]
        pub fn FloatNDArray_diff(
            this: *const root::FloatNDArray,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray6insertERKS_ll"]
        pub fn FloatNDArray_insert(
            this: *mut root::FloatNDArray,
            a: *const root::FloatNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray6insertERKS_RK5ArrayIlE"]
        pub fn FloatNDArray_insert1(
            this: *mut root::FloatNDArray,
            a: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray3absEv"]
        pub fn FloatNDArray_abs(this: *const root::FloatNDArray) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray5isnanEv"]
        pub fn FloatNDArray_isnan(this: *const root::FloatNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray5isinfEv"]
        pub fn FloatNDArray_isinf(this: *const root::FloatNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray8isfiniteEv"]
        pub fn FloatNDArray_isfinite(this: *const root::FloatNDArray) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray7fourierEi"]
        pub fn FloatNDArray_fourier(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray8ifourierEi"]
        pub fn FloatNDArray_ifourier(
            this: *const root::FloatNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray9fourier2dEv"]
        pub fn FloatNDArray_fourier2d(this: *const root::FloatNDArray)
            -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray10ifourier2dEv"]
        pub fn FloatNDArray_ifourier2d(
            this: *const root::FloatNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray9fourierNdEv"]
        pub fn FloatNDArray_fourierNd(this: *const root::FloatNDArray)
            -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray10ifourierNdEv"]
        pub fn FloatNDArray_ifourierNd(
            this: *const root::FloatNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn FloatNDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn FloatNDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray4diagEl"]
        pub fn FloatNDArray_diag(
            this: *const root::FloatNDArray,
            k: root::octave_idx_type,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12FloatNDArray4diagEll"]
        pub fn FloatNDArray_diag1(
            this: *const root::FloatNDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12FloatNDArrayC1ERK11charNDArray"]
        pub fn FloatNDArray_FloatNDArray(
            this: *mut root::FloatNDArray,
            arg1: *const root::charNDArray,
        );
    }
    impl FloatNDArray {
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_positive(&self, arg1: bool) -> bool {
            FloatNDArray_any_element_is_positive(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            FloatNDArray_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            FloatNDArray_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            FloatNDArray_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32, min_val: *mut f32) -> bool {
            FloatNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn all_integers1(&self) -> bool {
            FloatNDArray_all_integers1(self)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            FloatNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            FloatNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            FloatNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int) -> root::NDArray {
            FloatNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatNDArray {
            FloatNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray {
            FloatNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat2(
            &mut self,
            rb: *const root::charNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::charNDArray {
            FloatNDArray_concat2(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray {
            FloatNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray {
            FloatNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray {
            FloatNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> root::FloatNDArray {
            FloatNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray {
            FloatNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(
            &self,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatNDArray {
            FloatNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatNDArray {
            FloatNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::FloatNDArray {
            FloatNDArray_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            FloatNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            FloatNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::FloatNDArray {
            FloatNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatNDArray {
            FloatNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatNDArray_FloatNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatMatrix {
        pub _base: root::FloatNDArray,
    }
    pub type FloatMatrix_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_column_vector_type = root::FloatColumnVector;
    pub type FloatMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatMatrix_complex_matrix_type = root::FloatComplexMatrix;
    pub type FloatMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatMatrix_complex_diag_matrix_type = root::FloatComplexDiagMatrix;
    pub type FloatMatrix_real_elt_type = f32;
    pub type FloatMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatMatrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatMatrix() {
        assert_eq!(
            ::core::mem::size_of::<FloatMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(FloatMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix11issymmetricEv"]
        pub fn FloatMatrix_issymmetric(this: *const root::FloatMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix6insertERKS_ll"]
        pub fn FloatMatrix_insert(
            this: *mut root::FloatMatrix,
            a: *const root::FloatMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix6insertERK14FloatRowVectorll"]
        pub fn FloatMatrix_insert1(
            this: *mut root::FloatMatrix,
            a: *const root::FloatRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix6insertERK17FloatColumnVectorll"]
        pub fn FloatMatrix_insert2(
            this: *mut root::FloatMatrix,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix6insertERK15FloatDiagMatrixll"]
        pub fn FloatMatrix_insert3(
            this: *mut root::FloatMatrix,
            a: *const root::FloatDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix4fillEf"]
        pub fn FloatMatrix_fill(this: *mut root::FloatMatrix, val: f32) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrix4fillEfllll"]
        pub fn FloatMatrix_fill1(
            this: *mut root::FloatMatrix,
            val: f32,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6appendERKS_"]
        pub fn FloatMatrix_append(
            this: *const root::FloatMatrix,
            a: *const root::FloatMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6appendERK14FloatRowVector"]
        pub fn FloatMatrix_append1(
            this: *const root::FloatMatrix,
            a: *const root::FloatRowVector,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6appendERK17FloatColumnVector"]
        pub fn FloatMatrix_append2(
            this: *const root::FloatMatrix,
            a: *const root::FloatColumnVector,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatMatrix_append3(
            this: *const root::FloatMatrix,
            a: *const root::FloatDiagMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5stackERKS_"]
        pub fn FloatMatrix_stack(
            this: *const root::FloatMatrix,
            a: *const root::FloatMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5stackERK14FloatRowVector"]
        pub fn FloatMatrix_stack1(
            this: *const root::FloatMatrix,
            a: *const root::FloatRowVector,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5stackERK17FloatColumnVector"]
        pub fn FloatMatrix_stack2(
            this: *const root::FloatMatrix,
            a: *const root::FloatColumnVector,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatMatrix_stack3(
            this: *const root::FloatMatrix,
            a: *const root::FloatDiagMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7extractEllll"]
        pub fn FloatMatrix_extract(
            this: *const root::FloatMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix9extract_nEllll"]
        pub fn FloatMatrix_extract_n(
            this: *const root::FloatMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix3rowEl"]
        pub fn FloatMatrix_row(
            this: *const root::FloatMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6columnEl"]
        pub fn FloatMatrix_column(
            this: *const root::FloatMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseEv"]
        pub fn FloatMatrix_inverse(this: *const root::FloatMatrix) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseERl"]
        pub fn FloatMatrix_inverse1(
            this: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseERlRfbb"]
        pub fn FloatMatrix_inverse2(
            this: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseER10MatrixType"]
        pub fn FloatMatrix_inverse3(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseER10MatrixTypeRl"]
        pub fn FloatMatrix_inverse4(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7inverseER10MatrixTypeRlRfbb"]
        pub fn FloatMatrix_inverse5(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix14pseudo_inverseEf"]
        pub fn FloatMatrix_pseudo_inverse(
            this: *const root::FloatMatrix,
            tol: f32,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7fourierEv"]
        pub fn FloatMatrix_fourier(this: *const root::FloatMatrix) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix8ifourierEv"]
        pub fn FloatMatrix_ifourier(this: *const root::FloatMatrix) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix9fourier2dEv"]
        pub fn FloatMatrix_fourier2d(this: *const root::FloatMatrix) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix10ifourier2dEv"]
        pub fn FloatMatrix_ifourier2d(this: *const root::FloatMatrix) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix11determinantEv"]
        pub fn FloatMatrix_determinant(this: *const root::FloatMatrix) -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix11determinantERl"]
        pub fn FloatMatrix_determinant1(
            this: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix11determinantERlRfb"]
        pub fn FloatMatrix_determinant2(
            this: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix11determinantER10MatrixTypeRlRfb"]
        pub fn FloatMatrix_determinant3(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5rcondEv"]
        pub fn FloatMatrix_rcond(this: *const root::FloatMatrix) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5rcondER10MatrixType"]
        pub fn FloatMatrix_rcond1(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
        ) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatMatrix_solve(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRKS_Rl"]
        pub fn FloatMatrix_solve1(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RlRf"]
        pub fn FloatMatrix_solve2(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRKS_RlRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve3(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve4(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRl"]
        pub fn FloatMatrix_solve5(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRlRf"]
        pub fn FloatMatrix_solve6(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK18FloatComplexMatrixRlRfPFvfEb15blas_trans_type"]
        pub fn FloatMatrix_solve7(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatMatrix_solve8(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRl"]
        pub fn FloatMatrix_solve9(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRlRf"]
        pub fn FloatMatrix_solve10(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK17FloatColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve11(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve12(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRl"]
        pub fn FloatMatrix_solve13(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRlRf"]
        pub fn FloatMatrix_solve14(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve15(
            this: *const root::FloatMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERKS_"]
        pub fn FloatMatrix_solve16(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERKS_Rl"]
        pub fn FloatMatrix_solve17(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERKS_RlRf"]
        pub fn FloatMatrix_solve18(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERKS_RlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve19(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_solve20(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRl"]
        pub fn FloatMatrix_solve21(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRlRf"]
        pub fn FloatMatrix_solve22(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK18FloatComplexMatrixRlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve23(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK17FloatColumnVector"]
        pub fn FloatMatrix_solve24(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK17FloatColumnVectorRl"]
        pub fn FloatMatrix_solve25(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK17FloatColumnVectorRlRf"]
        pub fn FloatMatrix_solve26(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK17FloatColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve27(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_solve28(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRl"]
        pub fn FloatMatrix_solve29(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRlRf"]
        pub fn FloatMatrix_solve30(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5solveERK24FloatComplexColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatMatrix_solve31(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERKS_"]
        pub fn FloatMatrix_lssolve(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERKS_Rl"]
        pub fn FloatMatrix_lssolve1(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERKS_RlS2_"]
        pub fn FloatMatrix_lssolve2(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERKS_RlS2_Rf"]
        pub fn FloatMatrix_lssolve3(
            this: *const root::FloatMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrix"]
        pub fn FloatMatrix_lssolve4(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRl"]
        pub fn FloatMatrix_lssolve5(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRlS3_"]
        pub fn FloatMatrix_lssolve6(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK18FloatComplexMatrixRlS3_Rf"]
        pub fn FloatMatrix_lssolve7(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatMatrix_lssolve8(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRl"]
        pub fn FloatMatrix_lssolve9(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRlS3_"]
        pub fn FloatMatrix_lssolve10(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK17FloatColumnVectorRlS3_Rf"]
        pub fn FloatMatrix_lssolve11(
            this: *const root::FloatMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatMatrix_lssolve12(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRl"]
        pub fn FloatMatrix_lssolve13(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRlS3_"]
        pub fn FloatMatrix_lssolve14(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7lssolveERK24FloatComplexColumnVectorRlS3_Rf"]
        pub fn FloatMatrix_lssolve15(
            this: *const root::FloatMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7cumprodEi"]
        pub fn FloatMatrix_cumprod(
            this: *const root::FloatMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix6cumsumEi"]
        pub fn FloatMatrix_cumsum(
            this: *const root::FloatMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix4prodEi"]
        pub fn FloatMatrix_prod(
            this: *const root::FloatMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix3sumEi"]
        pub fn FloatMatrix_sum(
            this: *const root::FloatMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix5sumsqEi"]
        pub fn FloatMatrix_sumsq(
            this: *const root::FloatMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix3absEv"]
        pub fn FloatMatrix_abs(this: *const root::FloatMatrix) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix4diagEl"]
        pub fn FloatMatrix_diag(
            this: *const root::FloatMatrix,
            k: root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix4diagEll"]
        pub fn FloatMatrix_diag1(
            this: *const root::FloatMatrix,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7row_minEv"]
        pub fn FloatMatrix_row_min(this: *const root::FloatMatrix) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7row_maxEv"]
        pub fn FloatMatrix_row_max(this: *const root::FloatMatrix) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7row_minER5ArrayIlE"]
        pub fn FloatMatrix_row_min1(
            this: *const root::FloatMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix7row_maxER5ArrayIlE"]
        pub fn FloatMatrix_row_max1(
            this: *const root::FloatMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix10column_minEv"]
        pub fn FloatMatrix_column_min(this: *const root::FloatMatrix) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix10column_maxEv"]
        pub fn FloatMatrix_column_max(this: *const root::FloatMatrix) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix10column_minER5ArrayIlE"]
        pub fn FloatMatrix_column_min1(
            this: *const root::FloatMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11FloatMatrix10column_maxER5ArrayIlE"]
        pub fn FloatMatrix_column_max1(
            this: *const root::FloatMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK14FloatRowVector"]
        pub fn FloatMatrix_FloatMatrix(
            this: *mut root::FloatMatrix,
            rv: *const root::FloatRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK17FloatColumnVector"]
        pub fn FloatMatrix_FloatMatrix1(
            this: *mut root::FloatMatrix,
            cv: *const root::FloatColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatMatrix_FloatMatrix2(
            this: *mut root::FloatMatrix,
            a: *const root::FloatDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix3(
            this: *mut root::FloatMatrix,
            a: *const root::MDiagArray2<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatMatrix_FloatMatrix4(
            this: *mut root::FloatMatrix,
            a: *const root::DiagArray2<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK10PermMatrix"]
        pub fn FloatMatrix_FloatMatrix5(this: *mut root::FloatMatrix, a: *const root::PermMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK10boolMatrix"]
        pub fn FloatMatrix_FloatMatrix6(this: *mut root::FloatMatrix, a: *const root::boolMatrix);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11FloatMatrixC1ERK10charMatrix"]
        pub fn FloatMatrix_FloatMatrix7(this: *mut root::FloatMatrix, a: *const root::charMatrix);
    }
    impl FloatMatrix {
        #[inline]
        pub unsafe fn issymmetric(&self) -> bool {
            FloatMatrix_issymmetric(self)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix {
            FloatMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix {
            FloatMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix {
            FloatMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(
            &mut self,
            a: *const root::FloatDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatMatrix {
            FloatMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatMatrix {
            FloatMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f32,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatMatrix {
            FloatMatrix_fill1(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix) -> root::FloatMatrix {
            FloatMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector) -> root::FloatMatrix {
            FloatMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(&self, a: *const root::FloatColumnVector) -> root::FloatMatrix {
            FloatMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix) -> root::FloatMatrix {
            FloatMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix) -> root::FloatMatrix {
            FloatMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector) -> root::FloatMatrix {
            FloatMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector) -> root::FloatMatrix {
            FloatMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix) -> root::FloatMatrix {
            FloatMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::FloatRowVector {
            FloatMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::FloatColumnVector {
            FloatMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatMatrix {
            FloatMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type) -> root::FloatMatrix {
            FloatMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatMatrix {
            FloatMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType) -> root::FloatMatrix {
            FloatMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatMatrix {
            FloatMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatMatrix {
            FloatMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type) -> root::FloatDET {
            FloatMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatDET {
            FloatMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatDET {
            FloatMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
        ) -> root::FloatMatrix {
            FloatMatrix_solve(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_solve1(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix {
            FloatMatrix_solve2(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatMatrix {
            FloatMatrix_solve3(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve4(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve5(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve6(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve7(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve8(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve9(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve10(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve11(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve12(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve13(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve14(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve15(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix) -> root::FloatMatrix {
            FloatMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix {
            FloatMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatMatrix {
            FloatMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(
            &self,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::FloatColumnVector) -> root::FloatColumnVector {
            FloatMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(
            &self,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix) -> root::FloatMatrix {
            FloatMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatMatrix {
            FloatMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(
            &self,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(
            &self,
            b: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector {
            FloatMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatColumnVector {
            FloatMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(
            &self,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::FloatMatrix {
            FloatMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::FloatMatrix {
            FloatMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::FloatMatrix {
            FloatMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::FloatMatrix {
            FloatMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::FloatMatrix {
            FloatMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::FloatMatrix {
            FloatMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatDiagMatrix {
            FloatMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatColumnVector {
            FloatMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatColumnVector {
            FloatMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatColumnVector {
            FloatMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatColumnVector {
            FloatMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatRowVector {
            FloatMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatRowVector {
            FloatMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatRowVector {
            FloatMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatRowVector {
            FloatMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix1(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix6(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatMatrix_FloatMatrix7(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexNDArray {
        pub _base: root::MArray<root::FloatComplex>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexNDArray() {
        assert_eq!(
            ::core::mem::size_of::<FloatComplexNDArray>(),
            40usize,
            concat!("Size of: ", stringify!(FloatComplexNDArray))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatComplexNDArray>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatComplexNDArray))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray18any_element_is_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_nan(
            this: *const root::FloatComplexNDArray,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray25any_element_is_inf_or_nanEv"]
        pub fn FloatComplexNDArray_any_element_is_inf_or_nan(
            this: *const root::FloatComplexNDArray,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray21all_elements_are_realEv"]
        pub fn FloatComplexNDArray_all_elements_are_real(
            this: *const root::FloatComplexNDArray,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray12all_integersERfS0_"]
        pub fn FloatComplexNDArray_all_integers(
            this: *const root::FloatComplexNDArray,
            max_val: *mut f32,
            min_val: *mut f32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray19too_large_for_floatEv"]
        pub fn FloatComplexNDArray_too_large_for_float(
            this: *const root::FloatComplexNDArray,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3allEi"]
        pub fn FloatComplexNDArray_all(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3anyEi"]
        pub fn FloatComplexNDArray_any(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray7cumprodEi"]
        pub fn FloatComplexNDArray_cumprod(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray6cumsumEi"]
        pub fn FloatComplexNDArray_cumsum(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray4prodEi"]
        pub fn FloatComplexNDArray_prod(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray5dprodEi"]
        pub fn FloatComplexNDArray_dprod(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3sumEi"]
        pub fn FloatComplexNDArray_sum(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray4dsumEi"]
        pub fn FloatComplexNDArray_dsum(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray5sumsqEi"]
        pub fn FloatComplexNDArray_sumsq(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray6concatERKS_RK5ArrayIlE"]
        pub fn FloatComplexNDArray_concat(
            this: *mut root::FloatComplexNDArray,
            rb: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray6concatERK12FloatNDArrayRK5ArrayIlE"]
        pub fn FloatComplexNDArray_concat1(
            this: *mut root::FloatComplexNDArray,
            rb: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3maxEi"]
        pub fn FloatComplexNDArray_max(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3maxER5ArrayIlEi"]
        pub fn FloatComplexNDArray_max1(
            this: *const root::FloatComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3minEi"]
        pub fn FloatComplexNDArray_min(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3minER5ArrayIlEi"]
        pub fn FloatComplexNDArray_min1(
            this: *const root::FloatComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray6cummaxEi"]
        pub fn FloatComplexNDArray_cummax(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray6cummaxER5ArrayIlEi"]
        pub fn FloatComplexNDArray_cummax1(
            this: *const root::FloatComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray6cumminEi"]
        pub fn FloatComplexNDArray_cummin(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray6cumminER5ArrayIlEi"]
        pub fn FloatComplexNDArray_cummin1(
            this: *const root::FloatComplexNDArray,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray4diffEli"]
        pub fn FloatComplexNDArray_diff(
            this: *const root::FloatComplexNDArray,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray6insertERK7NDArrayll"]
        pub fn FloatComplexNDArray_insert(
            this: *mut root::FloatComplexNDArray,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray6insertERKS_ll"]
        pub fn FloatComplexNDArray_insert1(
            this: *mut root::FloatComplexNDArray,
            a: *const root::FloatComplexNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray6insertERKS_RK5ArrayIlE"]
        pub fn FloatComplexNDArray_insert2(
            this: *mut root::FloatComplexNDArray,
            a: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray3absEv"]
        pub fn FloatComplexNDArray_abs(
            this: *const root::FloatComplexNDArray,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray5isnanEv"]
        pub fn FloatComplexNDArray_isnan(
            this: *const root::FloatComplexNDArray,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray5isinfEv"]
        pub fn FloatComplexNDArray_isinf(
            this: *const root::FloatComplexNDArray,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray8isfiniteEv"]
        pub fn FloatComplexNDArray_isfinite(
            this: *const root::FloatComplexNDArray,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray7fourierEi"]
        pub fn FloatComplexNDArray_fourier(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray8ifourierEi"]
        pub fn FloatComplexNDArray_ifourier(
            this: *const root::FloatComplexNDArray,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray9fourier2dEv"]
        pub fn FloatComplexNDArray_fourier2d(
            this: *const root::FloatComplexNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray10ifourier2dEv"]
        pub fn FloatComplexNDArray_ifourier2d(
            this: *const root::FloatComplexNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray9fourierNdEv"]
        pub fn FloatComplexNDArray_fourierNd(
            this: *const root::FloatComplexNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray10ifourierNdEv"]
        pub fn FloatComplexNDArray_ifourierNd(
            this: *const root::FloatComplexNDArray,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray15increment_indexER5ArrayIlERK10dim_vectori"]
        pub fn FloatComplexNDArray_increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArray13compute_indexER5ArrayIlERK10dim_vector"]
        pub fn FloatComplexNDArray_compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray4diagEl"]
        pub fn FloatComplexNDArray_diag(
            this: *const root::FloatComplexNDArray,
            k: root::octave_idx_type,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19FloatComplexNDArray4diagEll"]
        pub fn FloatComplexNDArray_diag1(
            this: *const root::FloatComplexNDArray,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19FloatComplexNDArrayC1ERK11charNDArray"]
        pub fn FloatComplexNDArray_FloatComplexNDArray(
            this: *mut root::FloatComplexNDArray,
            arg1: *const root::charNDArray,
        );
    }
    impl FloatComplexNDArray {
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            FloatComplexNDArray_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexNDArray_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f32, min_val: *mut f32) -> bool {
            FloatComplexNDArray_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            FloatComplexNDArray_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            FloatComplexNDArray_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolNDArray {
            FloatComplexNDArray_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_prod(self, dim)
        }
        #[inline]
        pub unsafe fn dprod(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            FloatComplexNDArray_dprod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_sum(self, dim)
        }
        #[inline]
        pub unsafe fn dsum(&self, dim: ::std::os::raw::c_int) -> root::ComplexNDArray {
            FloatComplexNDArray_dsum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::FloatNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummax(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax(self, dim)
        }
        #[inline]
        pub unsafe fn cummax1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummax1(self, index, dim)
        }
        #[inline]
        pub unsafe fn cummin(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin(self, dim)
        }
        #[inline]
        pub unsafe fn cummin1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_cummin1(self, index, dim)
        }
        #[inline]
        pub unsafe fn diff(
            &self,
            order: root::octave_idx_type,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_diff(self, order, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::NDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatComplexNDArray,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::FloatComplexNDArray,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::FloatComplexNDArray {
            FloatComplexNDArray_insert2(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatNDArray {
            FloatComplexNDArray_abs(self)
        }
        #[inline]
        pub unsafe fn isnan(&self) -> root::boolNDArray {
            FloatComplexNDArray_isnan(self)
        }
        #[inline]
        pub unsafe fn isinf(&self) -> root::boolNDArray {
            FloatComplexNDArray_isinf(self)
        }
        #[inline]
        pub unsafe fn isfinite(&self) -> root::boolNDArray {
            FloatComplexNDArray_isfinite(self)
        }
        #[inline]
        pub unsafe fn fourier(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier(self, dim)
        }
        #[inline]
        pub unsafe fn ifourier(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier(self, dim)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn fourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_fourierNd(self)
        }
        #[inline]
        pub unsafe fn ifourierNd(&self) -> root::FloatComplexNDArray {
            FloatComplexNDArray_ifourierNd(self)
        }
        #[inline]
        pub unsafe fn increment_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
            start_dimension: ::std::os::raw::c_int,
        ) {
            FloatComplexNDArray_increment_index(ra_idx, dimensions, start_dimension)
        }
        #[inline]
        pub unsafe fn compute_index(
            ra_idx: *mut root::Array<root::octave_idx_type>,
            dimensions: *const root::dim_vector,
        ) -> root::octave_idx_type {
            FloatComplexNDArray_compute_index(ra_idx, dimensions)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexNDArray {
            FloatComplexNDArray_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::charNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexNDArray_FloatComplexNDArray(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexMatrix {
        pub _base: root::FloatComplexNDArray,
    }
    pub type FloatComplexMatrix_column_vector_type = root::FloatComplexColumnVector;
    pub type FloatComplexMatrix_row_vector_type = root::FloatComplexRowVector;
    pub type FloatComplexMatrix_real_column_vector_type = root::FloatColumnVector;
    pub type FloatComplexMatrix_real_row_vector_type = root::FloatRowVector;
    pub type FloatComplexMatrix_real_matrix_type = root::FloatMatrix;
    pub type FloatComplexMatrix_complex_matrix_type = root::FloatComplexMatrix;
    pub type FloatComplexMatrix_real_diag_matrix_type = root::FloatDiagMatrix;
    pub type FloatComplexMatrix_complex_diag_matrix_type = root::FloatComplexDiagMatrix;
    pub type FloatComplexMatrix_real_elt_type = f32;
    pub type FloatComplexMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatComplexMatrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcon: f32)>;
    #[test]
    fn bindgen_test_layout_FloatComplexMatrix() {
        assert_eq!(
            ::core::mem::size_of::<FloatComplexMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(FloatComplexMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatComplexMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatComplexMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix11ishermitianEv"]
        pub fn FloatComplexMatrix_ishermitian(this: *const root::FloatComplexMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK11FloatMatrixll"]
        pub fn FloatComplexMatrix_insert(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK14FloatRowVectorll"]
        pub fn FloatComplexMatrix_insert1(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK17FloatColumnVectorll"]
        pub fn FloatComplexMatrix_insert2(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK15FloatDiagMatrixll"]
        pub fn FloatComplexMatrix_insert3(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERKS_ll"]
        pub fn FloatComplexMatrix_insert4(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK21FloatComplexRowVectorll"]
        pub fn FloatComplexMatrix_insert5(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatComplexRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK24FloatComplexColumnVectorll"]
        pub fn FloatComplexMatrix_insert6(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatComplexColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix6insertERK22FloatComplexDiagMatrixll"]
        pub fn FloatComplexMatrix_insert7(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatComplexDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix4fillEf"]
        pub fn FloatComplexMatrix_fill(
            this: *mut root::FloatComplexMatrix,
            val: f32,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexMatrix_fill1(
            this: *mut root::FloatComplexMatrix,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix4fillEfllll"]
        pub fn FloatComplexMatrix_fill2(
            this: *mut root::FloatComplexMatrix,
            val: f32,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrix4fillERKSt7complexIfEllll"]
        pub fn FloatComplexMatrix_fill3(
            this: *mut root::FloatComplexMatrix,
            val: *const root::FloatComplex,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK11FloatMatrix"]
        pub fn FloatComplexMatrix_append(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK14FloatRowVector"]
        pub fn FloatComplexMatrix_append1(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatRowVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_append2(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatColumnVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_append3(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatDiagMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERKS_"]
        pub fn FloatComplexMatrix_append4(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_append5(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_append6(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6appendERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_append7(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK11FloatMatrix"]
        pub fn FloatComplexMatrix_stack(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK14FloatRowVector"]
        pub fn FloatComplexMatrix_stack1(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatRowVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_stack2(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatColumnVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_stack3(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatDiagMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERKS_"]
        pub fn FloatComplexMatrix_stack4(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_stack5(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_stack6(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5stackERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_stack7(
            this: *const root::FloatComplexMatrix,
            a: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7extractEllll"]
        pub fn FloatComplexMatrix_extract(
            this: *const root::FloatComplexMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix9extract_nEllll"]
        pub fn FloatComplexMatrix_extract_n(
            this: *const root::FloatComplexMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix3rowEl"]
        pub fn FloatComplexMatrix_row(
            this: *const root::FloatComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6columnEl"]
        pub fn FloatComplexMatrix_column(
            this: *const root::FloatComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseEv"]
        pub fn FloatComplexMatrix_inverse(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseERl"]
        pub fn FloatComplexMatrix_inverse1(
            this: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseERlRfbb"]
        pub fn FloatComplexMatrix_inverse2(
            this: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseER10MatrixType"]
        pub fn FloatComplexMatrix_inverse3(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRl"]
        pub fn FloatComplexMatrix_inverse4(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7inverseER10MatrixTypeRlRfbb"]
        pub fn FloatComplexMatrix_inverse5(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix14pseudo_inverseEf"]
        pub fn FloatComplexMatrix_pseudo_inverse(
            this: *const root::FloatComplexMatrix,
            tol: f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7fourierEv"]
        pub fn FloatComplexMatrix_fourier(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix8ifourierEv"]
        pub fn FloatComplexMatrix_ifourier(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix9fourier2dEv"]
        pub fn FloatComplexMatrix_fourier2d(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix10ifourier2dEv"]
        pub fn FloatComplexMatrix_ifourier2d(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix11determinantEv"]
        pub fn FloatComplexMatrix_determinant(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix11determinantERl"]
        pub fn FloatComplexMatrix_determinant1(
            this: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix11determinantERlRfb"]
        pub fn FloatComplexMatrix_determinant2(
            this: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix11determinantER10MatrixTypeRlRfb"]
        pub fn FloatComplexMatrix_determinant3(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5rcondEv"]
        pub fn FloatComplexMatrix_rcond(this: *const root::FloatComplexMatrix) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5rcondER10MatrixType"]
        pub fn FloatComplexMatrix_rcond1(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
        ) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRl"]
        pub fn FloatComplexMatrix_solve1(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRlRf"]
        pub fn FloatComplexMatrix_solve2(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK11FloatMatrixRlRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve3(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn FloatComplexMatrix_solve4(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_Rl"]
        pub fn FloatComplexMatrix_solve5(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RlRf"]
        pub fn FloatComplexMatrix_solve6(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRKS_RlRfPFvfEb15blas_trans_type"]
        pub fn FloatComplexMatrix_solve7(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve8(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRl"]
        pub fn FloatComplexMatrix_solve9(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRlRf"]
        pub fn FloatComplexMatrix_solve10(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK17FloatColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve11(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve12(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRl"]
        pub fn FloatComplexMatrix_solve13(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRlRf"]
        pub fn FloatComplexMatrix_solve14(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveER10MatrixTypeRK24FloatComplexColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve15(
            this: *const root::FloatComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_solve16(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRl"]
        pub fn FloatComplexMatrix_solve17(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRlRf"]
        pub fn FloatComplexMatrix_solve18(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK11FloatMatrixRlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve19(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERKS_"]
        pub fn FloatComplexMatrix_solve20(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERKS_Rl"]
        pub fn FloatComplexMatrix_solve21(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERKS_RlRf"]
        pub fn FloatComplexMatrix_solve22(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERKS_RlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve23(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_solve24(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRl"]
        pub fn FloatComplexMatrix_solve25(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRlRf"]
        pub fn FloatComplexMatrix_solve26(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK17FloatColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve27(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_solve28(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRl"]
        pub fn FloatComplexMatrix_solve29(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRlRf"]
        pub fn FloatComplexMatrix_solve30(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5solveERK24FloatComplexColumnVectorRlRfPFvfE15blas_trans_type"]
        pub fn FloatComplexMatrix_solve31(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrix"]
        pub fn FloatComplexMatrix_lssolve(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRl"]
        pub fn FloatComplexMatrix_lssolve1(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRlS3_"]
        pub fn FloatComplexMatrix_lssolve2(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK11FloatMatrixRlS3_Rf"]
        pub fn FloatComplexMatrix_lssolve3(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERKS_"]
        pub fn FloatComplexMatrix_lssolve4(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERKS_Rl"]
        pub fn FloatComplexMatrix_lssolve5(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERKS_RlS2_"]
        pub fn FloatComplexMatrix_lssolve6(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERKS_RlS2_Rf"]
        pub fn FloatComplexMatrix_lssolve7(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_lssolve8(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRl"]
        pub fn FloatComplexMatrix_lssolve9(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRlS3_"]
        pub fn FloatComplexMatrix_lssolve10(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK17FloatColumnVectorRlS3_Rf"]
        pub fn FloatComplexMatrix_lssolve11(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_lssolve12(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRl"]
        pub fn FloatComplexMatrix_lssolve13(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRlS3_"]
        pub fn FloatComplexMatrix_lssolve14(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7lssolveERK24FloatComplexColumnVectorRlS3_Rf"]
        pub fn FloatComplexMatrix_lssolve15(
            this: *const root::FloatComplexMatrix,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix3allEi"]
        pub fn FloatComplexMatrix_all(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix3anyEi"]
        pub fn FloatComplexMatrix_any(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7cumprodEi"]
        pub fn FloatComplexMatrix_cumprod(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix6cumsumEi"]
        pub fn FloatComplexMatrix_cumsum(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix4prodEi"]
        pub fn FloatComplexMatrix_prod(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix3sumEi"]
        pub fn FloatComplexMatrix_sum(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix5sumsqEi"]
        pub fn FloatComplexMatrix_sumsq(
            this: *const root::FloatComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix3absEv"]
        pub fn FloatComplexMatrix_abs(this: *const root::FloatComplexMatrix) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix4diagEl"]
        pub fn FloatComplexMatrix_diag(
            this: *const root::FloatComplexMatrix,
            k: root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix4diagEll"]
        pub fn FloatComplexMatrix_diag1(
            this: *const root::FloatComplexMatrix,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix16row_is_real_onlyEl"]
        pub fn FloatComplexMatrix_row_is_real_only(
            this: *const root::FloatComplexMatrix,
            arg1: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix19column_is_real_onlyEl"]
        pub fn FloatComplexMatrix_column_is_real_only(
            this: *const root::FloatComplexMatrix,
            arg1: root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7row_minEv"]
        pub fn FloatComplexMatrix_row_min(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7row_maxEv"]
        pub fn FloatComplexMatrix_row_max(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7row_minER5ArrayIlE"]
        pub fn FloatComplexMatrix_row_min1(
            this: *const root::FloatComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix7row_maxER5ArrayIlE"]
        pub fn FloatComplexMatrix_row_max1(
            this: *const root::FloatComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix10column_minEv"]
        pub fn FloatComplexMatrix_column_min(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix10column_maxEv"]
        pub fn FloatComplexMatrix_column_max(
            this: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix10column_minER5ArrayIlE"]
        pub fn FloatComplexMatrix_column_min1(
            this: *const root::FloatComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18FloatComplexMatrix10column_maxER5ArrayIlE"]
        pub fn FloatComplexMatrix_column_max1(
            this: *const root::FloatComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK11FloatMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK14FloatRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix1(
            this: *mut root::FloatComplexMatrix,
            rv: *const root::FloatRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK17FloatColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix2(
            this: *mut root::FloatComplexMatrix,
            cv: *const root::FloatColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix3(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK11MDiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix4(
            this: *mut root::FloatComplexMatrix,
            a: *const root::MDiagArray2<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK10DiagArray2IfE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix5(
            this: *mut root::FloatComplexMatrix,
            a: *const root::DiagArray2<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK21FloatComplexRowVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix6(
            this: *mut root::FloatComplexMatrix,
            rv: *const root::FloatComplexRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK24FloatComplexColumnVector"]
        pub fn FloatComplexMatrix_FloatComplexMatrix7(
            this: *mut root::FloatComplexMatrix,
            cv: *const root::FloatComplexColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK22FloatComplexDiagMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix8(
            this: *mut root::FloatComplexMatrix,
            a: *const root::FloatComplexDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK11MDiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix9(
            this: *mut root::FloatComplexMatrix,
            a: *const root::MDiagArray2<root::FloatComplex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn FloatComplexMatrix_FloatComplexMatrix10(
            this: *mut root::FloatComplexMatrix,
            a: *const root::DiagArray2<root::FloatComplex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK10boolMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix11(
            this: *mut root::FloatComplexMatrix,
            a: *const root::boolMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK10charMatrix"]
        pub fn FloatComplexMatrix_FloatComplexMatrix12(
            this: *mut root::FloatComplexMatrix,
            a: *const root::charMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18FloatComplexMatrixC1ERK11FloatMatrixS2_"]
        pub fn FloatComplexMatrix_FloatComplexMatrix13(
            this: *mut root::FloatComplexMatrix,
            re: *const root::FloatMatrix,
            im: *const root::FloatMatrix,
        );
    }
    impl FloatComplexMatrix {
        #[inline]
        pub unsafe fn ishermitian(&self) -> bool {
            FloatComplexMatrix_ishermitian(self)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert2(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert3(
            &mut self,
            a: *const root::FloatDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert3(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert4(
            &mut self,
            a: *const root::FloatComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert4(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert5(
            &mut self,
            a: *const root::FloatComplexRowVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert5(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert6(
            &mut self,
            a: *const root::FloatComplexColumnVector,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert6(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert7(
            &mut self,
            a: *const root::FloatComplexDiagMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_insert7(self, a, r, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f32,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill2(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::FloatComplex,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexMatrix {
            FloatComplexMatrix_fill3(self, val, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::FloatRowVector) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append1(self, a)
        }
        #[inline]
        pub unsafe fn append2(
            &self,
            a: *const root::FloatColumnVector,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append2(self, a)
        }
        #[inline]
        pub unsafe fn append3(&self, a: *const root::FloatDiagMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append3(self, a)
        }
        #[inline]
        pub unsafe fn append4(
            &self,
            a: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append4(self, a)
        }
        #[inline]
        pub unsafe fn append5(
            &self,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append5(self, a)
        }
        #[inline]
        pub unsafe fn append6(
            &self,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append6(self, a)
        }
        #[inline]
        pub unsafe fn append7(
            &self,
            a: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_append7(self, a)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(&self, a: *const root::FloatRowVector) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack1(self, a)
        }
        #[inline]
        pub unsafe fn stack2(&self, a: *const root::FloatColumnVector) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack2(self, a)
        }
        #[inline]
        pub unsafe fn stack3(&self, a: *const root::FloatDiagMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack3(self, a)
        }
        #[inline]
        pub unsafe fn stack4(
            &self,
            a: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack4(self, a)
        }
        #[inline]
        pub unsafe fn stack5(
            &self,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack5(self, a)
        }
        #[inline]
        pub unsafe fn stack6(
            &self,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack6(self, a)
        }
        #[inline]
        pub unsafe fn stack7(
            &self,
            a: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_stack7(self, a)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            nr: root::octave_idx_type,
            nc: root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_extract_n(self, r1, c1, nr, nc)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::FloatComplexRowVector {
            FloatComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(
            &self,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse2(self, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn inverse3(&self, mattype: *mut root::MatrixType) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse3(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse4(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse4(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse5(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            force: bool,
            calc_cond: bool,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_inverse5(self, mattype, info, rcon, force, calc_cond)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatComplexMatrix {
            FloatComplexMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn fourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier(self)
        }
        #[inline]
        pub unsafe fn ifourier(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier(self)
        }
        #[inline]
        pub unsafe fn fourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_fourier2d(self)
        }
        #[inline]
        pub unsafe fn ifourier2d(&self) -> root::FloatComplexMatrix {
            FloatComplexMatrix_ifourier2d(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(
            &self,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant2(self, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            calc_cond: bool,
        ) -> root::FloatComplexDET {
            FloatComplexMatrix_determinant3(self, mattype, info, rcon, calc_cond)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatComplexMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn rcond1(&self, mattype: *mut root::MatrixType) -> f32 {
            FloatComplexMatrix_rcond1(self, mattype)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve1(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve2(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve3(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve4(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve5(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve6(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve7(
                self,
                mattype,
                b,
                info,
                rcon,
                sing_handler,
                singular_fallback,
                transt,
            )
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve8(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve9(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve10(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve11(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve12(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve13(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve14(self, mattype, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve15(self, mattype, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve16(&self, b: *const root::FloatMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve16(self, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve17(self, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve18(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve19(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve20(
            &self,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve20(self, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve21(self, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve22(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_solve23(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve24(
            &self,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve26(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve27(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn solve28(
            &self,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve30(self, b, info, rcon)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcon: *mut f32,
            sing_handler: root::FloatComplexMatrix_solve_singularity_handler,
            transt: root::blas_trans_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_solve31(self, b, info, rcon, sing_handler, transt)
        }
        #[inline]
        pub unsafe fn lssolve(&self, b: *const root::FloatMatrix) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve(self, b)
        }
        #[inline]
        pub unsafe fn lssolve1(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve1(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve2(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve2(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve3(
            &self,
            b: *const root::FloatMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve3(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve4(
            &self,
            b: *const root::FloatComplexMatrix,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve4(self, b)
        }
        #[inline]
        pub unsafe fn lssolve5(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve5(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve6(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve6(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve7(
            &self,
            b: *const root::FloatComplexMatrix,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexMatrix {
            FloatComplexMatrix_lssolve7(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve8(
            &self,
            b: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve8(self, b)
        }
        #[inline]
        pub unsafe fn lssolve9(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve9(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve10(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve10(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve11(
            &self,
            b: *const root::FloatColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve11(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn lssolve12(
            &self,
            b: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve12(self, b)
        }
        #[inline]
        pub unsafe fn lssolve13(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve13(self, b, info)
        }
        #[inline]
        pub unsafe fn lssolve14(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve14(self, b, info, rank)
        }
        #[inline]
        pub unsafe fn lssolve15(
            &self,
            b: *const root::FloatComplexColumnVector,
            info: *mut root::octave_idx_type,
            rank: *mut root::octave_idx_type,
            rcon: *mut f32,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_lssolve15(self, b, info, rank, rcon)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            FloatComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::boolMatrix {
            FloatComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexMatrix {
            FloatComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexMatrix {
            FloatComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexMatrix {
            FloatComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::FloatComplexMatrix {
            FloatComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatMatrix {
            FloatComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::FloatComplexMatrix {
            FloatComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexDiagMatrix {
            FloatComplexMatrix_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn row_is_real_only(&self, arg1: root::octave_idx_type) -> bool {
            FloatComplexMatrix_row_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn column_is_real_only(&self, arg1: root::octave_idx_type) -> bool {
            FloatComplexMatrix_column_is_real_only(self, arg1)
        }
        #[inline]
        pub unsafe fn row_min(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min(self)
        }
        #[inline]
        pub unsafe fn row_max(&self) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max(self)
        }
        #[inline]
        pub unsafe fn row_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_min1(self, index)
        }
        #[inline]
        pub unsafe fn row_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexColumnVector {
            FloatComplexMatrix_row_max1(self, index)
        }
        #[inline]
        pub unsafe fn column_min(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min(self)
        }
        #[inline]
        pub unsafe fn column_max(&self) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max(self)
        }
        #[inline]
        pub unsafe fn column_min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_min1(self, index)
        }
        #[inline]
        pub unsafe fn column_max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
        ) -> root::FloatComplexRowVector {
            FloatComplexMatrix_column_max1(self, index)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(rv: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix1(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(cv: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix2(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix3(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(a: *const root::MDiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix4(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(a: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix5(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(rv: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix6(&mut __bindgen_tmp, rv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(cv: *const root::FloatComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix7(&mut __bindgen_tmp, cv);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(a: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix8(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(a: *const root::MDiagArray2<root::FloatComplex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix9(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(a: *const root::DiagArray2<root::FloatComplex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix10(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::boolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix11(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(a: *const root::charMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix12(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(re: *const root::FloatMatrix, im: *const root::FloatMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexMatrix_FloatComplexMatrix13(&mut __bindgen_tmp, re, im);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ColumnVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_ColumnVector() {
        assert_eq!(
            ::core::mem::size_of::<ColumnVector>(),
            40usize,
            concat!("Size of: ", stringify!(ColumnVector))
        );
        assert_eq!(
            ::core::mem::align_of::<ColumnVector>(),
            8usize,
            concat!("Alignment of ", stringify!(ColumnVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12ColumnVector6insertERKS_l"]
        pub fn ColumnVector_insert(
            this: *mut root::ColumnVector,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12ColumnVector4fillEd"]
        pub fn ColumnVector_fill(
            this: *mut root::ColumnVector,
            val: f64,
        ) -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12ColumnVector4fillEdll"]
        pub fn ColumnVector_fill1(
            this: *mut root::ColumnVector,
            val: f64,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector5stackERKS_"]
        pub fn ColumnVector_stack(
            this: *const root::ColumnVector,
            a: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector9transposeEv"]
        pub fn ColumnVector_transpose(this: *const root::ColumnVector) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector7extractEll"]
        pub fn ColumnVector_extract(
            this: *const root::ColumnVector,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector9extract_nEll"]
        pub fn ColumnVector_extract_n(
            this: *const root::ColumnVector,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector3minEv"]
        pub fn ColumnVector_min(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector3maxEv"]
        pub fn ColumnVector_max(this: *const root::ColumnVector) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12ColumnVector3absEv"]
        pub fn ColumnVector_abs(this: *const root::ColumnVector) -> root::ColumnVector;
    }
    impl ColumnVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ColumnVector {
            ColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ColumnVector {
            ColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f64,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ColumnVector {
            ColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector) -> root::ColumnVector {
            ColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::RowVector {
            ColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::ColumnVector {
            ColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ColumnVector {
            ColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 {
            ColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> f64 {
            ColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexColumnVector {
        pub _base: root::MArray<root::Complex>,
    }
    #[test]
    fn bindgen_test_layout_ComplexColumnVector() {
        assert_eq!(
            ::core::mem::size_of::<ComplexColumnVector>(),
            40usize,
            concat!("Size of: ", stringify!(ComplexColumnVector))
        );
        assert_eq!(
            ::core::mem::align_of::<ComplexColumnVector>(),
            8usize,
            concat!("Alignment of ", stringify!(ComplexColumnVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector6insertERK12ColumnVectorl"]
        pub fn ComplexColumnVector_insert(
            this: *mut root::ComplexColumnVector,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector6insertERKS_l"]
        pub fn ComplexColumnVector_insert1(
            this: *mut root::ComplexColumnVector,
            a: *const root::ComplexColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector4fillEd"]
        pub fn ComplexColumnVector_fill(
            this: *mut root::ComplexColumnVector,
            val: f64,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector4fillERKSt7complexIdE"]
        pub fn ComplexColumnVector_fill1(
            this: *mut root::ComplexColumnVector,
            val: *const root::Complex,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector4fillEdll"]
        pub fn ComplexColumnVector_fill2(
            this: *mut root::ComplexColumnVector,
            val: f64,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVector4fillERKSt7complexIdEll"]
        pub fn ComplexColumnVector_fill3(
            this: *mut root::ComplexColumnVector,
            val: *const root::Complex,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector5stackERK12ColumnVector"]
        pub fn ComplexColumnVector_stack(
            this: *const root::ComplexColumnVector,
            a: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector5stackERKS_"]
        pub fn ComplexColumnVector_stack1(
            this: *const root::ComplexColumnVector,
            a: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector9hermitianEv"]
        pub fn ComplexColumnVector_hermitian(
            this: *const root::ComplexColumnVector,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector9transposeEv"]
        pub fn ComplexColumnVector_transpose(
            this: *const root::ComplexColumnVector,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector7extractEll"]
        pub fn ComplexColumnVector_extract(
            this: *const root::ComplexColumnVector,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector9extract_nEll"]
        pub fn ComplexColumnVector_extract_n(
            this: *const root::ComplexColumnVector,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector3minEv"]
        pub fn ComplexColumnVector_min(this: *const root::ComplexColumnVector) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector3maxEv"]
        pub fn ComplexColumnVector_max(this: *const root::ComplexColumnVector) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19ComplexColumnVector3absEv"]
        pub fn ComplexColumnVector_abs(
            this: *const root::ComplexColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19ComplexColumnVectorC1ERK12ColumnVector"]
        pub fn ComplexColumnVector_ComplexColumnVector(
            this: *mut root::ComplexColumnVector,
            a: *const root::ColumnVector,
        );
    }
    impl ComplexColumnVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::ColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::ComplexColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: *const root::Complex,
        ) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f64,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::Complex,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::ComplexColumnVector {
            ComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::ColumnVector) -> root::ComplexColumnVector {
            ComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(
            &self,
            a: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            ComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexRowVector {
            ComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexRowVector {
            ComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            ComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::ColumnVector {
            ComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexColumnVector_ComplexColumnVector(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatColumnVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatColumnVector() {
        assert_eq!(
            ::core::mem::size_of::<FloatColumnVector>(),
            40usize,
            concat!("Size of: ", stringify!(FloatColumnVector))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatColumnVector>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatColumnVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17FloatColumnVector6insertERKS_l"]
        pub fn FloatColumnVector_insert(
            this: *mut root::FloatColumnVector,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17FloatColumnVector4fillEf"]
        pub fn FloatColumnVector_fill(
            this: *mut root::FloatColumnVector,
            val: f32,
        ) -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17FloatColumnVector4fillEfll"]
        pub fn FloatColumnVector_fill1(
            this: *mut root::FloatColumnVector,
            val: f32,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector5stackERKS_"]
        pub fn FloatColumnVector_stack(
            this: *const root::FloatColumnVector,
            a: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector9transposeEv"]
        pub fn FloatColumnVector_transpose(
            this: *const root::FloatColumnVector,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector7extractEll"]
        pub fn FloatColumnVector_extract(
            this: *const root::FloatColumnVector,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector9extract_nEll"]
        pub fn FloatColumnVector_extract_n(
            this: *const root::FloatColumnVector,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector3minEv"]
        pub fn FloatColumnVector_min(this: *const root::FloatColumnVector) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector3maxEv"]
        pub fn FloatColumnVector_max(this: *const root::FloatColumnVector) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17FloatColumnVector3absEv"]
        pub fn FloatColumnVector_abs(
            this: *const root::FloatColumnVector,
        ) -> root::FloatColumnVector;
    }
    impl FloatColumnVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatColumnVector {
            FloatColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatColumnVector {
            FloatColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f32,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatColumnVector {
            FloatColumnVector_fill1(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(&self, a: *const root::FloatColumnVector) -> root::FloatColumnVector {
            FloatColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatRowVector {
            FloatColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatColumnVector {
            FloatColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 {
            FloatColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> f32 {
            FloatColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatColumnVector_abs(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexColumnVector {
        pub _base: root::MArray<root::FloatComplex>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexColumnVector() {
        assert_eq!(
            ::core::mem::size_of::<FloatComplexColumnVector>(),
            40usize,
            concat!("Size of: ", stringify!(FloatComplexColumnVector))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatComplexColumnVector>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatComplexColumnVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector6insertERK17FloatColumnVectorl"]
        pub fn FloatComplexColumnVector_insert(
            this: *mut root::FloatComplexColumnVector,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector6insertERKS_l"]
        pub fn FloatComplexColumnVector_insert1(
            this: *mut root::FloatComplexColumnVector,
            a: *const root::FloatComplexColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector4fillEf"]
        pub fn FloatComplexColumnVector_fill(
            this: *mut root::FloatComplexColumnVector,
            val: f32,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector4fillERKSt7complexIfE"]
        pub fn FloatComplexColumnVector_fill1(
            this: *mut root::FloatComplexColumnVector,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector4fillEfll"]
        pub fn FloatComplexColumnVector_fill2(
            this: *mut root::FloatComplexColumnVector,
            val: f32,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVector4fillERKSt7complexIfEll"]
        pub fn FloatComplexColumnVector_fill3(
            this: *mut root::FloatComplexColumnVector,
            val: *const root::FloatComplex,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector5stackERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_stack(
            this: *const root::FloatComplexColumnVector,
            a: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector5stackERKS_"]
        pub fn FloatComplexColumnVector_stack1(
            this: *const root::FloatComplexColumnVector,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector9hermitianEv"]
        pub fn FloatComplexColumnVector_hermitian(
            this: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector9transposeEv"]
        pub fn FloatComplexColumnVector_transpose(
            this: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector7extractEll"]
        pub fn FloatComplexColumnVector_extract(
            this: *const root::FloatComplexColumnVector,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector9extract_nEll"]
        pub fn FloatComplexColumnVector_extract_n(
            this: *const root::FloatComplexColumnVector,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector3minEv"]
        pub fn FloatComplexColumnVector_min(
            this: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector3maxEv"]
        pub fn FloatComplexColumnVector_max(
            this: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK24FloatComplexColumnVector3absEv"]
        pub fn FloatComplexColumnVector_abs(
            this: *const root::FloatComplexColumnVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN24FloatComplexColumnVectorC1ERK17FloatColumnVector"]
        pub fn FloatComplexColumnVector_FloatComplexColumnVector(
            this: *mut root::FloatComplexColumnVector,
            a: *const root::FloatColumnVector,
        );
    }
    impl FloatComplexColumnVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert(self, a, r)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatComplexColumnVector,
            r: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_insert1(self, a, r)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f32,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill2(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::FloatComplex,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> *mut root::FloatComplexColumnVector {
            FloatComplexColumnVector_fill3(self, val, r1, r2)
        }
        #[inline]
        pub unsafe fn stack(
            &self,
            a: *const root::FloatColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack(self, a)
        }
        #[inline]
        pub unsafe fn stack1(
            &self,
            a: *const root::FloatComplexColumnVector,
        ) -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_stack1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexRowVector {
            FloatComplexColumnVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            r2: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract(self, r1, r2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            r1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector {
            FloatComplexColumnVector_extract_n(self, r1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexColumnVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexColumnVector_max(self)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatColumnVector {
            FloatComplexColumnVector_abs(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexColumnVector_FloatComplexColumnVector(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RowVector {
        pub _base: root::MArray<f64>,
    }
    #[test]
    fn bindgen_test_layout_RowVector() {
        assert_eq!(
            ::core::mem::size_of::<RowVector>(),
            40usize,
            concat!("Size of: ", stringify!(RowVector))
        );
        assert_eq!(
            ::core::mem::align_of::<RowVector>(),
            8usize,
            concat!("Alignment of ", stringify!(RowVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN9RowVector6insertERKS_l"]
        pub fn RowVector_insert(
            this: *mut root::RowVector,
            a: *const root::RowVector,
            c: root::octave_idx_type,
        ) -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN9RowVector4fillEd"]
        pub fn RowVector_fill(this: *mut root::RowVector, val: f64) -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN9RowVector4fillEdll"]
        pub fn RowVector_fill1(
            this: *mut root::RowVector,
            val: f64,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector6appendERKS_"]
        pub fn RowVector_append(
            this: *const root::RowVector,
            a: *const root::RowVector,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector9transposeEv"]
        pub fn RowVector_transpose(this: *const root::RowVector) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector7extractEll"]
        pub fn RowVector_extract(
            this: *const root::RowVector,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector9extract_nEll"]
        pub fn RowVector_extract_n(
            this: *const root::RowVector,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector3minEv"]
        pub fn RowVector_min(this: *const root::RowVector) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK9RowVector3maxEv"]
        pub fn RowVector_max(this: *const root::RowVector) -> f64;
    }
    impl RowVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::RowVector,
            c: root::octave_idx_type,
        ) -> *mut root::RowVector {
            RowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::RowVector {
            RowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f64,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::RowVector {
            RowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector) -> root::RowVector {
            RowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ColumnVector {
            RowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::RowVector {
            RowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::RowVector {
            RowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 {
            RowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> f64 {
            RowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexRowVector {
        pub _base: root::MArray<root::Complex>,
    }
    #[test]
    fn bindgen_test_layout_ComplexRowVector() {
        assert_eq!(
            ::core::mem::size_of::<ComplexRowVector>(),
            40usize,
            concat!("Size of: ", stringify!(ComplexRowVector))
        );
        assert_eq!(
            ::core::mem::align_of::<ComplexRowVector>(),
            8usize,
            concat!("Alignment of ", stringify!(ComplexRowVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector6insertERK9RowVectorl"]
        pub fn ComplexRowVector_insert(
            this: *mut root::ComplexRowVector,
            a: *const root::RowVector,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector6insertERKS_l"]
        pub fn ComplexRowVector_insert1(
            this: *mut root::ComplexRowVector,
            a: *const root::ComplexRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector4fillEd"]
        pub fn ComplexRowVector_fill(
            this: *mut root::ComplexRowVector,
            val: f64,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector4fillERKSt7complexIdE"]
        pub fn ComplexRowVector_fill1(
            this: *mut root::ComplexRowVector,
            val: *const root::Complex,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector4fillEdll"]
        pub fn ComplexRowVector_fill2(
            this: *mut root::ComplexRowVector,
            val: f64,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16ComplexRowVector4fillERKSt7complexIdEll"]
        pub fn ComplexRowVector_fill3(
            this: *mut root::ComplexRowVector,
            val: *const root::Complex,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector6appendERK9RowVector"]
        pub fn ComplexRowVector_append(
            this: *const root::ComplexRowVector,
            a: *const root::RowVector,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector6appendERKS_"]
        pub fn ComplexRowVector_append1(
            this: *const root::ComplexRowVector,
            a: *const root::ComplexRowVector,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector9hermitianEv"]
        pub fn ComplexRowVector_hermitian(
            this: *const root::ComplexRowVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector9transposeEv"]
        pub fn ComplexRowVector_transpose(
            this: *const root::ComplexRowVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector7extractEll"]
        pub fn ComplexRowVector_extract(
            this: *const root::ComplexRowVector,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector9extract_nEll"]
        pub fn ComplexRowVector_extract_n(
            this: *const root::ComplexRowVector,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector3minEv"]
        pub fn ComplexRowVector_min(this: *const root::ComplexRowVector) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16ComplexRowVector3maxEv"]
        pub fn ComplexRowVector_max(this: *const root::ComplexRowVector) -> root::Complex;
    }
    impl ComplexRowVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::RowVector,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector {
            ComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::ComplexRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector {
            ComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexRowVector {
            ComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex) -> *mut root::ComplexRowVector {
            ComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f64,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector {
            ComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::Complex,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::ComplexRowVector {
            ComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::RowVector) -> root::ComplexRowVector {
            ComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(&self, a: *const root::ComplexRowVector) -> root::ComplexRowVector {
            ComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::ComplexColumnVector {
            ComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::ComplexColumnVector {
            ComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexRowVector {
            ComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::ComplexRowVector {
            ComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::Complex {
            ComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::Complex {
            ComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatRowVector {
        pub _base: root::MArray<f32>,
    }
    #[test]
    fn bindgen_test_layout_FloatRowVector() {
        assert_eq!(
            ::core::mem::size_of::<FloatRowVector>(),
            40usize,
            concat!("Size of: ", stringify!(FloatRowVector))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatRowVector>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatRowVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14FloatRowVector6insertERKS_l"]
        pub fn FloatRowVector_insert(
            this: *mut root::FloatRowVector,
            a: *const root::FloatRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14FloatRowVector4fillEf"]
        pub fn FloatRowVector_fill(
            this: *mut root::FloatRowVector,
            val: f32,
        ) -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14FloatRowVector4fillEfll"]
        pub fn FloatRowVector_fill1(
            this: *mut root::FloatRowVector,
            val: f32,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector6appendERKS_"]
        pub fn FloatRowVector_append(
            this: *const root::FloatRowVector,
            a: *const root::FloatRowVector,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector9transposeEv"]
        pub fn FloatRowVector_transpose(
            this: *const root::FloatRowVector,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector7extractEll"]
        pub fn FloatRowVector_extract(
            this: *const root::FloatRowVector,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector9extract_nEll"]
        pub fn FloatRowVector_extract_n(
            this: *const root::FloatRowVector,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector3minEv"]
        pub fn FloatRowVector_min(this: *const root::FloatRowVector) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14FloatRowVector3maxEv"]
        pub fn FloatRowVector_max(this: *const root::FloatRowVector) -> f32;
    }
    impl FloatRowVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatRowVector {
            FloatRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatRowVector {
            FloatRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f32,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatRowVector {
            FloatRowVector_fill1(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector) -> root::FloatRowVector {
            FloatRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatColumnVector {
            FloatRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatRowVector {
            FloatRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatRowVector {
            FloatRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> f32 {
            FloatRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> f32 {
            FloatRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexRowVector {
        pub _base: root::MArray<root::FloatComplex>,
    }
    #[test]
    fn bindgen_test_layout_FloatComplexRowVector() {
        assert_eq!(
            ::core::mem::size_of::<FloatComplexRowVector>(),
            40usize,
            concat!("Size of: ", stringify!(FloatComplexRowVector))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatComplexRowVector>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatComplexRowVector))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector6insertERK14FloatRowVectorl"]
        pub fn FloatComplexRowVector_insert(
            this: *mut root::FloatComplexRowVector,
            a: *const root::FloatRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector6insertERKS_l"]
        pub fn FloatComplexRowVector_insert1(
            this: *mut root::FloatComplexRowVector,
            a: *const root::FloatComplexRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector4fillEf"]
        pub fn FloatComplexRowVector_fill(
            this: *mut root::FloatComplexRowVector,
            val: f32,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector4fillERKSt7complexIfE"]
        pub fn FloatComplexRowVector_fill1(
            this: *mut root::FloatComplexRowVector,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector4fillEfll"]
        pub fn FloatComplexRowVector_fill2(
            this: *mut root::FloatComplexRowVector,
            val: f32,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21FloatComplexRowVector4fillERKSt7complexIfEll"]
        pub fn FloatComplexRowVector_fill3(
            this: *mut root::FloatComplexRowVector,
            val: *const root::FloatComplex,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector6appendERK14FloatRowVector"]
        pub fn FloatComplexRowVector_append(
            this: *const root::FloatComplexRowVector,
            a: *const root::FloatRowVector,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector6appendERKS_"]
        pub fn FloatComplexRowVector_append1(
            this: *const root::FloatComplexRowVector,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector9hermitianEv"]
        pub fn FloatComplexRowVector_hermitian(
            this: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector9transposeEv"]
        pub fn FloatComplexRowVector_transpose(
            this: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector7extractEll"]
        pub fn FloatComplexRowVector_extract(
            this: *const root::FloatComplexRowVector,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector9extract_nEll"]
        pub fn FloatComplexRowVector_extract_n(
            this: *const root::FloatComplexRowVector,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector3minEv"]
        pub fn FloatComplexRowVector_min(
            this: *const root::FloatComplexRowVector,
        ) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21FloatComplexRowVector3maxEv"]
        pub fn FloatComplexRowVector_max(
            this: *const root::FloatComplexRowVector,
        ) -> root::FloatComplex;
    }
    impl FloatComplexRowVector {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::FloatRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert(self, a, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::FloatComplexRowVector,
            c: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_insert1(self, a, c)
        }
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f32,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill2(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::FloatComplex,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> *mut root::FloatComplexRowVector {
            FloatComplexRowVector_fill3(self, val, c1, c2)
        }
        #[inline]
        pub unsafe fn append(&self, a: *const root::FloatRowVector) -> root::FloatComplexRowVector {
            FloatComplexRowVector_append(self, a)
        }
        #[inline]
        pub unsafe fn append1(
            &self,
            a: *const root::FloatComplexRowVector,
        ) -> root::FloatComplexRowVector {
            FloatComplexRowVector_append1(self, a)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_hermitian(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::FloatComplexColumnVector {
            FloatComplexRowVector_transpose(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            c1: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract(self, c1, c2)
        }
        #[inline]
        pub unsafe fn extract_n(
            &self,
            c1: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::FloatComplexRowVector {
            FloatComplexRowVector_extract_n(self, c1, n)
        }
        #[inline]
        pub unsafe fn min(&self) -> root::FloatComplex {
            FloatComplexRowVector_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> root::FloatComplex {
            FloatComplexRowVector_max(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct DiagMatrix {
        pub _base: root::MDiagArray2<f64>,
    }
    pub type DiagMatrix_full_matrix_type = root::Matrix;
    #[test]
    fn bindgen_test_layout_DiagMatrix() {
        assert_eq!(
            ::core::mem::size_of::<DiagMatrix>(),
            56usize,
            concat!("Size of: ", stringify!(DiagMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<DiagMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(DiagMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillEd"]
        pub fn DiagMatrix_fill(this: *mut root::DiagMatrix, val: f64) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillEdll"]
        pub fn DiagMatrix_fill1(
            this: *mut root::DiagMatrix,
            val: f64,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillERK12ColumnVector"]
        pub fn DiagMatrix_fill2(
            this: *mut root::DiagMatrix,
            a: *const root::ColumnVector,
        ) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillERK9RowVector"]
        pub fn DiagMatrix_fill3(
            this: *mut root::DiagMatrix,
            a: *const root::RowVector,
        ) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillERK12ColumnVectorl"]
        pub fn DiagMatrix_fill4(
            this: *mut root::DiagMatrix,
            a: *const root::ColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10DiagMatrix4fillERK9RowVectorl"]
        pub fn DiagMatrix_fill5(
            this: *mut root::DiagMatrix,
            a: *const root::RowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix3absEv"]
        pub fn DiagMatrix_abs(this: *const root::DiagMatrix) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix7extractEllll"]
        pub fn DiagMatrix_extract(
            this: *const root::DiagMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix3rowEl"]
        pub fn DiagMatrix_row(
            this: *const root::DiagMatrix,
            i: root::octave_idx_type,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix3rowEPc"]
        pub fn DiagMatrix_row1(
            this: *const root::DiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix6columnEl"]
        pub fn DiagMatrix_column(
            this: *const root::DiagMatrix,
            i: root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix6columnEPc"]
        pub fn DiagMatrix_column1(
            this: *const root::DiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix7inverseEv"]
        pub fn DiagMatrix_inverse(this: *const root::DiagMatrix) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix7inverseERl"]
        pub fn DiagMatrix_inverse1(
            this: *const root::DiagMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix14pseudo_inverseEd"]
        pub fn DiagMatrix_pseudo_inverse(
            this: *const root::DiagMatrix,
            tol: f64,
        ) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix11determinantEv"]
        pub fn DiagMatrix_determinant(this: *const root::DiagMatrix) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10DiagMatrix5rcondEv"]
        pub fn DiagMatrix_rcond(this: *const root::DiagMatrix) -> f64;
    }
    impl DiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::DiagMatrix {
            DiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f64,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::DiagMatrix {
            DiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(&mut self, a: *const root::ColumnVector) -> *mut root::DiagMatrix {
            DiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(&mut self, a: *const root::RowVector) -> *mut root::DiagMatrix {
            DiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(
            &mut self,
            a: *const root::ColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::DiagMatrix {
            DiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(
            &mut self,
            a: *const root::RowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::DiagMatrix {
            DiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix {
            DiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::Matrix {
            DiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::RowVector {
            DiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char) -> root::RowVector {
            DiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ColumnVector {
            DiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char) -> root::ColumnVector {
            DiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::DiagMatrix {
            DiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type) -> root::DiagMatrix {
            DiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::DiagMatrix {
            DiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            DiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 {
            DiagMatrix_rcond(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::Complex>,
    }
    pub type ComplexDiagMatrix_full_matrix_type = root::ComplexMatrix;
    pub type ComplexDiagMatrix_real_elt_type = f64;
    pub type ComplexDiagMatrix_complex_elt_type = root::Complex;
    pub type ComplexDiagMatrix_element_type = root::Complex;
    #[test]
    fn bindgen_test_layout_ComplexDiagMatrix() {
        assert_eq!(
            ::core::mem::size_of::<ComplexDiagMatrix>(),
            56usize,
            concat!("Size of: ", stringify!(ComplexDiagMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<ComplexDiagMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(ComplexDiagMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillEd"]
        pub fn ComplexDiagMatrix_fill(
            this: *mut root::ComplexDiagMatrix,
            val: f64,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERKSt7complexIdE"]
        pub fn ComplexDiagMatrix_fill1(
            this: *mut root::ComplexDiagMatrix,
            val: *const root::Complex,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillEdll"]
        pub fn ComplexDiagMatrix_fill2(
            this: *mut root::ComplexDiagMatrix,
            val: f64,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERKSt7complexIdEll"]
        pub fn ComplexDiagMatrix_fill3(
            this: *mut root::ComplexDiagMatrix,
            val: *const root::Complex,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK12ColumnVector"]
        pub fn ComplexDiagMatrix_fill4(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ColumnVector,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVector"]
        pub fn ComplexDiagMatrix_fill5(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ComplexColumnVector,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK9RowVector"]
        pub fn ComplexDiagMatrix_fill6(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::RowVector,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK16ComplexRowVector"]
        pub fn ComplexDiagMatrix_fill7(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ComplexRowVector,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK12ColumnVectorl"]
        pub fn ComplexDiagMatrix_fill8(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK19ComplexColumnVectorl"]
        pub fn ComplexDiagMatrix_fill9(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ComplexColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK9RowVectorl"]
        pub fn ComplexDiagMatrix_fill10(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::RowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrix4fillERK16ComplexRowVectorl"]
        pub fn ComplexDiagMatrix_fill11(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::ComplexRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix3absEv"]
        pub fn ComplexDiagMatrix_abs(this: *const root::ComplexDiagMatrix) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix7extractEllll"]
        pub fn ComplexDiagMatrix_extract(
            this: *const root::ComplexDiagMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix3rowEl"]
        pub fn ComplexDiagMatrix_row(
            this: *const root::ComplexDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix3rowEPc"]
        pub fn ComplexDiagMatrix_row1(
            this: *const root::ComplexDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix6columnEl"]
        pub fn ComplexDiagMatrix_column(
            this: *const root::ComplexDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix6columnEPc"]
        pub fn ComplexDiagMatrix_column1(
            this: *const root::ComplexDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix7inverseERl"]
        pub fn ComplexDiagMatrix_inverse(
            this: *const root::ComplexDiagMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix7inverseEv"]
        pub fn ComplexDiagMatrix_inverse1(
            this: *const root::ComplexDiagMatrix,
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix14pseudo_inverseEd"]
        pub fn ComplexDiagMatrix_pseudo_inverse(
            this: *const root::ComplexDiagMatrix,
            tol: f64,
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix21all_elements_are_realEv"]
        pub fn ComplexDiagMatrix_all_elements_are_real(
            this: *const root::ComplexDiagMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix11determinantEv"]
        pub fn ComplexDiagMatrix_determinant(
            this: *const root::ComplexDiagMatrix,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17ComplexDiagMatrix5rcondEv"]
        pub fn ComplexDiagMatrix_rcond(this: *const root::ComplexDiagMatrix) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17ComplexDiagMatrixC1ERK10DiagMatrix"]
        pub fn ComplexDiagMatrix_ComplexDiagMatrix(
            this: *mut root::ComplexDiagMatrix,
            a: *const root::DiagMatrix,
        );
    }
    impl ComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f64) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(&mut self, val: *const root::Complex) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f64,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::Complex,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(
            &mut self,
            a: *const root::ColumnVector,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(
            &mut self,
            a: *const root::ComplexColumnVector,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(&mut self, a: *const root::RowVector) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(
            &mut self,
            a: *const root::ComplexRowVector,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(
            &mut self,
            a: *const root::ColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(
            &mut self,
            a: *const root::ComplexColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(
            &mut self,
            a: *const root::RowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(
            &mut self,
            a: *const root::ComplexRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::ComplexDiagMatrix {
            ComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::DiagMatrix {
            ComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::ComplexMatrix {
            ComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::ComplexRowVector {
            ComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char) -> root::ComplexRowVector {
            ComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ComplexColumnVector {
            ComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char) -> root::ComplexColumnVector {
            ComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self, info: *mut root::octave_idx_type) -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f64) -> root::ComplexDiagMatrix {
            ComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            ComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            ComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f64 {
            ComplexDiagMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            ComplexDiagMatrix_ComplexDiagMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatDiagMatrix {
        pub _base: root::MDiagArray2<f32>,
    }
    pub type FloatDiagMatrix_full_matrix_type = root::FloatMatrix;
    #[test]
    fn bindgen_test_layout_FloatDiagMatrix() {
        assert_eq!(
            ::core::mem::size_of::<FloatDiagMatrix>(),
            56usize,
            concat!("Size of: ", stringify!(FloatDiagMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatDiagMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatDiagMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillEf"]
        pub fn FloatDiagMatrix_fill(
            this: *mut root::FloatDiagMatrix,
            val: f32,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillEfll"]
        pub fn FloatDiagMatrix_fill1(
            this: *mut root::FloatDiagMatrix,
            val: f32,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatDiagMatrix_fill2(
            this: *mut root::FloatDiagMatrix,
            a: *const root::FloatColumnVector,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatDiagMatrix_fill3(
            this: *mut root::FloatDiagMatrix,
            a: *const root::FloatRowVector,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillERK17FloatColumnVectorl"]
        pub fn FloatDiagMatrix_fill4(
            this: *mut root::FloatDiagMatrix,
            a: *const root::FloatColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15FloatDiagMatrix4fillERK14FloatRowVectorl"]
        pub fn FloatDiagMatrix_fill5(
            this: *mut root::FloatDiagMatrix,
            a: *const root::FloatRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix3absEv"]
        pub fn FloatDiagMatrix_abs(this: *const root::FloatDiagMatrix) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix7extractEllll"]
        pub fn FloatDiagMatrix_extract(
            this: *const root::FloatDiagMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix3rowEl"]
        pub fn FloatDiagMatrix_row(
            this: *const root::FloatDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix3rowEPc"]
        pub fn FloatDiagMatrix_row1(
            this: *const root::FloatDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix6columnEl"]
        pub fn FloatDiagMatrix_column(
            this: *const root::FloatDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix6columnEPc"]
        pub fn FloatDiagMatrix_column1(
            this: *const root::FloatDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix7inverseEv"]
        pub fn FloatDiagMatrix_inverse(this: *const root::FloatDiagMatrix)
            -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix7inverseERl"]
        pub fn FloatDiagMatrix_inverse1(
            this: *const root::FloatDiagMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix14pseudo_inverseEf"]
        pub fn FloatDiagMatrix_pseudo_inverse(
            this: *const root::FloatDiagMatrix,
            tol: f32,
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix11determinantEv"]
        pub fn FloatDiagMatrix_determinant(this: *const root::FloatDiagMatrix) -> root::FloatDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15FloatDiagMatrix5rcondEv"]
        pub fn FloatDiagMatrix_rcond(this: *const root::FloatDiagMatrix) -> f32;
    }
    impl FloatDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: f32,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill1(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            a: *const root::FloatColumnVector,
        ) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill2(self, a)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            a: *const root::FloatRowVector,
        ) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill3(self, a)
        }
        #[inline]
        pub unsafe fn fill4(
            &mut self,
            a: *const root::FloatColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill4(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill5(
            &mut self,
            a: *const root::FloatRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatDiagMatrix {
            FloatDiagMatrix_fill5(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatMatrix {
            FloatDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::FloatRowVector {
            FloatDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char) -> root::FloatRowVector {
            FloatDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::FloatColumnVector {
            FloatDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(&self, s: *mut ::std::os::raw::c_char) -> root::FloatColumnVector {
            FloatDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, info: *mut root::octave_idx_type) -> root::FloatDiagMatrix {
            FloatDiagMatrix_inverse1(self, info)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatDiagMatrix {
            FloatDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatDET {
            FloatDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatDiagMatrix_rcond(self)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct FloatComplexDiagMatrix {
        pub _base: root::MDiagArray2<root::FloatComplex>,
    }
    pub type FloatComplexDiagMatrix_full_matrix_type = root::FloatComplexMatrix;
    pub type FloatComplexDiagMatrix_real_elt_type = f32;
    pub type FloatComplexDiagMatrix_complex_elt_type = root::FloatComplex;
    pub type FloatComplexDiagMatrix_element_type = root::FloatComplex;
    #[test]
    fn bindgen_test_layout_FloatComplexDiagMatrix() {
        assert_eq!(
            ::core::mem::size_of::<FloatComplexDiagMatrix>(),
            56usize,
            concat!("Size of: ", stringify!(FloatComplexDiagMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<FloatComplexDiagMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(FloatComplexDiagMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillEf"]
        pub fn FloatComplexDiagMatrix_fill(
            this: *mut root::FloatComplexDiagMatrix,
            val: f32,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfE"]
        pub fn FloatComplexDiagMatrix_fill1(
            this: *mut root::FloatComplexDiagMatrix,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillEfll"]
        pub fn FloatComplexDiagMatrix_fill2(
            this: *mut root::FloatComplexDiagMatrix,
            val: f32,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERKSt7complexIfEll"]
        pub fn FloatComplexDiagMatrix_fill3(
            this: *mut root::FloatComplexDiagMatrix,
            val: *const root::FloatComplex,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVector"]
        pub fn FloatComplexDiagMatrix_fill4(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatColumnVector,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVector"]
        pub fn FloatComplexDiagMatrix_fill5(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatComplexColumnVector,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVector"]
        pub fn FloatComplexDiagMatrix_fill6(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatRowVector,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVector"]
        pub fn FloatComplexDiagMatrix_fill7(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatComplexRowVector,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK17FloatColumnVectorl"]
        pub fn FloatComplexDiagMatrix_fill8(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK24FloatComplexColumnVectorl"]
        pub fn FloatComplexDiagMatrix_fill9(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatComplexColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK14FloatRowVectorl"]
        pub fn FloatComplexDiagMatrix_fill10(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrix4fillERK21FloatComplexRowVectorl"]
        pub fn FloatComplexDiagMatrix_fill11(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatComplexRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix3absEv"]
        pub fn FloatComplexDiagMatrix_abs(
            this: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix7extractEllll"]
        pub fn FloatComplexDiagMatrix_extract(
            this: *const root::FloatComplexDiagMatrix,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix3rowEl"]
        pub fn FloatComplexDiagMatrix_row(
            this: *const root::FloatComplexDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix3rowEPc"]
        pub fn FloatComplexDiagMatrix_row1(
            this: *const root::FloatComplexDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix6columnEl"]
        pub fn FloatComplexDiagMatrix_column(
            this: *const root::FloatComplexDiagMatrix,
            i: root::octave_idx_type,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix6columnEPc"]
        pub fn FloatComplexDiagMatrix_column1(
            this: *const root::FloatComplexDiagMatrix,
            s: *mut ::std::os::raw::c_char,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix7inverseERl"]
        pub fn FloatComplexDiagMatrix_inverse(
            this: *const root::FloatComplexDiagMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix7inverseEv"]
        pub fn FloatComplexDiagMatrix_inverse1(
            this: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix14pseudo_inverseEf"]
        pub fn FloatComplexDiagMatrix_pseudo_inverse(
            this: *const root::FloatComplexDiagMatrix,
            tol: f32,
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix21all_elements_are_realEv"]
        pub fn FloatComplexDiagMatrix_all_elements_are_real(
            this: *const root::FloatComplexDiagMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix11determinantEv"]
        pub fn FloatComplexDiagMatrix_determinant(
            this: *const root::FloatComplexDiagMatrix,
        ) -> root::FloatComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22FloatComplexDiagMatrix5rcondEv"]
        pub fn FloatComplexDiagMatrix_rcond(this: *const root::FloatComplexDiagMatrix) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22FloatComplexDiagMatrixC1ERK15FloatDiagMatrix"]
        pub fn FloatComplexDiagMatrix_FloatComplexDiagMatrix(
            this: *mut root::FloatComplexDiagMatrix,
            a: *const root::FloatDiagMatrix,
        );
    }
    impl FloatComplexDiagMatrix {
        #[inline]
        pub unsafe fn fill(&mut self, val: f32) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill(self, val)
        }
        #[inline]
        pub unsafe fn fill1(
            &mut self,
            val: *const root::FloatComplex,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill1(self, val)
        }
        #[inline]
        pub unsafe fn fill2(
            &mut self,
            val: f32,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill2(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill3(
            &mut self,
            val: *const root::FloatComplex,
            beg: root::octave_idx_type,
            end: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill3(self, val, beg, end)
        }
        #[inline]
        pub unsafe fn fill4(
            &mut self,
            a: *const root::FloatColumnVector,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill4(self, a)
        }
        #[inline]
        pub unsafe fn fill5(
            &mut self,
            a: *const root::FloatComplexColumnVector,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill5(self, a)
        }
        #[inline]
        pub unsafe fn fill6(
            &mut self,
            a: *const root::FloatRowVector,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill6(self, a)
        }
        #[inline]
        pub unsafe fn fill7(
            &mut self,
            a: *const root::FloatComplexRowVector,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill7(self, a)
        }
        #[inline]
        pub unsafe fn fill8(
            &mut self,
            a: *const root::FloatColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill8(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill9(
            &mut self,
            a: *const root::FloatComplexColumnVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill9(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill10(
            &mut self,
            a: *const root::FloatRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill10(self, a, beg)
        }
        #[inline]
        pub unsafe fn fill11(
            &mut self,
            a: *const root::FloatComplexRowVector,
            beg: root::octave_idx_type,
        ) -> *mut root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_fill11(self, a, beg)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::FloatDiagMatrix {
            FloatComplexDiagMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn extract(
            &self,
            r1: root::octave_idx_type,
            c1: root::octave_idx_type,
            r2: root::octave_idx_type,
            c2: root::octave_idx_type,
        ) -> root::FloatComplexMatrix {
            FloatComplexDiagMatrix_extract(self, r1, c1, r2, c2)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn row1(&self, s: *mut ::std::os::raw::c_char) -> root::FloatComplexRowVector {
            FloatComplexDiagMatrix_row1(self, s)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn column1(
            &self,
            s: *mut ::std::os::raw::c_char,
        ) -> root::FloatComplexColumnVector {
            FloatComplexDiagMatrix_column1(self, s)
        }
        #[inline]
        pub unsafe fn inverse(
            &self,
            info: *mut root::octave_idx_type,
        ) -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse(self, info)
        }
        #[inline]
        pub unsafe fn inverse1(&self) -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_inverse1(self)
        }
        #[inline]
        pub unsafe fn pseudo_inverse(&self, tol: f32) -> root::FloatComplexDiagMatrix {
            FloatComplexDiagMatrix_pseudo_inverse(self, tol)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            FloatComplexDiagMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::FloatComplexDET {
            FloatComplexDiagMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn rcond(&self) -> f32 {
            FloatComplexDiagMatrix_rcond(self)
        }
        #[inline]
        pub unsafe fn new(a: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            FloatComplexDiagMatrix_FloatComplexDiagMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PermMatrix {
        pub _base: root::Array<root::octave_idx_type>,
    }
    #[test]
    fn bindgen_test_layout_PermMatrix() {
        assert_eq!(
            ::core::mem::size_of::<PermMatrix>(),
            40usize,
            concat!("Size of: ", stringify!(PermMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<PermMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(PermMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10PermMatrix9checkelemEll"]
        pub fn PermMatrix_checkelem(
            this: *const root::PermMatrix,
            i: root::octave_idx_type,
            j: root::octave_idx_type,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10PermMatrix9transposeEv"]
        pub fn PermMatrix_transpose(this: *const root::PermMatrix) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10PermMatrix7inverseEv"]
        pub fn PermMatrix_inverse(this: *const root::PermMatrix) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10PermMatrix11determinantEv"]
        pub fn PermMatrix_determinant(this: *const root::PermMatrix) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10PermMatrix5powerEl"]
        pub fn PermMatrix_power(
            this: *const root::PermMatrix,
            n: root::octave_idx_type,
        ) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10PermMatrix3eyeEl"]
        pub fn PermMatrix_eye(n: root::octave_idx_type) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10PermMatrixC1El"]
        pub fn PermMatrix_PermMatrix(this: *mut root::PermMatrix, n: root::octave_idx_type);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10PermMatrixC1ERK5ArrayIlEbb"]
        pub fn PermMatrix_PermMatrix1(
            this: *mut root::PermMatrix,
            p: *const root::Array<root::octave_idx_type>,
            colp: bool,
            check: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10PermMatrixC1ERK10idx_vectorbl"]
        pub fn PermMatrix_PermMatrix2(
            this: *mut root::PermMatrix,
            idx: *const root::idx_vector,
            colp: bool,
            n: root::octave_idx_type,
        );
    }
    impl PermMatrix {
        #[inline]
        pub unsafe fn checkelem(
            &self,
            i: root::octave_idx_type,
            j: root::octave_idx_type,
        ) -> root::octave_idx_type {
            PermMatrix_checkelem(self, i, j)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::PermMatrix {
            PermMatrix_transpose(self)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::PermMatrix {
            PermMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::octave_idx_type {
            PermMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn power(&self, n: root::octave_idx_type) -> root::PermMatrix {
            PermMatrix_power(self, n)
        }
        #[inline]
        pub unsafe fn eye(n: root::octave_idx_type) -> root::PermMatrix {
            PermMatrix_eye(n)
        }
        #[inline]
        pub unsafe fn new(n: root::octave_idx_type) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            PermMatrix_PermMatrix(&mut __bindgen_tmp, n);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            p: *const root::Array<root::octave_idx_type>,
            colp: bool,
            check: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            PermMatrix_PermMatrix1(&mut __bindgen_tmp, p, colp, check);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(
            idx: *const root::idx_vector,
            colp: bool,
            n: root::octave_idx_type,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            PermMatrix_PermMatrix2(&mut __bindgen_tmp, idx, colp, n);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseBoolMatrix {
        pub _base: root::Sparse<bool>,
    }
    pub type SparseBoolMatrix_dense_matrix_type = root::boolMatrix;
    #[test]
    fn bindgen_test_layout_SparseBoolMatrix() {
        assert_eq!(
            ::core::mem::size_of::<SparseBoolMatrix>(),
            24usize,
            concat!("Size of: ", stringify!(SparseBoolMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<SparseBoolMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(SparseBoolMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16SparseBoolMatrix6insertERKS_ll"]
        pub fn SparseBoolMatrix_insert(
            this: *mut root::SparseBoolMatrix,
            a: *const root::SparseBoolMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16SparseBoolMatrix6insertERKS_RK5ArrayIlE"]
        pub fn SparseBoolMatrix_insert1(
            this: *mut root::SparseBoolMatrix,
            a: *const root::SparseBoolMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16SparseBoolMatrix6concatERKS_RK5ArrayIlE"]
        pub fn SparseBoolMatrix_concat(
            this: *mut root::SparseBoolMatrix,
            rb: *const root::SparseBoolMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix4diagEl"]
        pub fn SparseBoolMatrix_diag(
            this: *const root::SparseBoolMatrix,
            k: root::octave_idx_type,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix12matrix_valueEv"]
        pub fn SparseBoolMatrix_matrix_value(
            this: *const root::SparseBoolMatrix,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix7squeezeEv"]
        pub fn SparseBoolMatrix_squeeze(
            this: *const root::SparseBoolMatrix,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix5indexERK10idx_vectorb"]
        pub fn SparseBoolMatrix_index(
            this: *const root::SparseBoolMatrix,
            i: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix5indexERK10idx_vectorS2_b"]
        pub fn SparseBoolMatrix_index1(
            this: *const root::SparseBoolMatrix,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix7reshapeERK10dim_vector"]
        pub fn SparseBoolMatrix_reshape(
            this: *const root::SparseBoolMatrix,
            new_dims: *const root::dim_vector,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix7permuteERK5ArrayIlEb"]
        pub fn SparseBoolMatrix_permute(
            this: *const root::SparseBoolMatrix,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix8ipermuteERK5ArrayIlE"]
        pub fn SparseBoolMatrix_ipermute(
            this: *const root::SparseBoolMatrix,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix3allEi"]
        pub fn SparseBoolMatrix_all(
            this: *const root::SparseBoolMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix3anyEi"]
        pub fn SparseBoolMatrix_any(
            this: *const root::SparseBoolMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16SparseBoolMatrix3sumEi"]
        pub fn SparseBoolMatrix_sum(
            this: *const root::SparseBoolMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    impl SparseBoolMatrix {
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::SparseBoolMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::SparseBoolMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseBoolMatrix {
            SparseBoolMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::SparseBoolMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseBoolMatrix {
            SparseBoolMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::SparseBoolMatrix {
            SparseBoolMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::boolMatrix {
            SparseBoolMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseBoolMatrix {
            SparseBoolMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn index(
            &self,
            i: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::SparseBoolMatrix {
            SparseBoolMatrix_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(
            &self,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::SparseBoolMatrix {
            SparseBoolMatrix_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector) -> root::SparseBoolMatrix {
            SparseBoolMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseBoolMatrix {
            SparseBoolMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseBoolMatrix {
            SparseBoolMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseBoolMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseBoolMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseBoolMatrix_sum(self, dim)
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseMatrix {
        pub _base: root::MSparse<f64>,
    }
    pub type SparseMatrix_dense_matrix_type = root::Matrix;
    pub type SparseMatrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseMatrix() {
        assert_eq!(
            ::core::mem::size_of::<SparseMatrix>(),
            24usize,
            concat!("Size of: ", stringify!(SparseMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<SparseMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(SparseMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix11issymmetricEv"]
        pub fn SparseMatrix_issymmetric(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3maxEi"]
        pub fn SparseMatrix_max(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3maxER5ArrayIlEi"]
        pub fn SparseMatrix_max1(
            this: *const root::SparseMatrix,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3minEi"]
        pub fn SparseMatrix_min(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3minER5ArrayIlEi"]
        pub fn SparseMatrix_min1(
            this: *const root::SparseMatrix,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrix6insertERKS_ll"]
        pub fn SparseMatrix_insert(
            this: *mut root::SparseMatrix,
            a: *const root::SparseMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrix6insertERKS_RK5ArrayIlE"]
        pub fn SparseMatrix_insert1(
            this: *mut root::SparseMatrix,
            a: *const root::SparseMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrix6concatERKS_RK5ArrayIlE"]
        pub fn SparseMatrix_concat(
            this: *mut root::SparseMatrix,
            rb: *const root::SparseMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrix6concatERK19SparseComplexMatrixRK5ArrayIlE"]
        pub fn SparseMatrix_concat1(
            this: *mut root::SparseMatrix,
            rb: *const root::SparseComplexMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3rowEl"]
        pub fn SparseMatrix_row(
            this: *const root::SparseMatrix,
            i: root::octave_idx_type,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix6columnEl"]
        pub fn SparseMatrix_column(
            this: *const root::SparseMatrix,
            i: root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7inverseEv"]
        pub fn SparseMatrix_inverse(this: *const root::SparseMatrix) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7inverseER10MatrixType"]
        pub fn SparseMatrix_inverse1(
            this: *const root::SparseMatrix,
            mattype: *mut root::MatrixType,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7inverseER10MatrixTypeRl"]
        pub fn SparseMatrix_inverse2(
            this: *const root::SparseMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7inverseER10MatrixTypeRlRdbb"]
        pub fn SparseMatrix_inverse3(
            this: *const root::SparseMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix11determinantEv"]
        pub fn SparseMatrix_determinant(this: *const root::SparseMatrix) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix11determinantERl"]
        pub fn SparseMatrix_determinant1(
            this: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix11determinantERlRdb"]
        pub fn SparseMatrix_determinant2(
            this: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            calc_cond: bool,
        ) -> root::DET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseMatrix_solve(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRl"]
        pub fn SparseMatrix_solve1(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRlRd"]
        pub fn SparseMatrix_solve2(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK6MatrixRlRdPFvdEb"]
        pub fn SparseMatrix_solve3(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseMatrix_solve4(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRl"]
        pub fn SparseMatrix_solve5(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRlRd"]
        pub fn SparseMatrix_solve6(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK13ComplexMatrixRlRdPFvdEb"]
        pub fn SparseMatrix_solve7(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseMatrix_solve8(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRKS_Rl"]
        pub fn SparseMatrix_solve9(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RlRd"]
        pub fn SparseMatrix_solve10(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRKS_RlRdPFvdEb"]
        pub fn SparseMatrix_solve11(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve12(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRl"]
        pub fn SparseMatrix_solve13(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRlRd"]
        pub fn SparseMatrix_solve14(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19SparseComplexMatrixRlRdPFvdEb"]
        pub fn SparseMatrix_solve15(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallabck: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseMatrix_solve16(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRl"]
        pub fn SparseMatrix_solve17(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRlRd"]
        pub fn SparseMatrix_solve18(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK12ColumnVectorRlRdPFvdE"]
        pub fn SparseMatrix_solve19(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseMatrix_solve20(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRl"]
        pub fn SparseMatrix_solve21(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRd"]
        pub fn SparseMatrix_solve22(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRdPFvdE"]
        pub fn SparseMatrix_solve23(
            this: *const root::SparseMatrix,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK6Matrix"]
        pub fn SparseMatrix_solve24(
            this: *const root::SparseMatrix,
            b: *const root::Matrix,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK6MatrixRl"]
        pub fn SparseMatrix_solve25(
            this: *const root::SparseMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK6MatrixRlRd"]
        pub fn SparseMatrix_solve26(
            this: *const root::SparseMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK6MatrixRlRdPFvdE"]
        pub fn SparseMatrix_solve27(
            this: *const root::SparseMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK13ComplexMatrix"]
        pub fn SparseMatrix_solve28(
            this: *const root::SparseMatrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK13ComplexMatrixRl"]
        pub fn SparseMatrix_solve29(
            this: *const root::SparseMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK13ComplexMatrixRlRd"]
        pub fn SparseMatrix_solve30(
            this: *const root::SparseMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK13ComplexMatrixRlRdPFvdE"]
        pub fn SparseMatrix_solve31(
            this: *const root::SparseMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERKS_"]
        pub fn SparseMatrix_solve32(
            this: *const root::SparseMatrix,
            b: *const root::SparseMatrix,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERKS_Rl"]
        pub fn SparseMatrix_solve33(
            this: *const root::SparseMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERKS_RlRd"]
        pub fn SparseMatrix_solve34(
            this: *const root::SparseMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERKS_RlRdPFvdE"]
        pub fn SparseMatrix_solve35(
            this: *const root::SparseMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19SparseComplexMatrix"]
        pub fn SparseMatrix_solve36(
            this: *const root::SparseMatrix,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRl"]
        pub fn SparseMatrix_solve37(
            this: *const root::SparseMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRlRd"]
        pub fn SparseMatrix_solve38(
            this: *const root::SparseMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19SparseComplexMatrixRlRdPFvdE"]
        pub fn SparseMatrix_solve39(
            this: *const root::SparseMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK12ColumnVector"]
        pub fn SparseMatrix_solve40(
            this: *const root::SparseMatrix,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK12ColumnVectorRl"]
        pub fn SparseMatrix_solve41(
            this: *const root::SparseMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK12ColumnVectorRlRd"]
        pub fn SparseMatrix_solve42(
            this: *const root::SparseMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK12ColumnVectorRlRdPFvdE"]
        pub fn SparseMatrix_solve43(
            this: *const root::SparseMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseMatrix_solve44(
            this: *const root::SparseMatrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRl"]
        pub fn SparseMatrix_solve45(
            this: *const root::SparseMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRlRd"]
        pub fn SparseMatrix_solve46(
            this: *const root::SparseMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5solveERK19ComplexColumnVectorRlRdPFvdE"]
        pub fn SparseMatrix_solve47(
            this: *const root::SparseMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix23any_element_is_negativeEb"]
        pub fn SparseMatrix_any_element_is_negative(
            this: *const root::SparseMatrix,
            arg1: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix18any_element_is_nanEv"]
        pub fn SparseMatrix_any_element_is_nan(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseMatrix_any_element_is_inf_or_nan(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix27any_element_not_one_or_zeroEv"]
        pub fn SparseMatrix_any_element_not_one_or_zero(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix21all_elements_are_zeroEv"]
        pub fn SparseMatrix_all_elements_are_zero(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix34all_elements_are_int_or_inf_or_nanEv"]
        pub fn SparseMatrix_all_elements_are_int_or_inf_or_nan(
            this: *const root::SparseMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix12all_integersERdS0_"]
        pub fn SparseMatrix_all_integers(
            this: *const root::SparseMatrix,
            max_val: *mut f64,
            min_val: *mut f64,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix19too_large_for_floatEv"]
        pub fn SparseMatrix_too_large_for_float(this: *const root::SparseMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3allEi"]
        pub fn SparseMatrix_all(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3anyEi"]
        pub fn SparseMatrix_any(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7cumprodEi"]
        pub fn SparseMatrix_cumprod(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix6cumsumEi"]
        pub fn SparseMatrix_cumsum(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix4prodEi"]
        pub fn SparseMatrix_prod(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3sumEi"]
        pub fn SparseMatrix_sum(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix5sumsqEi"]
        pub fn SparseMatrix_sumsq(
            this: *const root::SparseMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix3absEv"]
        pub fn SparseMatrix_abs(this: *const root::SparseMatrix) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix4diagEl"]
        pub fn SparseMatrix_diag(
            this: *const root::SparseMatrix,
            k: root::octave_idx_type,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix12matrix_valueEv"]
        pub fn SparseMatrix_matrix_value(this: *const root::SparseMatrix) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7squeezeEv"]
        pub fn SparseMatrix_squeeze(this: *const root::SparseMatrix) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7reshapeERK10dim_vector"]
        pub fn SparseMatrix_reshape(
            this: *const root::SparseMatrix,
            new_dims: *const root::dim_vector,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix7permuteERK5ArrayIlEb"]
        pub fn SparseMatrix_permute(
            this: *const root::SparseMatrix,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12SparseMatrix8ipermuteERK5ArrayIlE"]
        pub fn SparseMatrix_ipermute(
            this: *const root::SparseMatrix,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseMatrix_SparseMatrix(
            this: *mut root::SparseMatrix,
            a: *const root::SparseBoolMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12SparseMatrixC1ERK10DiagMatrix"]
        pub fn SparseMatrix_SparseMatrix1(
            this: *mut root::SparseMatrix,
            a: *const root::DiagMatrix,
        );
    }
    impl SparseMatrix {
        #[inline]
        pub unsafe fn issymmetric(&self) -> bool {
            SparseMatrix_issymmetric(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix {
            SparseMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseMatrix {
            SparseMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::SparseMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseMatrix {
            SparseMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::SparseMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseMatrix {
            SparseMatrix_insert1(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::SparseMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseMatrix {
            SparseMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::SparseComplexMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::RowVector {
            SparseMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ColumnVector {
            SparseMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseMatrix {
            SparseMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType) -> root::SparseMatrix {
            SparseMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix {
            SparseMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::SparseMatrix {
            SparseMatrix_inverse3(self, mattype, info, rcond, force, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::DET {
            SparseMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type) -> root::DET {
            SparseMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            calc_cond: bool,
        ) -> root::DET {
            SparseMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::Matrix {
            SparseMatrix_solve(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            SparseMatrix_solve1(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::Matrix {
            SparseMatrix_solve2(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::Matrix {
            SparseMatrix_solve3(self, typ, b, info, rcond, sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve4(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve5(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve6(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve7(self, typ, b, info, rcond, sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
        ) -> root::SparseMatrix {
            SparseMatrix_solve8(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix {
            SparseMatrix_solve9(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseMatrix {
            SparseMatrix_solve10(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseMatrix {
            SparseMatrix_solve11(self, typ, b, info, rcond, sing_handler, singular_fallback)
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve12(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve13(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve14(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
            singular_fallabck: bool,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve15(self, typ, b, info, rcond, sing_handler, singular_fallabck)
        }
        #[inline]
        pub unsafe fn solve16(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ColumnVector {
            SparseMatrix_solve16(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            SparseMatrix_solve17(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ColumnVector {
            SparseMatrix_solve18(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ColumnVector {
            SparseMatrix_solve19(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve20(self, typ, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve21(self, typ, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve22(self, typ, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            typ: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve23(self, typ, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix) -> root::Matrix {
            SparseMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::Matrix {
            SparseMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::Matrix {
            SparseMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::Matrix {
            SparseMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            SparseMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix {
            SparseMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix) -> root::SparseMatrix {
            SparseMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseMatrix {
            SparseMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseMatrix {
            SparseMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::SparseMatrix {
            SparseMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(
            &self,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix {
            SparseMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector) -> root::ColumnVector {
            SparseMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ColumnVector {
            SparseMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ColumnVector {
            SparseMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ColumnVector {
            SparseMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn any_element_is_negative(&self, arg1: bool) -> bool {
            SparseMatrix_any_element_is_negative(self, arg1)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_not_one_or_zero(&self) -> bool {
            SparseMatrix_any_element_not_one_or_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_zero(&self) -> bool {
            SparseMatrix_all_elements_are_zero(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_int_or_inf_or_nan(&self) -> bool {
            SparseMatrix_all_elements_are_int_or_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64) -> bool {
            SparseMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::SparseMatrix {
            SparseMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::SparseMatrix {
            SparseMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            SparseMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseMatrix {
            SparseMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, new_dims: *const root::dim_vector) -> root::SparseMatrix {
            SparseMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseMatrix {
            SparseMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseMatrix {
            SparseMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            SparseMatrix_SparseMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            SparseMatrix_SparseMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct SparseComplexMatrix {
        pub _base: root::MSparse<root::Complex>,
    }
    pub type SparseComplexMatrix_dense_matrix_type = root::ComplexMatrix;
    pub type SparseComplexMatrix_solve_singularity_handler =
        ::core::option::Option<unsafe extern "C" fn(rcond: f64)>;
    #[test]
    fn bindgen_test_layout_SparseComplexMatrix() {
        assert_eq!(
            ::core::mem::size_of::<SparseComplexMatrix>(),
            24usize,
            concat!("Size of: ", stringify!(SparseComplexMatrix))
        );
        assert_eq!(
            ::core::mem::align_of::<SparseComplexMatrix>(),
            8usize,
            concat!("Alignment of ", stringify!(SparseComplexMatrix))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix11ishermitianEv"]
        pub fn SparseComplexMatrix_ishermitian(this: *const root::SparseComplexMatrix) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3maxEi"]
        pub fn SparseComplexMatrix_max(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3maxER5ArrayIlEi"]
        pub fn SparseComplexMatrix_max1(
            this: *const root::SparseComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3minEi"]
        pub fn SparseComplexMatrix_min(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3minER5ArrayIlEi"]
        pub fn SparseComplexMatrix_min1(
            this: *const root::SparseComplexMatrix,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6insertERKS_ll"]
        pub fn SparseComplexMatrix_insert(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6insertERK12SparseMatrixll"]
        pub fn SparseComplexMatrix_insert1(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6insertERKS_RK5ArrayIlE"]
        pub fn SparseComplexMatrix_insert2(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseComplexMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6insertERK12SparseMatrixRK5ArrayIlE"]
        pub fn SparseComplexMatrix_insert3(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6concatERKS_RK5ArrayIlE"]
        pub fn SparseComplexMatrix_concat(
            this: *mut root::SparseComplexMatrix,
            rb: *const root::SparseComplexMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrix6concatERK12SparseMatrixRK5ArrayIlE"]
        pub fn SparseComplexMatrix_concat1(
            this: *mut root::SparseComplexMatrix,
            rb: *const root::SparseMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix12matrix_valueEv"]
        pub fn SparseComplexMatrix_matrix_value(
            this: *const root::SparseComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix9hermitianEv"]
        pub fn SparseComplexMatrix_hermitian(
            this: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3rowEl"]
        pub fn SparseComplexMatrix_row(
            this: *const root::SparseComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix6columnEl"]
        pub fn SparseComplexMatrix_column(
            this: *const root::SparseComplexMatrix,
            i: root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7inverseEv"]
        pub fn SparseComplexMatrix_inverse(
            this: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7inverseER10MatrixType"]
        pub fn SparseComplexMatrix_inverse1(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRl"]
        pub fn SparseComplexMatrix_inverse2(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7inverseER10MatrixTypeRlRdbb"]
        pub fn SparseComplexMatrix_inverse3(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix11determinantEv"]
        pub fn SparseComplexMatrix_determinant(
            this: *const root::SparseComplexMatrix,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix11determinantERl"]
        pub fn SparseComplexMatrix_determinant1(
            this: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix11determinantERlRdb"]
        pub fn SparseComplexMatrix_determinant2(
            this: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6Matrix"]
        pub fn SparseComplexMatrix_solve(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRl"]
        pub fn SparseComplexMatrix_solve1(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRlRd"]
        pub fn SparseComplexMatrix_solve2(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK6MatrixRlRdPFvdEb"]
        pub fn SparseComplexMatrix_solve3(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve4(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRl"]
        pub fn SparseComplexMatrix_solve5(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRlRd"]
        pub fn SparseComplexMatrix_solve6(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK13ComplexMatrixRlRdPFvdEb"]
        pub fn SparseComplexMatrix_solve7(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve8(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRl"]
        pub fn SparseComplexMatrix_solve9(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRlRd"]
        pub fn SparseComplexMatrix_solve10(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12SparseMatrixRlRdPFvdEb"]
        pub fn SparseComplexMatrix_solve11(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_"]
        pub fn SparseComplexMatrix_solve12(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_Rl"]
        pub fn SparseComplexMatrix_solve13(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RlRd"]
        pub fn SparseComplexMatrix_solve14(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRKS_RlRdPFvdEb"]
        pub fn SparseComplexMatrix_solve15(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVector"]
        pub fn SparseComplexMatrix_solve16(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRl"]
        pub fn SparseComplexMatrix_solve17(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRlRd"]
        pub fn SparseComplexMatrix_solve18(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK12ColumnVectorRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve19(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve20(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRl"]
        pub fn SparseComplexMatrix_solve21(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRd"]
        pub fn SparseComplexMatrix_solve22(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveER10MatrixTypeRK19ComplexColumnVectorRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve23(
            this: *const root::SparseComplexMatrix,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK6Matrix"]
        pub fn SparseComplexMatrix_solve24(
            this: *const root::SparseComplexMatrix,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK6MatrixRl"]
        pub fn SparseComplexMatrix_solve25(
            this: *const root::SparseComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK6MatrixRlRd"]
        pub fn SparseComplexMatrix_solve26(
            this: *const root::SparseComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK6MatrixRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve27(
            this: *const root::SparseComplexMatrix,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK13ComplexMatrix"]
        pub fn SparseComplexMatrix_solve28(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRl"]
        pub fn SparseComplexMatrix_solve29(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRlRd"]
        pub fn SparseComplexMatrix_solve30(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK13ComplexMatrixRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve31(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12SparseMatrix"]
        pub fn SparseComplexMatrix_solve32(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRl"]
        pub fn SparseComplexMatrix_solve33(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRlRd"]
        pub fn SparseComplexMatrix_solve34(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12SparseMatrixRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve35(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERKS_"]
        pub fn SparseComplexMatrix_solve36(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERKS_Rl"]
        pub fn SparseComplexMatrix_solve37(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERKS_RlRd"]
        pub fn SparseComplexMatrix_solve38(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERKS_RlRdPFvdE"]
        pub fn SparseComplexMatrix_solve39(
            this: *const root::SparseComplexMatrix,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12ColumnVector"]
        pub fn SparseComplexMatrix_solve40(
            this: *const root::SparseComplexMatrix,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRl"]
        pub fn SparseComplexMatrix_solve41(
            this: *const root::SparseComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRlRd"]
        pub fn SparseComplexMatrix_solve42(
            this: *const root::SparseComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK12ColumnVectorRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve43(
            this: *const root::SparseComplexMatrix,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVector"]
        pub fn SparseComplexMatrix_solve44(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRl"]
        pub fn SparseComplexMatrix_solve45(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRlRd"]
        pub fn SparseComplexMatrix_solve46(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5solveERK19ComplexColumnVectorRlRdPFvdE"]
        pub fn SparseComplexMatrix_solve47(
            this: *const root::SparseComplexMatrix,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7squeezeEv"]
        pub fn SparseComplexMatrix_squeeze(
            this: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7reshapeERK10dim_vector"]
        pub fn SparseComplexMatrix_reshape(
            this: *const root::SparseComplexMatrix,
            new_dims: *const root::dim_vector,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7permuteERK5ArrayIlEb"]
        pub fn SparseComplexMatrix_permute(
            this: *const root::SparseComplexMatrix,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix8ipermuteERK5ArrayIlE"]
        pub fn SparseComplexMatrix_ipermute(
            this: *const root::SparseComplexMatrix,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix18any_element_is_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_nan(
            this: *const root::SparseComplexMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix25any_element_is_inf_or_nanEv"]
        pub fn SparseComplexMatrix_any_element_is_inf_or_nan(
            this: *const root::SparseComplexMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix21all_elements_are_realEv"]
        pub fn SparseComplexMatrix_all_elements_are_real(
            this: *const root::SparseComplexMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix12all_integersERdS0_"]
        pub fn SparseComplexMatrix_all_integers(
            this: *const root::SparseComplexMatrix,
            max_val: *mut f64,
            min_val: *mut f64,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix19too_large_for_floatEv"]
        pub fn SparseComplexMatrix_too_large_for_float(
            this: *const root::SparseComplexMatrix,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3allEi"]
        pub fn SparseComplexMatrix_all(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3anyEi"]
        pub fn SparseComplexMatrix_any(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix7cumprodEi"]
        pub fn SparseComplexMatrix_cumprod(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix6cumsumEi"]
        pub fn SparseComplexMatrix_cumsum(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix4prodEi"]
        pub fn SparseComplexMatrix_prod(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3sumEi"]
        pub fn SparseComplexMatrix_sum(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix5sumsqEi"]
        pub fn SparseComplexMatrix_sumsq(
            this: *const root::SparseComplexMatrix,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix3absEv"]
        pub fn SparseComplexMatrix_abs(
            this: *const root::SparseComplexMatrix,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19SparseComplexMatrix4diagEl"]
        pub fn SparseComplexMatrix_diag(
            this: *const root::SparseComplexMatrix,
            k: root::octave_idx_type,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrixC1ERK12SparseMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrixC1ERK16SparseBoolMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix1(
            this: *mut root::SparseComplexMatrix,
            a: *const root::SparseBoolMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19SparseComplexMatrixC1ERK17ComplexDiagMatrix"]
        pub fn SparseComplexMatrix_SparseComplexMatrix2(
            this: *mut root::SparseComplexMatrix,
            a: *const root::ComplexDiagMatrix,
        );
    }
    impl SparseComplexMatrix {
        #[inline]
        pub unsafe fn ishermitian(&self) -> bool {
            SparseComplexMatrix_ishermitian(self)
        }
        #[inline]
        pub unsafe fn max(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_max(self, dim)
        }
        #[inline]
        pub unsafe fn max1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_max1(self, index, dim)
        }
        #[inline]
        pub unsafe fn min(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_min(self, dim)
        }
        #[inline]
        pub unsafe fn min1(
            &self,
            index: *mut root::Array<root::octave_idx_type>,
            dim: ::std::os::raw::c_int,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_min1(self, index, dim)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::SparseComplexMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::SparseMatrix,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert1(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert2(
            &mut self,
            a: *const root::SparseComplexMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert2(self, a, indx)
        }
        #[inline]
        pub unsafe fn insert3(
            &mut self,
            a: *const root::SparseMatrix,
            indx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::SparseComplexMatrix {
            SparseComplexMatrix_insert3(self, a, indx)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::SparseComplexMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn concat1(
            &mut self,
            rb: *const root::SparseMatrix,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_concat1(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::ComplexMatrix {
            SparseComplexMatrix_matrix_value(self)
        }
        #[inline]
        pub unsafe fn hermitian(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_hermitian(self)
        }
        #[inline]
        pub unsafe fn row(&self, i: root::octave_idx_type) -> root::ComplexRowVector {
            SparseComplexMatrix_row(self, i)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::ComplexColumnVector {
            SparseComplexMatrix_column(self, i)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse(self)
        }
        #[inline]
        pub unsafe fn inverse1(&self, mattype: *mut root::MatrixType) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse1(self, mattype)
        }
        #[inline]
        pub unsafe fn inverse2(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse2(self, mattype, info)
        }
        #[inline]
        pub unsafe fn inverse3(
            &self,
            mattype: *mut root::MatrixType,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            force: bool,
            calc_cond: bool,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_inverse3(self, mattype, info, rcond, force, calc_cond)
        }
        #[inline]
        pub unsafe fn determinant(&self) -> root::ComplexDET {
            SparseComplexMatrix_determinant(self)
        }
        #[inline]
        pub unsafe fn determinant1(&self, info: *mut root::octave_idx_type) -> root::ComplexDET {
            SparseComplexMatrix_determinant1(self, info)
        }
        #[inline]
        pub unsafe fn determinant2(
            &self,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            calc_cond: bool,
        ) -> root::ComplexDET {
            SparseComplexMatrix_determinant2(self, info, rcond, calc_cond)
        }
        #[inline]
        pub unsafe fn solve(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve1(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve1(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve2(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve2(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve3(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve3(
                self,
                mattype,
                b,
                info,
                rcond,
                sing_handler,
                singular_fallback,
            )
        }
        #[inline]
        pub unsafe fn solve4(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve4(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve5(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve5(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve6(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve6(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve7(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve7(
                self,
                mattype,
                b,
                info,
                rcond,
                sing_handler,
                singular_fallback,
            )
        }
        #[inline]
        pub unsafe fn solve8(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve8(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve9(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve9(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve10(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve10(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve11(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve11(
                self,
                mattype,
                b,
                info,
                rcond,
                sing_handler,
                singular_fallback,
            )
        }
        #[inline]
        pub unsafe fn solve12(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve12(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve13(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve13(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve14(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve14(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve15(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
            singular_fallback: bool,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve15(
                self,
                mattype,
                b,
                info,
                rcond,
                sing_handler,
                singular_fallback,
            )
        }
        #[inline]
        pub unsafe fn solve16(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve16(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve17(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve17(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve18(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve18(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve19(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve19(self, mattype, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve20(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve20(self, mattype, b)
        }
        #[inline]
        pub unsafe fn solve21(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve21(self, mattype, b, info)
        }
        #[inline]
        pub unsafe fn solve22(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve22(self, mattype, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve23(
            &self,
            mattype: *mut root::MatrixType,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve23(self, mattype, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve24(&self, b: *const root::Matrix) -> root::ComplexMatrix {
            SparseComplexMatrix_solve24(self, b)
        }
        #[inline]
        pub unsafe fn solve25(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve25(self, b, info)
        }
        #[inline]
        pub unsafe fn solve26(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve26(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve27(
            &self,
            b: *const root::Matrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve27(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve28(&self, b: *const root::ComplexMatrix) -> root::ComplexMatrix {
            SparseComplexMatrix_solve28(self, b)
        }
        #[inline]
        pub unsafe fn solve29(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve29(self, b, info)
        }
        #[inline]
        pub unsafe fn solve30(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve30(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve31(
            &self,
            b: *const root::ComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexMatrix {
            SparseComplexMatrix_solve31(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve32(&self, b: *const root::SparseMatrix) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve32(self, b)
        }
        #[inline]
        pub unsafe fn solve33(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve33(self, b, info)
        }
        #[inline]
        pub unsafe fn solve34(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve34(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve35(
            &self,
            b: *const root::SparseMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve35(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve36(
            &self,
            b: *const root::SparseComplexMatrix,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve36(self, b)
        }
        #[inline]
        pub unsafe fn solve37(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve37(self, b, info)
        }
        #[inline]
        pub unsafe fn solve38(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve38(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve39(
            &self,
            b: *const root::SparseComplexMatrix,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_solve39(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve40(&self, b: *const root::ColumnVector) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve40(self, b)
        }
        #[inline]
        pub unsafe fn solve41(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve41(self, b, info)
        }
        #[inline]
        pub unsafe fn solve42(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve42(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve43(
            &self,
            b: *const root::ColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve43(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn solve44(
            &self,
            b: *const root::ComplexColumnVector,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve44(self, b)
        }
        #[inline]
        pub unsafe fn solve45(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve45(self, b, info)
        }
        #[inline]
        pub unsafe fn solve46(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve46(self, b, info, rcond)
        }
        #[inline]
        pub unsafe fn solve47(
            &self,
            b: *const root::ComplexColumnVector,
            info: *mut root::octave_idx_type,
            rcond: *mut f64,
            sing_handler: root::SparseComplexMatrix_solve_singularity_handler,
        ) -> root::ComplexColumnVector {
            SparseComplexMatrix_solve47(self, b, info, rcond, sing_handler)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::SparseComplexMatrix {
            SparseComplexMatrix_squeeze(self)
        }
        #[inline]
        pub unsafe fn reshape(
            &self,
            new_dims: *const root::dim_vector,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_reshape(self, new_dims)
        }
        #[inline]
        pub unsafe fn permute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
            inv: bool,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn ipermute(
            &self,
            vec: *const root::Array<root::octave_idx_type>,
        ) -> root::SparseComplexMatrix {
            SparseComplexMatrix_ipermute(self, vec)
        }
        #[inline]
        pub unsafe fn any_element_is_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_nan(self)
        }
        #[inline]
        pub unsafe fn any_element_is_inf_or_nan(&self) -> bool {
            SparseComplexMatrix_any_element_is_inf_or_nan(self)
        }
        #[inline]
        pub unsafe fn all_elements_are_real(&self) -> bool {
            SparseComplexMatrix_all_elements_are_real(self)
        }
        #[inline]
        pub unsafe fn all_integers(&self, max_val: *mut f64, min_val: *mut f64) -> bool {
            SparseComplexMatrix_all_integers(self, max_val, min_val)
        }
        #[inline]
        pub unsafe fn too_large_for_float(&self) -> bool {
            SparseComplexMatrix_too_large_for_float(self)
        }
        #[inline]
        pub unsafe fn all(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseComplexMatrix_all(self, dim)
        }
        #[inline]
        pub unsafe fn any(&self, dim: ::std::os::raw::c_int) -> root::SparseBoolMatrix {
            SparseComplexMatrix_any(self, dim)
        }
        #[inline]
        pub unsafe fn cumprod(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumprod(self, dim)
        }
        #[inline]
        pub unsafe fn cumsum(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_cumsum(self, dim)
        }
        #[inline]
        pub unsafe fn prod(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_prod(self, dim)
        }
        #[inline]
        pub unsafe fn sum(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_sum(self, dim)
        }
        #[inline]
        pub unsafe fn sumsq(&self, dim: ::std::os::raw::c_int) -> root::SparseComplexMatrix {
            SparseComplexMatrix_sumsq(self, dim)
        }
        #[inline]
        pub unsafe fn abs(&self) -> root::SparseMatrix {
            SparseComplexMatrix_abs(self)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::SparseComplexMatrix {
            SparseComplexMatrix_diag(self, k)
        }
        #[inline]
        pub unsafe fn new(a: *const root::SparseMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(a: *const root::SparseBoolMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix1(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(a: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            SparseComplexMatrix_SparseComplexMatrix2(&mut __bindgen_tmp, a);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct intNDArray<T> {
        pub _base: root::MArray<T>,
        pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
    }
    pub type int8NDArray = root::intNDArray<root::octave_int8>;
    pub type int16NDArray = root::intNDArray<root::octave_int16>;
    pub type int32NDArray = root::intNDArray<root::octave_int32>;
    pub type int64NDArray = root::intNDArray<root::octave_int64>;
    pub type uint8NDArray = root::intNDArray<root::octave_uint8>;
    pub type uint16NDArray = root::intNDArray<root::octave_uint16>;
    pub type uint32NDArray = root::intNDArray<root::octave_uint32>;
    pub type uint64NDArray = root::intNDArray<root::octave_uint64>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct Range {
        pub rng_base: f64,
        pub rng_limit: f64,
        pub rng_inc: f64,
        pub rng_numel: root::octave_idx_type,
        pub cache: root::Matrix,
    }
    #[test]
    fn bindgen_test_layout_Range() {
        assert_eq!(
            ::core::mem::size_of::<Range>(),
            72usize,
            concat!("Size of: ", stringify!(Range))
        );
        assert_eq!(
            ::core::mem::align_of::<Range>(),
            8usize,
            concat!("Alignment of ", stringify!(Range))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Range>())).rng_base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Range),
                "::",
                stringify!(rng_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Range>())).rng_limit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Range),
                "::",
                stringify!(rng_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Range>())).rng_inc as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Range),
                "::",
                stringify!(rng_inc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Range>())).rng_numel as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Range),
                "::",
                stringify!(rng_numel)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<Range>())).cache as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Range),
                "::",
                stringify!(cache)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range21all_elements_are_intsEv"]
        pub fn Range_all_elements_are_ints(this: *const root::Range) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range12matrix_valueEv"]
        pub fn Range_matrix_value(this: *const root::Range) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range3minEv"]
        pub fn Range_min(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range3maxEv"]
        pub fn Range_max(this: *const root::Range) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN5Range13sort_internalEb"]
        pub fn Range_sort_internal(this: *mut root::Range, ascending: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN5Range13sort_internalER5ArrayIlEb"]
        pub fn Range_sort_internal1(
            this: *mut root::Range,
            sidx: *mut root::Array<root::octave_idx_type>,
            ascending: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range4diagEl"]
        pub fn Range_diag(this: *const root::Range, k: root::octave_idx_type) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range4sortEl8sortmode"]
        pub fn Range_sort(
            this: *const root::Range,
            dim: root::octave_idx_type,
            mode: root::sortmode,
        ) -> root::Range;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range4sortER5ArrayIlEl8sortmode"]
        pub fn Range_sort1(
            this: *const root::Range,
            sidx: *mut root::Array<root::octave_idx_type>,
            dim: root::octave_idx_type,
            mode: root::sortmode,
        ) -> root::Range;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range8issortedE8sortmode"]
        pub fn Range_issorted(this: *const root::Range, mode: root::sortmode) -> root::sortmode;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range3nnzEv"]
        pub fn Range_nnz(this: *const root::Range) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range9checkelemEl"]
        pub fn Range_checkelem(this: *const root::Range, i: root::octave_idx_type) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range9checkelemEll"]
        pub fn Range_checkelem1(
            this: *const root::Range,
            i: root::octave_idx_type,
            j: root::octave_idx_type,
        ) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range4elemEl"]
        pub fn Range_elem(this: *const root::Range, i: root::octave_idx_type) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK5Range5indexERK10idx_vector"]
        pub fn Range_index(
            this: *const root::Range,
            i: *const root::idx_vector,
        ) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN5Range8set_baseEd"]
        pub fn Range_set_base(this: *mut root::Range, b: f64);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN5Range9set_limitEd"]
        pub fn Range_set_limit(this: *mut root::Range, l: f64);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN5Range7set_incEd"]
        pub fn Range_set_inc(this: *mut root::Range, i: f64);
    }
    impl Range {
        #[inline]
        pub unsafe fn all_elements_are_ints(&self) -> bool {
            Range_all_elements_are_ints(self)
        }
        #[inline]
        pub unsafe fn matrix_value(&self) -> root::Matrix {
            Range_matrix_value(self)
        }
        #[inline]
        pub unsafe fn min(&self) -> f64 {
            Range_min(self)
        }
        #[inline]
        pub unsafe fn max(&self) -> f64 {
            Range_max(self)
        }
        #[inline]
        pub unsafe fn sort_internal(&mut self, ascending: bool) {
            Range_sort_internal(self, ascending)
        }
        #[inline]
        pub unsafe fn sort_internal1(
            &mut self,
            sidx: *mut root::Array<root::octave_idx_type>,
            ascending: bool,
        ) {
            Range_sort_internal1(self, sidx, ascending)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Matrix {
            Range_diag(self, k)
        }
        #[inline]
        pub unsafe fn sort(&self, dim: root::octave_idx_type, mode: root::sortmode) -> root::Range {
            Range_sort(self, dim, mode)
        }
        #[inline]
        pub unsafe fn sort1(
            &self,
            sidx: *mut root::Array<root::octave_idx_type>,
            dim: root::octave_idx_type,
            mode: root::sortmode,
        ) -> root::Range {
            Range_sort1(self, sidx, dim, mode)
        }
        #[inline]
        pub unsafe fn issorted(&self, mode: root::sortmode) -> root::sortmode {
            Range_issorted(self, mode)
        }
        #[inline]
        pub unsafe fn nnz(&self) -> root::octave_idx_type {
            Range_nnz(self)
        }
        #[inline]
        pub unsafe fn checkelem(&self, i: root::octave_idx_type) -> f64 {
            Range_checkelem(self, i)
        }
        #[inline]
        pub unsafe fn checkelem1(&self, i: root::octave_idx_type, j: root::octave_idx_type) -> f64 {
            Range_checkelem1(self, i, j)
        }
        #[inline]
        pub unsafe fn elem(&self, i: root::octave_idx_type) -> f64 {
            Range_elem(self, i)
        }
        #[inline]
        pub unsafe fn index(&self, i: *const root::idx_vector) -> root::Array<f64> {
            Range_index(self, i)
        }
        #[inline]
        pub unsafe fn set_base(&mut self, b: f64) {
            Range_set_base(self, b)
        }
        #[inline]
        pub unsafe fn set_limit(&mut self, l: f64) {
            Range_set_limit(self, l)
        }
        #[inline]
        pub unsafe fn set_inc(&mut self, i: f64) {
            Range_set_inc(self, i)
        }
    }
    pub const oct_data_conv_data_type_dt_int8: root::oct_data_conv_data_type = 0;
    pub const oct_data_conv_data_type_dt_uint8: root::oct_data_conv_data_type = 1;
    pub const oct_data_conv_data_type_dt_int16: root::oct_data_conv_data_type = 2;
    pub const oct_data_conv_data_type_dt_uint16: root::oct_data_conv_data_type = 3;
    pub const oct_data_conv_data_type_dt_int32: root::oct_data_conv_data_type = 4;
    pub const oct_data_conv_data_type_dt_uint32: root::oct_data_conv_data_type = 5;
    pub const oct_data_conv_data_type_dt_int64: root::oct_data_conv_data_type = 6;
    pub const oct_data_conv_data_type_dt_uint64: root::oct_data_conv_data_type = 7;
    pub const oct_data_conv_data_type_dt_single: root::oct_data_conv_data_type = 8;
    pub const oct_data_conv_data_type_dt_double: root::oct_data_conv_data_type = 9;
    pub const oct_data_conv_data_type_dt_char: root::oct_data_conv_data_type = 10;
    pub const oct_data_conv_data_type_dt_schar: root::oct_data_conv_data_type = 11;
    pub const oct_data_conv_data_type_dt_uchar: root::oct_data_conv_data_type = 12;
    pub const oct_data_conv_data_type_dt_logical: root::oct_data_conv_data_type = 13;
    pub const oct_data_conv_data_type_dt_short: root::oct_data_conv_data_type = 14;
    pub const oct_data_conv_data_type_dt_ushort: root::oct_data_conv_data_type = 15;
    pub const oct_data_conv_data_type_dt_int: root::oct_data_conv_data_type = 16;
    pub const oct_data_conv_data_type_dt_uint: root::oct_data_conv_data_type = 17;
    pub const oct_data_conv_data_type_dt_long: root::oct_data_conv_data_type = 18;
    pub const oct_data_conv_data_type_dt_ulong: root::oct_data_conv_data_type = 19;
    pub const oct_data_conv_data_type_dt_longlong: root::oct_data_conv_data_type = 20;
    pub const oct_data_conv_data_type_dt_ulonglong: root::oct_data_conv_data_type = 21;
    pub const oct_data_conv_data_type_dt_float: root::oct_data_conv_data_type = 22;
    pub const oct_data_conv_data_type_dt_unknown: root::oct_data_conv_data_type = 23;
    pub type oct_data_conv_data_type = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mxArray {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_function {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_handle {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_fcn_inline {
        _unused: [u8; 0],
    }
    pub type octave_base_stream = root::octave::base_stream;
    pub type octave_stream = root::octave::stream;
    pub type octave_stream_list = root::octave::stream_list;
    pub type octave_hdf5_id = i64;
    pub type octave_hdf5_err = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct float_display_format {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_classdef {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_script {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_user_code {
        _unused: [u8; 0],
    }
    pub const builtin_type_t_btyp_double: root::builtin_type_t = 0;
    pub const builtin_type_t_btyp_float: root::builtin_type_t = 1;
    pub const builtin_type_t_btyp_complex: root::builtin_type_t = 2;
    pub const builtin_type_t_btyp_float_complex: root::builtin_type_t = 3;
    pub const builtin_type_t_btyp_int8: root::builtin_type_t = 4;
    pub const builtin_type_t_btyp_int16: root::builtin_type_t = 5;
    pub const builtin_type_t_btyp_int32: root::builtin_type_t = 6;
    pub const builtin_type_t_btyp_int64: root::builtin_type_t = 7;
    pub const builtin_type_t_btyp_uint8: root::builtin_type_t = 8;
    pub const builtin_type_t_btyp_uint16: root::builtin_type_t = 9;
    pub const builtin_type_t_btyp_uint32: root::builtin_type_t = 10;
    pub const builtin_type_t_btyp_uint64: root::builtin_type_t = 11;
    pub const builtin_type_t_btyp_bool: root::builtin_type_t = 12;
    pub const builtin_type_t_btyp_char: root::builtin_type_t = 13;
    pub const builtin_type_t_btyp_struct: root::builtin_type_t = 14;
    pub const builtin_type_t_btyp_cell: root::builtin_type_t = 15;
    pub const builtin_type_t_btyp_func_handle: root::builtin_type_t = 16;
    pub const builtin_type_t_btyp_unknown: root::builtin_type_t = 17;
    pub const builtin_type_t_btyp_num_types: root::builtin_type_t = 17;
    pub type builtin_type_t = u32;
    #[repr(C)]
    pub struct octave_base_value__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_base_value {
        pub vtable_: *const octave_base_value__bindgen_vtable,
        pub count: root::octave::refcount<root::octave_idx_type>,
    }
    pub type octave_base_value_type_conv_fcn = ::core::option::Option<
        unsafe extern "C" fn(arg1: *const root::octave_base_value) -> *mut root::octave_base_value,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct octave_base_value_type_conv_info {
        pub _fcn: root::octave_base_value_type_conv_fcn,
        pub _type_id: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_octave_base_value_type_conv_info() {
        assert_eq!(
            ::core::mem::size_of::<octave_base_value_type_conv_info>(),
            16usize,
            concat!("Size of: ", stringify!(octave_base_value_type_conv_info))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_base_value_type_conv_info>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(octave_base_value_type_conv_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_base_value_type_conv_info>()))._fcn as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_base_value_type_conv_info),
                "::",
                stringify!(_fcn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_base_value_type_conv_info>()))._type_id as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_base_value_type_conv_info),
                "::",
                stringify!(_type_id)
            )
        );
    }
    pub const octave_base_value_unary_mapper_t_umap_abs: root::octave_base_value_unary_mapper_t = 0;
    pub const octave_base_value_unary_mapper_t_umap_acos: root::octave_base_value_unary_mapper_t =
        1;
    pub const octave_base_value_unary_mapper_t_umap_acosh: root::octave_base_value_unary_mapper_t =
        2;
    pub const octave_base_value_unary_mapper_t_umap_angle: root::octave_base_value_unary_mapper_t =
        3;
    pub const octave_base_value_unary_mapper_t_umap_arg: root::octave_base_value_unary_mapper_t = 4;
    pub const octave_base_value_unary_mapper_t_umap_asin: root::octave_base_value_unary_mapper_t =
        5;
    pub const octave_base_value_unary_mapper_t_umap_asinh: root::octave_base_value_unary_mapper_t =
        6;
    pub const octave_base_value_unary_mapper_t_umap_atan: root::octave_base_value_unary_mapper_t =
        7;
    pub const octave_base_value_unary_mapper_t_umap_atanh: root::octave_base_value_unary_mapper_t =
        8;
    pub const octave_base_value_unary_mapper_t_umap_cbrt: root::octave_base_value_unary_mapper_t =
        9;
    pub const octave_base_value_unary_mapper_t_umap_ceil: root::octave_base_value_unary_mapper_t =
        10;
    pub const octave_base_value_unary_mapper_t_umap_conj: root::octave_base_value_unary_mapper_t =
        11;
    pub const octave_base_value_unary_mapper_t_umap_cos: root::octave_base_value_unary_mapper_t =
        12;
    pub const octave_base_value_unary_mapper_t_umap_cosh: root::octave_base_value_unary_mapper_t =
        13;
    pub const octave_base_value_unary_mapper_t_umap_erf: root::octave_base_value_unary_mapper_t =
        14;
    pub const octave_base_value_unary_mapper_t_umap_erfinv: root::octave_base_value_unary_mapper_t =
        15;
    pub const octave_base_value_unary_mapper_t_umap_erfcinv:
        root::octave_base_value_unary_mapper_t = 16;
    pub const octave_base_value_unary_mapper_t_umap_erfc: root::octave_base_value_unary_mapper_t =
        17;
    pub const octave_base_value_unary_mapper_t_umap_erfcx: root::octave_base_value_unary_mapper_t =
        18;
    pub const octave_base_value_unary_mapper_t_umap_erfi: root::octave_base_value_unary_mapper_t =
        19;
    pub const octave_base_value_unary_mapper_t_umap_dawson: root::octave_base_value_unary_mapper_t =
        20;
    pub const octave_base_value_unary_mapper_t_umap_exp: root::octave_base_value_unary_mapper_t =
        21;
    pub const octave_base_value_unary_mapper_t_umap_expm1: root::octave_base_value_unary_mapper_t =
        22;
    pub const octave_base_value_unary_mapper_t_umap_isfinite:
        root::octave_base_value_unary_mapper_t = 23;
    pub const octave_base_value_unary_mapper_t_umap_fix: root::octave_base_value_unary_mapper_t =
        24;
    pub const octave_base_value_unary_mapper_t_umap_floor: root::octave_base_value_unary_mapper_t =
        25;
    pub const octave_base_value_unary_mapper_t_umap_gamma: root::octave_base_value_unary_mapper_t =
        26;
    pub const octave_base_value_unary_mapper_t_umap_imag: root::octave_base_value_unary_mapper_t =
        27;
    pub const octave_base_value_unary_mapper_t_umap_isinf: root::octave_base_value_unary_mapper_t =
        28;
    pub const octave_base_value_unary_mapper_t_umap_isna: root::octave_base_value_unary_mapper_t =
        29;
    pub const octave_base_value_unary_mapper_t_umap_isnan: root::octave_base_value_unary_mapper_t =
        30;
    pub const octave_base_value_unary_mapper_t_umap_lgamma: root::octave_base_value_unary_mapper_t =
        31;
    pub const octave_base_value_unary_mapper_t_umap_log: root::octave_base_value_unary_mapper_t =
        32;
    pub const octave_base_value_unary_mapper_t_umap_log2: root::octave_base_value_unary_mapper_t =
        33;
    pub const octave_base_value_unary_mapper_t_umap_log10: root::octave_base_value_unary_mapper_t =
        34;
    pub const octave_base_value_unary_mapper_t_umap_log1p: root::octave_base_value_unary_mapper_t =
        35;
    pub const octave_base_value_unary_mapper_t_umap_real: root::octave_base_value_unary_mapper_t =
        36;
    pub const octave_base_value_unary_mapper_t_umap_round: root::octave_base_value_unary_mapper_t =
        37;
    pub const octave_base_value_unary_mapper_t_umap_roundb: root::octave_base_value_unary_mapper_t =
        38;
    pub const octave_base_value_unary_mapper_t_umap_signum: root::octave_base_value_unary_mapper_t =
        39;
    pub const octave_base_value_unary_mapper_t_umap_sin: root::octave_base_value_unary_mapper_t =
        40;
    pub const octave_base_value_unary_mapper_t_umap_sinh: root::octave_base_value_unary_mapper_t =
        41;
    pub const octave_base_value_unary_mapper_t_umap_sqrt: root::octave_base_value_unary_mapper_t =
        42;
    pub const octave_base_value_unary_mapper_t_umap_tan: root::octave_base_value_unary_mapper_t =
        43;
    pub const octave_base_value_unary_mapper_t_umap_tanh: root::octave_base_value_unary_mapper_t =
        44;
    pub const octave_base_value_unary_mapper_t_umap_xisalnum:
        root::octave_base_value_unary_mapper_t = 45;
    pub const octave_base_value_unary_mapper_t_umap_xisalpha:
        root::octave_base_value_unary_mapper_t = 46;
    pub const octave_base_value_unary_mapper_t_umap_xisascii:
        root::octave_base_value_unary_mapper_t = 47;
    pub const octave_base_value_unary_mapper_t_umap_xiscntrl:
        root::octave_base_value_unary_mapper_t = 48;
    pub const octave_base_value_unary_mapper_t_umap_xisdigit:
        root::octave_base_value_unary_mapper_t = 49;
    pub const octave_base_value_unary_mapper_t_umap_xisgraph:
        root::octave_base_value_unary_mapper_t = 50;
    pub const octave_base_value_unary_mapper_t_umap_xislower:
        root::octave_base_value_unary_mapper_t = 51;
    pub const octave_base_value_unary_mapper_t_umap_xisprint:
        root::octave_base_value_unary_mapper_t = 52;
    pub const octave_base_value_unary_mapper_t_umap_xispunct:
        root::octave_base_value_unary_mapper_t = 53;
    pub const octave_base_value_unary_mapper_t_umap_xisspace:
        root::octave_base_value_unary_mapper_t = 54;
    pub const octave_base_value_unary_mapper_t_umap_xisupper:
        root::octave_base_value_unary_mapper_t = 55;
    pub const octave_base_value_unary_mapper_t_umap_xisxdigit:
        root::octave_base_value_unary_mapper_t = 56;
    pub const octave_base_value_unary_mapper_t_umap_xsignbit:
        root::octave_base_value_unary_mapper_t = 57;
    pub const octave_base_value_unary_mapper_t_umap_xtolower:
        root::octave_base_value_unary_mapper_t = 58;
    pub const octave_base_value_unary_mapper_t_umap_xtoupper:
        root::octave_base_value_unary_mapper_t = 59;
    pub const octave_base_value_unary_mapper_t_umap_unknown:
        root::octave_base_value_unary_mapper_t = 60;
    pub const octave_base_value_unary_mapper_t_num_unary_mappers:
        root::octave_base_value_unary_mapper_t = 60;
    pub type octave_base_value_unary_mapper_t = u32;
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value23curr_print_indent_levelE"]
        pub static mut octave_base_value_curr_print_indent_level: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value17beginning_of_lineE"]
        pub static mut octave_base_value_beginning_of_line: bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value4t_idE"]
        pub static mut octave_base_value_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value6t_nameB5cxx11E"]
        pub static octave_base_value_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value6c_nameB5cxx11E"]
        pub static octave_base_value_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_base_value() {
        assert_eq!(
            ::core::mem::size_of::<octave_base_value>(),
            16usize,
            concat!("Size of: ", stringify!(octave_base_value))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_base_value>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_base_value))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_base_value>())).count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_base_value),
                "::",
                stringify!(count)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value14numeric_assignERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEERK12octave_value"]
        pub fn octave_base_value_numeric_assign(
            this: *mut root::octave_base_value,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value6indentERSo"]
        pub fn octave_base_value_indent(
            this: *const root::octave_base_value,
            os: *mut root::std::ostream,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7newlineERSo"]
        pub fn octave_base_value_newline(
            this: *const root::octave_base_value,
            os: *mut root::std::ostream,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value5resetEv"]
        pub fn octave_base_value_reset(this: *const root::octave_base_value);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value13get_umap_nameENS_14unary_mapper_tE"]
        pub fn octave_base_value_get_umap_name(
            arg1: root::octave_base_value_unary_mapper_t,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9warn_loadEPKc"]
        pub fn octave_base_value_warn_load(
            this: *const root::octave_base_value,
            type_: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9warn_saveEPKc"]
        pub fn octave_base_value_warn_save(
            this: *const root::octave_base_value,
            type_: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value13register_typeEv"]
        pub fn octave_base_value_register_type();
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value13register_typeERN6octave9type_infoE"]
        pub fn octave_base_value_register_type1(arg1: *mut root::octave::type_info);
    }
    impl octave_base_value {
        #[inline]
        pub unsafe fn numeric_assign(
            &mut self,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value {
            octave_base_value_numeric_assign(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn indent(&self, os: *mut root::std::ostream) {
            octave_base_value_indent(self, os)
        }
        #[inline]
        pub unsafe fn newline(&self, os: *mut root::std::ostream) {
            octave_base_value_newline(self, os)
        }
        #[inline]
        pub unsafe fn reset(&self) {
            octave_base_value_reset(self)
        }
        #[inline]
        pub unsafe fn get_umap_name(
            arg1: root::octave_base_value_unary_mapper_t,
        ) -> *const ::std::os::raw::c_char {
            octave_base_value_get_umap_name(arg1)
        }
        #[inline]
        pub unsafe fn warn_load(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_load(self, type_)
        }
        #[inline]
        pub unsafe fn warn_save(&self, type_: *const ::std::os::raw::c_char) {
            octave_base_value_warn_save(self, type_)
        }
        #[inline]
        pub unsafe fn register_type() {
            octave_base_value_register_type()
        }
        #[inline]
        pub unsafe fn register_type1(arg1: *mut root::octave::type_info) {
            octave_base_value_register_type1(arg1)
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11empty_cloneEv"]
        pub fn octave_base_value_empty_clone(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::octave_base_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7squeezeEv"]
        pub fn octave_base_value_squeeze(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10full_valueEv"]
        pub fn octave_base_value_full_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9as_doubleEv"]
        pub fn octave_base_value_as_double(this: *mut ::std::os::raw::c_void)
            -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9as_singleEv"]
        pub fn octave_base_value_as_single(this: *mut ::std::os::raw::c_void)
            -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7as_int8Ev"]
        pub fn octave_base_value_as_int8(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8as_int16Ev"]
        pub fn octave_base_value_as_int16(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8as_int32Ev"]
        pub fn octave_base_value_as_int32(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8as_int64Ev"]
        pub fn octave_base_value_as_int64(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8as_uint8Ev"]
        pub fn octave_base_value_as_uint8(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9as_uint16Ev"]
        pub fn octave_base_value_as_uint16(this: *mut ::std::os::raw::c_void)
            -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9as_uint32Ev"]
        pub fn octave_base_value_as_uint32(this: *mut ::std::os::raw::c_void)
            -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9as_uint64Ev"]
        pub fn octave_base_value_as_uint64(this: *mut ::std::os::raw::c_void)
            -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value4sizeEv"]
        pub fn octave_base_value_size(this: *mut ::std::os::raw::c_void) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value5numelERK17octave_value_list"]
        pub fn octave_base_value_numel(
            this: *mut ::std::os::raw::c_void,
            arg1: *const root::octave_value_list,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value7subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEE"]
        pub fn octave_base_value_subsref(
            this: *mut ::std::os::raw::c_void,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value7subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEi"]
        pub fn octave_base_value_subsref1(
            this: *mut ::std::os::raw::c_void,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            nargout: ::std::os::raw::c_int,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value7subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEb"]
        pub fn octave_base_value_subsref2(
            this: *mut ::std::os::raw::c_void,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            auto_add: bool,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value11do_index_opERK17octave_value_listb"]
        pub fn octave_base_value_do_index_op(
            this: *mut ::std::os::raw::c_void,
            idx: *const root::octave_value_list,
            resize_ok: bool,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value8subsasgnERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEERK12octave_value"]
        pub fn octave_base_value_subsasgn(
            this: *mut ::std::os::raw::c_void,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value14undef_subsasgnERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEERK12octave_value"]
        pub fn octave_base_value_undef_subsasgn(
            this: *mut ::std::os::raw::c_void,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12index_vectorEb"]
        pub fn octave_base_value_index_vector(
            this: *mut ::std::os::raw::c_void,
            require_integers: bool,
        ) -> root::idx_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value3nnzEv"]
        pub fn octave_base_value_nnz(this: *mut ::std::os::raw::c_void) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value5nzmaxEv"]
        pub fn octave_base_value_nzmax(this: *mut ::std::os::raw::c_void) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7nfieldsEv"]
        pub fn octave_base_value_nfields(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7reshapeERK10dim_vector"]
        pub fn octave_base_value_reshape(
            this: *mut ::std::os::raw::c_void,
            arg1: *const root::dim_vector,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value7permuteERK5ArrayIiEb"]
        pub fn octave_base_value_permute(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::Array<::std::os::raw::c_int>,
            arg1: bool,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value6resizeERK10dim_vectorb"]
        pub fn octave_base_value_resize(
            this: *mut ::std::os::raw::c_void,
            arg1: *const root::dim_vector,
            fill: bool,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11matrix_typeEv"]
        pub fn octave_base_value_matrix_type(this: *mut ::std::os::raw::c_void)
            -> root::MatrixType;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11matrix_typeERK10MatrixType"]
        pub fn octave_base_value_matrix_type1(
            this: *mut ::std::os::raw::c_void,
            typ: *const root::MatrixType,
        ) -> root::MatrixType;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value3allEi"]
        pub fn octave_base_value_all(
            this: *mut ::std::os::raw::c_void,
            arg1: ::std::os::raw::c_int,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value3anyEi"]
        pub fn octave_base_value_any(
            this: *mut ::std::os::raw::c_void,
            arg1: ::std::os::raw::c_int,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11short_valueEbb"]
        pub fn octave_base_value_short_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_short;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12ushort_valueEbb"]
        pub fn octave_base_value_ushort_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_ushort;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9int_valueEbb"]
        pub fn octave_base_value_int_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10uint_valueEbb"]
        pub fn octave_base_value_uint_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10nint_valueEb"]
        pub fn octave_base_value_nint_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10long_valueEbb"]
        pub fn octave_base_value_long_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11ulong_valueEbb"]
        pub fn octave_base_value_ulong_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11int64_valueEbb"]
        pub fn octave_base_value_int64_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> i64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12uint64_valueEbb"]
        pub fn octave_base_value_uint64_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
            arg2: bool,
        ) -> u64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12double_valueEb"]
        pub fn octave_base_value_double_value(this: *mut ::std::os::raw::c_void, arg1: bool)
            -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11float_valueEb"]
        pub fn octave_base_value_float_value(this: *mut ::std::os::raw::c_void, arg1: bool) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10cell_valueEv"]
        pub fn octave_base_value_cell_value(this: *mut ::std::os::raw::c_void) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12matrix_valueEb"]
        pub fn octave_base_value_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18float_matrix_valueEb"]
        pub fn octave_base_value_float_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11array_valueEb"]
        pub fn octave_base_value_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17float_array_valueEb"]
        pub fn octave_base_value_float_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value13complex_valueEb"]
        pub fn octave_base_value_complex_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19float_complex_valueEb"]
        pub fn octave_base_value_float_complex_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value20complex_matrix_valueEb"]
        pub fn octave_base_value_complex_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value26float_complex_matrix_valueEb"]
        pub fn octave_base_value_float_complex_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19complex_array_valueEb"]
        pub fn octave_base_value_complex_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value25float_complex_array_valueEb"]
        pub fn octave_base_value_float_complex_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10bool_valueEb"]
        pub fn octave_base_value_bool_value(this: *mut ::std::os::raw::c_void, arg1: bool) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17bool_matrix_valueEb"]
        pub fn octave_base_value_bool_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value16bool_array_valueEb"]
        pub fn octave_base_value_bool_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17char_matrix_valueEb"]
        pub fn octave_base_value_char_matrix_value(
            this: *mut ::std::os::raw::c_void,
            force: bool,
        ) -> root::charMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value16char_array_valueEb"]
        pub fn octave_base_value_char_array_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19sparse_matrix_valueEb"]
        pub fn octave_base_value_sparse_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value27sparse_complex_matrix_valueEb"]
        pub fn octave_base_value_sparse_complex_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value24sparse_bool_matrix_valueEb"]
        pub fn octave_base_value_sparse_bool_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17diag_matrix_valueEb"]
        pub fn octave_base_value_diag_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value23float_diag_matrix_valueEb"]
        pub fn octave_base_value_float_diag_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value25complex_diag_matrix_valueEb"]
        pub fn octave_base_value_complex_diag_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value31float_complex_diag_matrix_valueEb"]
        pub fn octave_base_value_float_complex_diag_matrix_value(
            this: *mut ::std::os::raw::c_void,
            arg1: bool,
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17perm_matrix_valueEv"]
        pub fn octave_base_value_perm_matrix_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17int8_scalar_valueEv"]
        pub fn octave_base_value_int8_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_int8;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18int16_scalar_valueEv"]
        pub fn octave_base_value_int16_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_int16;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18int32_scalar_valueEv"]
        pub fn octave_base_value_int32_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_int32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18int64_scalar_valueEv"]
        pub fn octave_base_value_int64_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_int64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18uint8_scalar_valueEv"]
        pub fn octave_base_value_uint8_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_uint8;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19uint16_scalar_valueEv"]
        pub fn octave_base_value_uint16_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_uint16;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19uint32_scalar_valueEv"]
        pub fn octave_base_value_uint32_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_uint32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19uint64_scalar_valueEv"]
        pub fn octave_base_value_uint64_scalar_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_uint64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value16int8_array_valueEv"]
        pub fn octave_base_value_int8_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::int8NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17int16_array_valueEv"]
        pub fn octave_base_value_int16_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::int16NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17int32_array_valueEv"]
        pub fn octave_base_value_int32_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::int32NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17int64_array_valueEv"]
        pub fn octave_base_value_int64_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::int64NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17uint8_array_valueEv"]
        pub fn octave_base_value_uint8_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::uint8NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18uint16_array_valueEv"]
        pub fn octave_base_value_uint16_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::uint16NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18uint32_array_valueEv"]
        pub fn octave_base_value_uint32_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::uint32NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18uint64_array_valueEv"]
        pub fn octave_base_value_uint64_array_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::uint64NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value19string_vector_valueEb"]
        pub fn octave_base_value_string_vector_value(
            this: *mut ::std::os::raw::c_void,
            pad: bool,
        ) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value12string_valueB5cxx11Eb"]
        pub fn octave_base_value_string_value(
            this: *mut ::std::os::raw::c_void,
            force: bool,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value13cellstr_valueB5cxx11Ev"]
        pub fn octave_base_value_cellstr_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::Array<root::std::string>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value11range_valueEv"]
        pub fn octave_base_value_range_value(this: *mut ::std::os::raw::c_void) -> root::Range;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9map_valueEv"]
        pub fn octave_base_value_map_value(this: *mut ::std::os::raw::c_void) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value16scalar_map_valueEv"]
        pub fn octave_base_value_scalar_map_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8map_keysEv"]
        pub fn octave_base_value_map_keys(this: *mut ::std::os::raw::c_void)
            -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8nparentsEv"]
        pub fn octave_base_value_nparents(this: *mut ::std::os::raw::c_void) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value22parent_class_name_listB5cxx11Ev"]
        pub fn octave_base_value_parent_class_name_list(
            this: *mut ::std::os::raw::c_void,
        ) -> [u64; 3usize];
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value18parent_class_namesEv"]
        pub fn octave_base_value_parent_class_names(
            this: *mut ::std::os::raw::c_void,
        ) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value21classdef_object_valueEb"]
        pub fn octave_base_value_classdef_object_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_classdef;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value14function_valueEb"]
        pub fn octave_base_value_function_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value19user_function_valueEb"]
        pub fn octave_base_value_user_function_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value17user_script_valueEb"]
        pub fn octave_base_value_user_script_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value15user_code_valueEb"]
        pub fn octave_base_value_user_code_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value16fcn_handle_valueEb"]
        pub fn octave_base_value_fcn_handle_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value16fcn_inline_valueEb"]
        pub fn octave_base_value_fcn_inline_value(
            this: *mut ::std::os::raw::c_void,
            silent: bool,
        ) -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10list_valueEv"]
        pub fn octave_base_value_list_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value14convert_to_strEbbc"]
        pub fn octave_base_value_convert_to_str(
            this: *mut ::std::os::raw::c_void,
            pad: bool,
            force: bool,
            type_: ::std::os::raw::c_char,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value23convert_to_str_internalEbbc"]
        pub fn octave_base_value_convert_to_str_internal(
            this: *mut ::std::os::raw::c_void,
            pad: bool,
            force: bool,
            type_: ::std::os::raw::c_char,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value31convert_to_row_or_column_vectorEv"]
        pub fn octave_base_value_convert_to_row_or_column_vector(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value13xstring_valueB5cxx11Ev"]
        pub fn octave_base_value_xstring_value(
            this: *mut ::std::os::raw::c_void,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value5printERSob"]
        pub fn octave_base_value_print(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
            pr_as_read_syntax: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value9print_rawERSob"]
        pub fn octave_base_value_print_raw(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
            pr_as_read_syntax: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value14print_name_tagERSoRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_base_value_print_name_tag(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
            name: *const root::std::string,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value15print_with_nameERSoRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
        pub fn octave_base_value_print_with_name(
            this: *mut ::std::os::raw::c_void,
            output_buf: *mut root::std::ostream,
            name: *const root::std::string,
            print_padding: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value23get_edit_display_formatEv"]
        pub fn octave_base_value_get_edit_display_format(
            this: *mut ::std::os::raw::c_void,
        ) -> root::float_display_format;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10print_infoERSoRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_base_value_print_info(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
            prefix: *const root::std::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value10save_asciiERSo"]
        pub fn octave_base_value_save_ascii(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value10load_asciiERSi"]
        pub fn octave_base_value_load_ascii(
            this: *mut ::std::os::raw::c_void,
            is: *mut root::std::istream,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value11save_binaryERSoRb"]
        pub fn octave_base_value_save_binary(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::std::ostream,
            save_as_floats: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value11load_binaryERSibN6octave9mach_info12float_formatE"]
        pub fn octave_base_value_load_binary(
            this: *mut ::std::os::raw::c_void,
            is: *mut root::std::istream,
            swap: bool,
            fmt: root::octave::mach_info::float_format,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value9save_hdf5ElPKcb"]
        pub fn octave_base_value_save_hdf5(
            this: *mut ::std::os::raw::c_void,
            loc_id: root::octave_hdf5_id,
            name: *const ::std::os::raw::c_char,
            save_as_floats: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value9load_hdf5ElPKc"]
        pub fn octave_base_value_load_hdf5(
            this: *mut ::std::os::raw::c_void,
            loc_id: root::octave_hdf5_id,
            name: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value5writeERN6octave6streamEiN13oct_data_conv9data_typeEiNS0_9mach_info12float_formatE"]
        pub fn octave_base_value_write(
            this: *mut ::std::os::raw::c_void,
            os: *mut root::octave::stream,
            block_size: ::std::os::raw::c_int,
            output_type: root::oct_data_conv_data_type,
            skip: ::std::os::raw::c_int,
            flt_fmt: root::octave::mach_info::float_format,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value10as_mxArrayEv"]
        pub fn octave_base_value_as_mxArray(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::mxArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value4diagEl"]
        pub fn octave_base_value_diag(
            this: *mut ::std::os::raw::c_void,
            k: root::octave_idx_type,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value4diagEll"]
        pub fn octave_base_value_diag1(
            this: *mut ::std::os::raw::c_void,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value4sortEl8sortmode"]
        pub fn octave_base_value_sort(
            this: *mut ::std::os::raw::c_void,
            dim: root::octave_idx_type,
            mode: root::sortmode,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value4sortER5ArrayIlEl8sortmode"]
        pub fn octave_base_value_sort1(
            this: *mut ::std::os::raw::c_void,
            sidx: *mut root::Array<root::octave_idx_type>,
            dim: root::octave_idx_type,
            mode: root::sortmode,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value8issortedE8sortmode"]
        pub fn octave_base_value_issorted(
            this: *mut ::std::os::raw::c_void,
            mode: root::sortmode,
        ) -> root::sortmode;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value13sort_rows_idxE8sortmode"]
        pub fn octave_base_value_sort_rows_idx(
            this: *mut ::std::os::raw::c_void,
            mode: root::sortmode,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value14is_sorted_rowsE8sortmode"]
        pub fn octave_base_value_is_sorted_rows(
            this: *mut ::std::os::raw::c_void,
            mode: root::sortmode,
        ) -> root::sortmode;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value4lockEv"]
        pub fn octave_base_value_lock(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value6unlockEv"]
        pub fn octave_base_value_unlock(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value4dumpEv"]
        pub fn octave_base_value_dump(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value3mapENS_14unary_mapper_tE"]
        pub fn octave_base_value_map(
            this: *mut ::std::os::raw::c_void,
            arg1: root::octave_base_value_unary_mapper_t,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value17fast_elem_extractEl"]
        pub fn octave_base_value_fast_elem_extract(
            this: *mut ::std::os::raw::c_void,
            n: root::octave_idx_type,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_base_value16fast_elem_insertElRK12octave_value"]
        pub fn octave_base_value_fast_elem_insert(
            this: *mut ::std::os::raw::c_void,
            n: root::octave_idx_type,
            x: *const root::octave_value,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_base_value21fast_elem_insert_selfEPv14builtin_type_t"]
        pub fn octave_base_value_fast_elem_insert_self(
            this: *mut ::std::os::raw::c_void,
            where_: *mut ::std::os::raw::c_void,
            btyp: root::builtin_type_t,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value {
        #[doc = "! The real representation."]
        pub rep: *mut root::octave_base_value,
    }
    pub const octave_value_unary_op_op_not: root::octave_value_unary_op = 0;
    pub const octave_value_unary_op_op_uplus: root::octave_value_unary_op = 1;
    pub const octave_value_unary_op_op_uminus: root::octave_value_unary_op = 2;
    pub const octave_value_unary_op_op_transpose: root::octave_value_unary_op = 3;
    pub const octave_value_unary_op_op_hermitian: root::octave_value_unary_op = 4;
    pub const octave_value_unary_op_op_incr: root::octave_value_unary_op = 5;
    pub const octave_value_unary_op_op_decr: root::octave_value_unary_op = 6;
    pub const octave_value_unary_op_num_unary_ops: root::octave_value_unary_op = 7;
    pub const octave_value_unary_op_unknown_unary_op: root::octave_value_unary_op = 8;
    pub type octave_value_unary_op = u32;
    pub const octave_value_binary_op_op_add: root::octave_value_binary_op = 0;
    pub const octave_value_binary_op_op_sub: root::octave_value_binary_op = 1;
    pub const octave_value_binary_op_op_mul: root::octave_value_binary_op = 2;
    pub const octave_value_binary_op_op_div: root::octave_value_binary_op = 3;
    pub const octave_value_binary_op_op_pow: root::octave_value_binary_op = 4;
    pub const octave_value_binary_op_op_ldiv: root::octave_value_binary_op = 5;
    pub const octave_value_binary_op_op_lt: root::octave_value_binary_op = 6;
    pub const octave_value_binary_op_op_le: root::octave_value_binary_op = 7;
    pub const octave_value_binary_op_op_eq: root::octave_value_binary_op = 8;
    pub const octave_value_binary_op_op_ge: root::octave_value_binary_op = 9;
    pub const octave_value_binary_op_op_gt: root::octave_value_binary_op = 10;
    pub const octave_value_binary_op_op_ne: root::octave_value_binary_op = 11;
    pub const octave_value_binary_op_op_el_mul: root::octave_value_binary_op = 12;
    pub const octave_value_binary_op_op_el_div: root::octave_value_binary_op = 13;
    pub const octave_value_binary_op_op_el_pow: root::octave_value_binary_op = 14;
    pub const octave_value_binary_op_op_el_ldiv: root::octave_value_binary_op = 15;
    pub const octave_value_binary_op_op_el_and: root::octave_value_binary_op = 16;
    pub const octave_value_binary_op_op_el_or: root::octave_value_binary_op = 17;
    pub const octave_value_binary_op_op_struct_ref: root::octave_value_binary_op = 18;
    pub const octave_value_binary_op_num_binary_ops: root::octave_value_binary_op = 19;
    pub const octave_value_binary_op_unknown_binary_op: root::octave_value_binary_op = 20;
    pub type octave_value_binary_op = u32;
    pub const octave_value_compound_binary_op_op_trans_mul: root::octave_value_compound_binary_op =
        0;
    pub const octave_value_compound_binary_op_op_mul_trans: root::octave_value_compound_binary_op =
        1;
    pub const octave_value_compound_binary_op_op_herm_mul: root::octave_value_compound_binary_op =
        2;
    pub const octave_value_compound_binary_op_op_mul_herm: root::octave_value_compound_binary_op =
        3;
    pub const octave_value_compound_binary_op_op_trans_ldiv: root::octave_value_compound_binary_op =
        4;
    pub const octave_value_compound_binary_op_op_herm_ldiv: root::octave_value_compound_binary_op =
        5;
    pub const octave_value_compound_binary_op_op_el_not_and: root::octave_value_compound_binary_op =
        6;
    pub const octave_value_compound_binary_op_op_el_not_or: root::octave_value_compound_binary_op =
        7;
    pub const octave_value_compound_binary_op_op_el_and_not: root::octave_value_compound_binary_op =
        8;
    pub const octave_value_compound_binary_op_op_el_or_not: root::octave_value_compound_binary_op =
        9;
    pub const octave_value_compound_binary_op_num_compound_binary_ops:
        root::octave_value_compound_binary_op = 10;
    pub const octave_value_compound_binary_op_unknown_compound_binary_op:
        root::octave_value_compound_binary_op = 11;
    pub type octave_value_compound_binary_op = u32;
    pub const octave_value_assign_op_op_asn_eq: root::octave_value_assign_op = 0;
    pub const octave_value_assign_op_op_add_eq: root::octave_value_assign_op = 1;
    pub const octave_value_assign_op_op_sub_eq: root::octave_value_assign_op = 2;
    pub const octave_value_assign_op_op_mul_eq: root::octave_value_assign_op = 3;
    pub const octave_value_assign_op_op_div_eq: root::octave_value_assign_op = 4;
    pub const octave_value_assign_op_op_ldiv_eq: root::octave_value_assign_op = 5;
    pub const octave_value_assign_op_op_pow_eq: root::octave_value_assign_op = 6;
    pub const octave_value_assign_op_op_el_mul_eq: root::octave_value_assign_op = 7;
    pub const octave_value_assign_op_op_el_div_eq: root::octave_value_assign_op = 8;
    pub const octave_value_assign_op_op_el_ldiv_eq: root::octave_value_assign_op = 9;
    pub const octave_value_assign_op_op_el_pow_eq: root::octave_value_assign_op = 10;
    pub const octave_value_assign_op_op_el_and_eq: root::octave_value_assign_op = 11;
    pub const octave_value_assign_op_op_el_or_eq: root::octave_value_assign_op = 12;
    pub const octave_value_assign_op_num_assign_ops: root::octave_value_assign_op = 13;
    pub const octave_value_assign_op_unknown_assign_op: root::octave_value_assign_op = 14;
    pub type octave_value_assign_op = u32;
    pub const octave_value_magic_colon_magic_colon_t: root::octave_value_magic_colon = 0;
    pub type octave_value_magic_colon = u32;
    #[test]
    fn bindgen_test_layout_octave_value() {
        assert_eq!(
            ::core::mem::size_of::<octave_value>(),
            8usize,
            concat!("Size of: ", stringify!(octave_value))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_value>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_value))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_value>())).rep as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_value),
                "::",
                stringify!(rep)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value22assign_op_to_binary_opENS_9assign_opE"]
        pub fn octave_value_assign_op_to_binary_op(
            arg1: root::octave_value_assign_op,
        ) -> root::octave_value_binary_op;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value22binary_op_to_assign_opENS_9binary_opE"]
        pub fn octave_value_binary_op_to_assign_op(
            arg1: root::octave_value_binary_op,
        ) -> root::octave_value_assign_op;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value18unary_op_as_stringB5cxx11ENS_8unary_opE"]
        pub fn octave_value_unary_op_as_string(
            arg1: root::octave_value_unary_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value17unary_op_fcn_nameB5cxx11ENS_8unary_opE"]
        pub fn octave_value_unary_op_fcn_name(
            arg1: root::octave_value_unary_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value19binary_op_as_stringB5cxx11ENS_9binary_opE"]
        pub fn octave_value_binary_op_as_string(
            arg1: root::octave_value_binary_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value18binary_op_fcn_nameB5cxx11ENS_9binary_opE"]
        pub fn octave_value_binary_op_fcn_name(
            arg1: root::octave_value_binary_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value18binary_op_fcn_nameB5cxx11ENS_18compound_binary_opE"]
        pub fn octave_value_binary_op_fcn_name1(
            arg1: root::octave_value_compound_binary_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value19assign_op_as_stringB5cxx11ENS_9assign_opE"]
        pub fn octave_value_assign_op_as_string(
            arg1: root::octave_value_assign_op,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value10empty_convERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS_"]
        pub fn octave_value_empty_conv(
            type_: *const root::std::string,
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value5cloneEv"]
        pub fn octave_value_clone(this: *const root::octave_value) -> *mut root::octave_base_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value12maybe_mutateEv"]
        pub fn octave_value_maybe_mutate(this: *mut root::octave_value);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value14single_subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK17octave_value_list"]
        pub fn octave_value_single_subsref(
            this: *mut root::octave_value,
            type_: *const root::std::string,
            idx: *const root::octave_value_list,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value7subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEi"]
        pub fn octave_value_subsref(
            this: *mut root::octave_value,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            nargout: ::std::os::raw::c_int,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value12next_subsrefERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEm"]
        pub fn octave_value_next_subsref(
            this: *mut root::octave_value,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value12next_subsrefEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEm"]
        pub fn octave_value_next_subsref1(
            this: *mut root::octave_value,
            nargout: ::std::os::raw::c_int,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value12next_subsrefEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEEm"]
        pub fn octave_value_next_subsref2(
            this: *mut root::octave_value,
            auto_add: bool,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value8subsasgnERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEERKS_"]
        pub fn octave_value_subsasgn(
            this: *mut root::octave_value,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value14undef_subsasgnERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4listI17octave_value_listSaIS9_EEERKS_"]
        pub fn octave_value_undef_subsasgn(
            this: *mut root::octave_value,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value6assignENS_9assign_opERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS1_4listI17octave_value_listSaISA_EEERKS_"]
        pub fn octave_value_assign(
            this: *mut root::octave_value,
            op: root::octave_value_assign_op,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value6assignENS_9assign_opERKS_"]
        pub fn octave_value_assign1(
            this: *mut root::octave_value,
            arg1: root::octave_value_assign_op,
            rhs: *const root::octave_value,
        ) -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12get_dims_strB5cxx11Ev"]
        pub fn octave_value_get_dims_str(this: *const root::octave_value) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value6lengthEv"]
        pub fn octave_value_length(this: *const root::octave_value) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value8is_equalERKS_"]
        pub fn octave_value_is_equal(
            this: *const root::octave_value,
            arg1: *const root::octave_value,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value14idx_type_valueEbb"]
        pub fn octave_value_idx_type_value(
            this: *const root::octave_value,
            req_int: bool,
            frc_str_conv: bool,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value10cell_valueEv"]
        pub fn octave_value_cell_value(this: *const root::octave_value) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value9map_valueEv"]
        pub fn octave_value_map_value(this: *const root::octave_value) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16scalar_map_valueEv"]
        pub fn octave_value_scalar_map_value(
            this: *const root::octave_value,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value21classdef_object_valueEb"]
        pub fn octave_value_classdef_object_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_classdef;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value14function_valueEb"]
        pub fn octave_value_function_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19user_function_valueEb"]
        pub fn octave_value_user_function_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17user_script_valueEb"]
        pub fn octave_value_user_script_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value15user_code_valueEb"]
        pub fn octave_value_user_code_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16fcn_handle_valueEb"]
        pub fn octave_value_fcn_handle_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16fcn_inline_valueEb"]
        pub fn octave_value_fcn_inline_value(
            this: *const root::octave_value,
            silent: bool,
        ) -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value10list_valueEv"]
        pub fn octave_value_list_value(this: *const root::octave_value) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19column_vector_valueEbb"]
        pub fn octave_value_column_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value27complex_column_vector_valueEbb"]
        pub fn octave_value_complex_column_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16row_vector_valueEbb"]
        pub fn octave_value_row_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value24complex_row_vector_valueEbb"]
        pub fn octave_value_complex_row_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value25float_column_vector_valueEbb"]
        pub fn octave_value_float_column_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value33float_complex_column_vector_valueEbb"]
        pub fn octave_value_float_complex_column_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value22float_row_vector_valueEbb"]
        pub fn octave_value_float_row_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value30float_complex_row_vector_valueEbb"]
        pub fn octave_value_float_complex_row_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16int_vector_valueEbbb"]
        pub fn octave_value_int_vector_value(
            this: *const root::octave_value,
            req_int: bool,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value28octave_idx_type_vector_valueEbbb"]
        pub fn octave_value_octave_idx_type_vector_value(
            this: *const root::octave_value,
            req_int: bool,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12vector_valueEbb"]
        pub fn octave_value_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20complex_vector_valueEbb"]
        pub fn octave_value_complex_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::Complex>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18float_vector_valueEbb"]
        pub fn octave_value_float_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value26float_complex_vector_valueEbb"]
        pub fn octave_value_float_complex_vector_value(
            this: *const root::octave_value,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::FloatComplex>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xshort_valueEPKcz"]
        pub fn octave_value_xshort_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_short;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xushort_valueEPKcz"]
        pub fn octave_value_xushort_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_ushort;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value10xint_valueEPKcz"]
        pub fn octave_value_xint_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xuint_valueEPKcz"]
        pub fn octave_value_xuint_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xnint_valueEPKcz"]
        pub fn octave_value_xnint_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xlong_valueEPKcz"]
        pub fn octave_value_xlong_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xulong_valueEPKcz"]
        pub fn octave_value_xulong_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xint64_valueEPKcz"]
        pub fn octave_value_xint64_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> i64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xuint64_valueEPKcz"]
        pub fn octave_value_xuint64_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> u64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value15xidx_type_valueEPKcz"]
        pub fn octave_value_xidx_type_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xdouble_valueEPKcz"]
        pub fn octave_value_xdouble_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xfloat_valueEPKcz"]
        pub fn octave_value_xfloat_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xscalar_valueEPKcz"]
        pub fn octave_value_xscalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xfloat_scalar_valueEPKcz"]
        pub fn octave_value_xfloat_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xmatrix_valueEPKcz"]
        pub fn octave_value_xmatrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Matrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xfloat_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xarray_valueEPKcz"]
        pub fn octave_value_xarray_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xfloat_array_valueEPKcz"]
        pub fn octave_value_xfloat_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value14xcomplex_valueEPKcz"]
        pub fn octave_value_xcomplex_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Complex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xfloat_complex_valueEPKcz"]
        pub fn octave_value_xfloat_complex_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplex;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value21xcomplex_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value27xfloat_complex_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xcomplex_array_valueEPKcz"]
        pub fn octave_value_xcomplex_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value26xfloat_complex_array_valueEPKcz"]
        pub fn octave_value_xfloat_complex_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplexNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xbool_valueEPKcz"]
        pub fn octave_value_xbool_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xbool_matrix_valueEPKcz"]
        pub fn octave_value_xbool_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::boolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xbool_array_valueEPKcz"]
        pub fn octave_value_xbool_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::boolNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xchar_matrix_valueEPKcz"]
        pub fn octave_value_xchar_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::charMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xchar_array_valueEPKcz"]
        pub fn octave_value_xchar_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::charNDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xsparse_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::SparseMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value28xsparse_complex_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_complex_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::SparseComplexMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value25xsparse_bool_matrix_valueEPKcz"]
        pub fn octave_value_xsparse_bool_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::SparseBoolMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xdiag_matrix_valueEPKcz"]
        pub fn octave_value_xdiag_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::DiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value24xfloat_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_diag_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value26xcomplex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xcomplex_diag_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value32xfloat_complex_diag_matrix_valueEPKcz"]
        pub fn octave_value_xfloat_complex_diag_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplexDiagMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xperm_matrix_valueEPKcz"]
        pub fn octave_value_xperm_matrix_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::PermMatrix;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xint8_scalar_valueEPKcz"]
        pub fn octave_value_xint8_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_int8;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xint16_scalar_valueEPKcz"]
        pub fn octave_value_xint16_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_int16;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xint32_scalar_valueEPKcz"]
        pub fn octave_value_xint32_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_int32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xint64_scalar_valueEPKcz"]
        pub fn octave_value_xint64_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_int64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xuint8_scalar_valueEPKcz"]
        pub fn octave_value_xuint8_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_uint8;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xuint16_scalar_valueEPKcz"]
        pub fn octave_value_xuint16_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_uint16;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xuint32_scalar_valueEPKcz"]
        pub fn octave_value_xuint32_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_uint32;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xuint64_scalar_valueEPKcz"]
        pub fn octave_value_xuint64_scalar_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_uint64;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xint8_array_valueEPKcz"]
        pub fn octave_value_xint8_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::int8NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xint16_array_valueEPKcz"]
        pub fn octave_value_xint16_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::int16NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xint32_array_valueEPKcz"]
        pub fn octave_value_xint32_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::int32NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xint64_array_valueEPKcz"]
        pub fn octave_value_xint64_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::int64NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xuint8_array_valueEPKcz"]
        pub fn octave_value_xuint8_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::uint8NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xuint16_array_valueEPKcz"]
        pub fn octave_value_xuint16_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::uint16NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xuint32_array_valueEPKcz"]
        pub fn octave_value_xuint32_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::uint32NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xuint64_array_valueEPKcz"]
        pub fn octave_value_xuint64_array_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::uint64NDArray;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xstring_valueB5cxx11EPKcz"]
        pub fn octave_value_xstring_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xstring_vector_valueEPKcz"]
        pub fn octave_value_xstring_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xcell_valueEPKcz"]
        pub fn octave_value_xcell_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value14xcellstr_valueB5cxx11EPKcz"]
        pub fn octave_value_xcellstr_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<root::std::string>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value12xrange_valueEPKcz"]
        pub fn octave_value_xrange_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Range;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value10xmap_valueEPKcz"]
        pub fn octave_value_xmap_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xscalar_map_valueEPKcz"]
        pub fn octave_value_xscalar_map_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xcolumn_vector_valueEPKcz"]
        pub fn octave_value_xcolumn_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value28xcomplex_column_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_column_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xrow_vector_valueEPKcz"]
        pub fn octave_value_xrow_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::RowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value25xcomplex_row_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_row_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::ComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value26xfloat_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_column_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value34xfloat_complex_column_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_column_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplexColumnVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value23xfloat_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_row_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value31xfloat_complex_row_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_row_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::FloatComplexRowVector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xint_vector_valueEPKcz"]
        pub fn octave_value_xint_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<::std::os::raw::c_int>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value29xoctave_idx_type_vector_valueEPKcz"]
        pub fn octave_value_xoctave_idx_type_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<root::octave_idx_type>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value13xvector_valueEPKcz"]
        pub fn octave_value_xvector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<f64>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value21xcomplex_vector_valueEPKcz"]
        pub fn octave_value_xcomplex_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<root::Complex>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value19xfloat_vector_valueEPKcz"]
        pub fn octave_value_xfloat_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<f32>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value27xfloat_complex_vector_valueEPKcz"]
        pub fn octave_value_xfloat_complex_vector_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::Array<root::FloatComplex>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value15xfunction_valueEPKcz"]
        pub fn octave_value_xfunction_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value20xuser_function_valueEPKcz"]
        pub fn octave_value_xuser_function_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_user_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value18xuser_script_valueEPKcz"]
        pub fn octave_value_xuser_script_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_user_script;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value16xuser_code_valueEPKcz"]
        pub fn octave_value_xuser_code_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_user_code;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xfcn_handle_valueEPKcz"]
        pub fn octave_value_xfcn_handle_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_fcn_handle;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value17xfcn_inline_valueEPKcz"]
        pub fn octave_value_xfcn_inline_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *mut root::octave_fcn_inline;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value11xlist_valueEPKcz"]
        pub fn octave_value_xlist_value(
            this: *const root::octave_value,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value14storable_valueEv"]
        pub fn octave_value_storable_value(this: *const root::octave_value) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value19make_storable_valueEv"]
        pub fn octave_value_make_storable_value(this: *mut root::octave_value);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value23get_edit_display_formatEv"]
        pub fn octave_value_get_edit_display_format(
            this: *const root::octave_value,
        ) -> root::float_display_format;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value21do_non_const_unary_opENS_8unary_opE"]
        pub fn octave_value_do_non_const_unary_op(
            this: *mut root::octave_value,
            op: root::octave_value_unary_op,
        ) -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_value21do_non_const_unary_opENS_8unary_opERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS1_4listI17octave_value_listSaISA_EEE"]
        pub fn octave_value_do_non_const_unary_op1(
            this: *mut root::octave_value,
            op: root::octave_value_unary_op,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
        ) -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value10print_infoERSoRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_value_print_info(
            this: *const root::octave_value,
            os: *mut root::std::ostream,
            prefix: *const root::std::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12octave_value5writeERN6octave6streamEiN13oct_data_conv9data_typeEiNS0_9mach_info12float_formatE"]
        pub fn octave_value_write(
            this: *const root::octave_value,
            os: *mut root::octave::stream,
            block_size: ::std::os::raw::c_int,
            output_type: root::oct_data_conv_data_type,
            skip: ::std::os::raw::c_int,
            flt_fmt: root::octave::mach_info::float_format,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Es"]
        pub fn octave_value_octave_value(this: *mut root::octave_value, i: ::std::os::raw::c_short);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Et"]
        pub fn octave_value_octave_value1(
            this: *mut root::octave_value,
            i: ::std::os::raw::c_ushort,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ei"]
        pub fn octave_value_octave_value2(this: *mut root::octave_value, i: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ej"]
        pub fn octave_value_octave_value3(this: *mut root::octave_value, i: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1El"]
        pub fn octave_value_octave_value4(this: *mut root::octave_value, i: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Em"]
        pub fn octave_value_octave_value5(
            this: *mut root::octave_value,
            i: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ex"]
        pub fn octave_value_octave_value6(
            this: *mut root::octave_value,
            i: ::std::os::raw::c_longlong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ey"]
        pub fn octave_value_octave_value7(
            this: *mut root::octave_value,
            i: ::std::os::raw::c_ulonglong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1EN6octave3sys4timeE"]
        pub fn octave_value_octave_value8(
            this: *mut root::octave_value,
            t: root::octave::sys::time,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ed"]
        pub fn octave_value_octave_value9(this: *mut root::octave_value, d: f64);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ef"]
        pub fn octave_value_octave_value10(this: *mut root::octave_value, d: f32);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIS_Eb"]
        pub fn octave_value_octave_value11(
            this: *mut root::octave_value,
            a: *const root::Array<root::octave_value>,
            is_cs_list: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK4Cellb"]
        pub fn octave_value_octave_value12(
            this: *mut root::octave_value,
            c: *const root::Cell,
            is_cs_list: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK6MatrixRK10MatrixType"]
        pub fn octave_value_octave_value13(
            this: *mut root::octave_value,
            m: *const root::Matrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK11FloatMatrixRK10MatrixType"]
        pub fn octave_value_octave_value14(
            this: *mut root::octave_value,
            m: *const root::FloatMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK7NDArray"]
        pub fn octave_value_octave_value15(
            this: *mut root::octave_value,
            nda: *const root::NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK12FloatNDArray"]
        pub fn octave_value_octave_value16(
            this: *mut root::octave_value,
            nda: *const root::FloatNDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIdE"]
        pub fn octave_value_octave_value17(
            this: *mut root::octave_value,
            m: *const root::Array<f64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIfE"]
        pub fn octave_value_octave_value18(
            this: *mut root::octave_value,
            m: *const root::Array<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10DiagMatrix"]
        pub fn octave_value_octave_value19(
            this: *mut root::octave_value,
            d: *const root::DiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10DiagArray2IdE"]
        pub fn octave_value_octave_value20(
            this: *mut root::octave_value,
            d: *const root::DiagArray2<f64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10DiagArray2IfE"]
        pub fn octave_value_octave_value21(
            this: *mut root::octave_value,
            d: *const root::DiagArray2<f32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10DiagArray2ISt7complexIdEE"]
        pub fn octave_value_octave_value22(
            this: *mut root::octave_value,
            d: *const root::DiagArray2<root::Complex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10DiagArray2ISt7complexIfEE"]
        pub fn octave_value_octave_value23(
            this: *mut root::octave_value,
            d: *const root::DiagArray2<root::FloatComplex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK15FloatDiagMatrix"]
        pub fn octave_value_octave_value24(
            this: *mut root::octave_value,
            d: *const root::FloatDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK9RowVector"]
        pub fn octave_value_octave_value25(
            this: *mut root::octave_value,
            v: *const root::RowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK14FloatRowVector"]
        pub fn octave_value_octave_value26(
            this: *mut root::octave_value,
            v: *const root::FloatRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK12ColumnVector"]
        pub fn octave_value_octave_value27(
            this: *mut root::octave_value,
            v: *const root::ColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17FloatColumnVector"]
        pub fn octave_value_octave_value28(
            this: *mut root::octave_value,
            v: *const root::FloatColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERKSt7complexIdE"]
        pub fn octave_value_octave_value29(this: *mut root::octave_value, C: *const root::Complex);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERKSt7complexIfE"]
        pub fn octave_value_octave_value30(
            this: *mut root::octave_value,
            C: *const root::FloatComplex,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK13ComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value31(
            this: *mut root::octave_value,
            m: *const root::ComplexMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK18FloatComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value32(
            this: *mut root::octave_value,
            m: *const root::FloatComplexMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK14ComplexNDArray"]
        pub fn octave_value_octave_value33(
            this: *mut root::octave_value,
            cnda: *const root::ComplexNDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK19FloatComplexNDArray"]
        pub fn octave_value_octave_value34(
            this: *mut root::octave_value,
            cnda: *const root::FloatComplexNDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayISt7complexIdEE"]
        pub fn octave_value_octave_value35(
            this: *mut root::octave_value,
            m: *const root::Array<root::Complex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayISt7complexIfEE"]
        pub fn octave_value_octave_value36(
            this: *mut root::octave_value,
            m: *const root::Array<root::FloatComplex>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17ComplexDiagMatrix"]
        pub fn octave_value_octave_value37(
            this: *mut root::octave_value,
            d: *const root::ComplexDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK22FloatComplexDiagMatrix"]
        pub fn octave_value_octave_value38(
            this: *mut root::octave_value,
            d: *const root::FloatComplexDiagMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK16ComplexRowVector"]
        pub fn octave_value_octave_value39(
            this: *mut root::octave_value,
            v: *const root::ComplexRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK21FloatComplexRowVector"]
        pub fn octave_value_octave_value40(
            this: *mut root::octave_value,
            v: *const root::FloatComplexRowVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK19ComplexColumnVector"]
        pub fn octave_value_octave_value41(
            this: *mut root::octave_value,
            v: *const root::ComplexColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK24FloatComplexColumnVector"]
        pub fn octave_value_octave_value42(
            this: *mut root::octave_value,
            v: *const root::FloatComplexColumnVector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10PermMatrix"]
        pub fn octave_value_octave_value43(
            this: *mut root::octave_value,
            p: *const root::PermMatrix,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Eb"]
        pub fn octave_value_octave_value44(this: *mut root::octave_value, b: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10boolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value45(
            this: *mut root::octave_value,
            bm: *const root::boolMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK11boolNDArray"]
        pub fn octave_value_octave_value46(
            this: *mut root::octave_value,
            bnda: *const root::boolNDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIbE"]
        pub fn octave_value_octave_value47(
            this: *mut root::octave_value,
            bnda: *const root::Array<bool>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Ecc"]
        pub fn octave_value_octave_value48(
            this: *mut root::octave_value,
            c: ::std::os::raw::c_char,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1EPKcc"]
        pub fn octave_value_octave_value49(
            this: *mut root::octave_value,
            s: *const ::std::os::raw::c_char,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEc"]
        pub fn octave_value_octave_value50(
            this: *mut root::octave_value,
            s: *const root::std::string,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK13string_vectorc"]
        pub fn octave_value_octave_value51(
            this: *mut root::octave_value,
            s: *const root::string_vector,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10charMatrixc"]
        pub fn octave_value_octave_value52(
            this: *mut root::octave_value,
            chm: *const root::charMatrix,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK11charNDArrayc"]
        pub fn octave_value_octave_value53(
            this: *mut root::octave_value,
            chnda: *const root::charNDArray,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIcEc"]
        pub fn octave_value_octave_value54(
            this: *mut root::octave_value,
            chnda: *const root::Array<::std::os::raw::c_char>,
            type_: ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK12SparseMatrixRK10MatrixType"]
        pub fn octave_value_octave_value55(
            this: *mut root::octave_value,
            m: *const root::SparseMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK6SparseIdERK10MatrixType"]
        pub fn octave_value_octave_value56(
            this: *mut root::octave_value,
            m: *const root::Sparse<f64>,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK19SparseComplexMatrixRK10MatrixType"]
        pub fn octave_value_octave_value57(
            this: *mut root::octave_value,
            m: *const root::SparseComplexMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK6SparseISt7complexIdEERK10MatrixType"]
        pub fn octave_value_octave_value58(
            this: *mut root::octave_value,
            m: *const root::Sparse<root::Complex>,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK16SparseBoolMatrixRK10MatrixType"]
        pub fn octave_value_octave_value59(
            this: *mut root::octave_value,
            bm: *const root::SparseBoolMatrix,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK6SparseIbERK10MatrixType"]
        pub fn octave_value_octave_value60(
            this: *mut root::octave_value,
            m: *const root::Sparse<bool>,
            t: *const root::MatrixType,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIaE"]
        pub fn octave_value_octave_value61(
            this: *mut root::octave_value,
            i: *const root::octave_int8,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIsE"]
        pub fn octave_value_octave_value62(
            this: *mut root::octave_value,
            i: *const root::octave_int16,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIiE"]
        pub fn octave_value_octave_value63(
            this: *mut root::octave_value,
            i: *const root::octave_int32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIlE"]
        pub fn octave_value_octave_value64(
            this: *mut root::octave_value,
            i: *const root::octave_int64,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIhE"]
        pub fn octave_value_octave_value65(
            this: *mut root::octave_value,
            i: *const root::octave_uint8,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intItE"]
        pub fn octave_value_octave_value66(
            this: *mut root::octave_value,
            i: *const root::octave_uint16,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intIjE"]
        pub fn octave_value_octave_value67(
            this: *mut root::octave_value,
            i: *const root::octave_uint32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_intImE"]
        pub fn octave_value_octave_value68(
            this: *mut root::octave_value,
            i: *const root::octave_uint64,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value69(
            this: *mut root::octave_value,
            inda: *const root::int8NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIaEE"]
        pub fn octave_value_octave_value70(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_int8>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value71(
            this: *mut root::octave_value,
            inda: *const root::int16NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIsEE"]
        pub fn octave_value_octave_value72(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_int16>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value73(
            this: *mut root::octave_value,
            inda: *const root::int32NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIiEE"]
        pub fn octave_value_octave_value74(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_int32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIlEE"]
        pub fn octave_value_octave_value75(
            this: *mut root::octave_value,
            inda: *const root::int64NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIlEE"]
        pub fn octave_value_octave_value76(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_int64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value77(
            this: *mut root::octave_value,
            inda: *const root::uint8NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIhEE"]
        pub fn octave_value_octave_value78(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_uint8>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intItEE"]
        pub fn octave_value_octave_value79(
            this: *mut root::octave_value,
            inda: *const root::uint16NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intItEE"]
        pub fn octave_value_octave_value80(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_uint16>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value81(
            this: *mut root::octave_value,
            inda: *const root::uint32NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intIjEE"]
        pub fn octave_value_octave_value82(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_uint32>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10intNDArrayI10octave_intImEE"]
        pub fn octave_value_octave_value83(
            this: *mut root::octave_value,
            inda: *const root::uint64NDArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayI10octave_intImEE"]
        pub fn octave_value_octave_value84(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_uint64>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayIlEbb"]
        pub fn octave_value_octave_value85(
            this: *mut root::octave_value,
            inda: *const root::Array<root::octave_idx_type>,
            zero_based: bool,
            cache_index: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5ArrayINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE"]
        pub fn octave_value_octave_value86(
            this: *mut root::octave_value,
            cellstr: *const root::Array<root::std::string>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10idx_vectorb"]
        pub fn octave_value_octave_value87(
            this: *mut root::octave_value,
            idx: *const root::idx_vector,
            lazy: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1Eddd"]
        pub fn octave_value_octave_value88(
            this: *mut root::octave_value,
            base: f64,
            limit: f64,
            inc: f64,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK5Rangeb"]
        pub fn octave_value_octave_value89(
            this: *mut root::octave_value,
            r: *const root::Range,
            force_range: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_map"]
        pub fn octave_value_octave_value90(
            this: *mut root::octave_value,
            m: *const root::octave_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17octave_scalar_map"]
        pub fn octave_value_octave_value91(
            this: *mut root::octave_value,
            m: *const root::octave_scalar_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES_St4lessIS6_ESaISt4pairIKS6_S_EEE"]
        pub fn octave_value_octave_value92(
            this: *mut root::octave_value,
            arg1: *const [u64; 6usize],
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK10octave_mapRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS3_4listIS8_SaIS8_EEE"]
        pub fn octave_value_octave_value93(
            this: *mut root::octave_value,
            m: *const root::octave_map,
            id: *const root::std::string,
            plist: *const [u64; 3usize],
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17octave_scalar_mapRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS3_4listIS8_SaIS8_EEE"]
        pub fn octave_value_octave_value94(
            this: *mut root::octave_value,
            m: *const root::octave_scalar_map,
            id: *const root::std::string,
            plist: *const [u64; 3usize],
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17octave_value_listb"]
        pub fn octave_value_octave_value95(
            this: *mut root::octave_value,
            m: *const root::octave_value_list,
            arg1: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ERK17octave_value_list"]
        pub fn octave_value_octave_value96(
            this: *mut root::octave_value,
            m: *const root::octave_value_list,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1ENS_11magic_colonE"]
        pub fn octave_value_octave_value97(
            this: *mut root::octave_value,
            arg1: root::octave_value_magic_colon,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12octave_valueC1EP17octave_base_valueb"]
        pub fn octave_value_octave_value98(
            this: *mut root::octave_value,
            new_rep: *mut root::octave_base_value,
            borrow: bool,
        );
    }
    impl octave_value {
        #[inline]
        pub unsafe fn assign_op_to_binary_op(
            arg1: root::octave_value_assign_op,
        ) -> root::octave_value_binary_op {
            octave_value_assign_op_to_binary_op(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_to_assign_op(
            arg1: root::octave_value_binary_op,
        ) -> root::octave_value_assign_op {
            octave_value_binary_op_to_assign_op(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_as_string(arg1: root::octave_value_unary_op) -> root::std::string {
            octave_value_unary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn unary_op_fcn_name(arg1: root::octave_value_unary_op) -> root::std::string {
            octave_value_unary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_as_string(arg1: root::octave_value_binary_op) -> root::std::string {
            octave_value_binary_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name(arg1: root::octave_value_binary_op) -> root::std::string {
            octave_value_binary_op_fcn_name(arg1)
        }
        #[inline]
        pub unsafe fn binary_op_fcn_name1(
            arg1: root::octave_value_compound_binary_op,
        ) -> root::std::string {
            octave_value_binary_op_fcn_name1(arg1)
        }
        #[inline]
        pub unsafe fn assign_op_as_string(arg1: root::octave_value_assign_op) -> root::std::string {
            octave_value_assign_op_as_string(arg1)
        }
        #[inline]
        pub unsafe fn empty_conv(
            type_: *const root::std::string,
            rhs: *const root::octave_value,
        ) -> root::octave_value {
            octave_value_empty_conv(type_, rhs)
        }
        #[inline]
        pub unsafe fn clone(&self) -> *mut root::octave_base_value {
            octave_value_clone(self)
        }
        #[inline]
        pub unsafe fn maybe_mutate(&mut self) {
            octave_value_maybe_mutate(self)
        }
        #[inline]
        pub unsafe fn single_subsref(
            &mut self,
            type_: *const root::std::string,
            idx: *const root::octave_value_list,
        ) -> root::octave_value {
            octave_value_single_subsref(self, type_, idx)
        }
        #[inline]
        pub unsafe fn subsref(
            &mut self,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            nargout: ::std::os::raw::c_int,
        ) -> root::octave_value_list {
            octave_value_subsref(self, type_, idx, nargout)
        }
        #[inline]
        pub unsafe fn next_subsref(
            &mut self,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value {
            octave_value_next_subsref(self, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref1(
            &mut self,
            nargout: ::std::os::raw::c_int,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value_list {
            octave_value_next_subsref1(self, nargout, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn next_subsref2(
            &mut self,
            auto_add: bool,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            skip: usize,
        ) -> root::octave_value {
            octave_value_next_subsref2(self, auto_add, type_, idx, skip)
        }
        #[inline]
        pub unsafe fn subsasgn(
            &mut self,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value {
            octave_value_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn undef_subsasgn(
            &mut self,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> root::octave_value {
            octave_value_undef_subsasgn(self, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign(
            &mut self,
            op: root::octave_value_assign_op,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
            rhs: *const root::octave_value,
        ) -> *mut root::octave_value {
            octave_value_assign(self, op, type_, idx, rhs)
        }
        #[inline]
        pub unsafe fn assign1(
            &mut self,
            arg1: root::octave_value_assign_op,
            rhs: *const root::octave_value,
        ) -> *mut root::octave_value {
            octave_value_assign1(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn get_dims_str(&self) -> root::std::string {
            octave_value_get_dims_str(self)
        }
        #[inline]
        pub unsafe fn length(&self) -> root::octave_idx_type {
            octave_value_length(self)
        }
        #[inline]
        pub unsafe fn is_equal(&self, arg1: *const root::octave_value) -> bool {
            octave_value_is_equal(self, arg1)
        }
        #[inline]
        pub unsafe fn idx_type_value(
            &self,
            req_int: bool,
            frc_str_conv: bool,
        ) -> root::octave_idx_type {
            octave_value_idx_type_value(self, req_int, frc_str_conv)
        }
        #[inline]
        pub unsafe fn cell_value(&self) -> root::Cell {
            octave_value_cell_value(self)
        }
        #[inline]
        pub unsafe fn map_value(&self) -> root::octave_map {
            octave_value_map_value(self)
        }
        #[inline]
        pub unsafe fn scalar_map_value(&self) -> root::octave_scalar_map {
            octave_value_scalar_map_value(self)
        }
        #[inline]
        pub unsafe fn classdef_object_value(&self, silent: bool) -> *mut root::octave_classdef {
            octave_value_classdef_object_value(self, silent)
        }
        #[inline]
        pub unsafe fn function_value(&self, silent: bool) -> *mut root::octave_function {
            octave_value_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_function_value(&self, silent: bool) -> *mut root::octave_user_function {
            octave_value_user_function_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_script_value(&self, silent: bool) -> *mut root::octave_user_script {
            octave_value_user_script_value(self, silent)
        }
        #[inline]
        pub unsafe fn user_code_value(&self, silent: bool) -> *mut root::octave_user_code {
            octave_value_user_code_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_handle_value(&self, silent: bool) -> *mut root::octave_fcn_handle {
            octave_value_fcn_handle_value(self, silent)
        }
        #[inline]
        pub unsafe fn fcn_inline_value(&self, silent: bool) -> *mut root::octave_fcn_inline {
            octave_value_fcn_inline_value(self, silent)
        }
        #[inline]
        pub unsafe fn list_value(&self) -> root::octave_value_list {
            octave_value_list_value(self)
        }
        #[inline]
        pub unsafe fn column_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ColumnVector {
            octave_value_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_column_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ComplexColumnVector {
            octave_value_complex_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn row_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::RowVector {
            octave_value_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_row_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::ComplexRowVector {
            octave_value_complex_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_column_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatColumnVector {
            octave_value_float_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_column_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatComplexColumnVector {
            octave_value_float_complex_column_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_row_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatRowVector {
            octave_value_float_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_row_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::FloatComplexRowVector {
            octave_value_float_complex_row_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn int_vector_value(
            &self,
            req_int: bool,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<::std::os::raw::c_int> {
            octave_value_int_vector_value(self, req_int, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn octave_idx_type_vector_value(
            &self,
            req_int: bool,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::octave_idx_type> {
            octave_value_octave_idx_type_vector_value(self, req_int, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<f64> {
            octave_value_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn complex_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::Complex> {
            octave_value_complex_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<f32> {
            octave_value_float_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn float_complex_vector_value(
            &self,
            frc_str_conv: bool,
            frc_vec_conv: bool,
        ) -> root::Array<root::FloatComplex> {
            octave_value_float_complex_vector_value(self, frc_str_conv, frc_vec_conv)
        }
        #[inline]
        pub unsafe fn storable_value(&self) -> root::octave_value {
            octave_value_storable_value(self)
        }
        #[inline]
        pub unsafe fn make_storable_value(&mut self) {
            octave_value_make_storable_value(self)
        }
        #[inline]
        pub unsafe fn get_edit_display_format(&self) -> root::float_display_format {
            octave_value_get_edit_display_format(self)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op(
            &mut self,
            op: root::octave_value_unary_op,
        ) -> *mut root::octave_value {
            octave_value_do_non_const_unary_op(self, op)
        }
        #[inline]
        pub unsafe fn do_non_const_unary_op1(
            &mut self,
            op: root::octave_value_unary_op,
            type_: *const root::std::string,
            idx: *const [u64; 3usize],
        ) -> *mut root::octave_value {
            octave_value_do_non_const_unary_op1(self, op, type_, idx)
        }
        #[inline]
        pub unsafe fn print_info(
            &self,
            os: *mut root::std::ostream,
            prefix: *const root::std::string,
        ) {
            octave_value_print_info(self, os, prefix)
        }
        #[inline]
        pub unsafe fn write(
            &self,
            os: *mut root::octave::stream,
            block_size: ::std::os::raw::c_int,
            output_type: root::oct_data_conv_data_type,
            skip: ::std::os::raw::c_int,
            flt_fmt: root::octave::mach_info::float_format,
        ) -> ::std::os::raw::c_int {
            octave_value_write(self, os, block_size, output_type, skip, flt_fmt)
        }
        #[inline]
        pub unsafe fn new(i: ::std::os::raw::c_short) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(i: ::std::os::raw::c_ushort) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value1(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(i: ::std::os::raw::c_int) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value2(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(i: ::std::os::raw::c_uint) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value3(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(i: ::std::os::raw::c_long) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value4(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new5(i: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value5(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new6(i: ::std::os::raw::c_longlong) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value6(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new7(i: ::std::os::raw::c_ulonglong) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value7(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new8(t: root::octave::sys::time) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value8(&mut __bindgen_tmp, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new9(d: f64) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value9(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new10(d: f32) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value10(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new11(a: *const root::Array<root::octave_value>, is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value11(&mut __bindgen_tmp, a, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new12(c: *const root::Cell, is_cs_list: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value12(&mut __bindgen_tmp, c, is_cs_list);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new13(m: *const root::Matrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value13(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new14(m: *const root::FloatMatrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value14(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new15(nda: *const root::NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value15(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new16(nda: *const root::FloatNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value16(&mut __bindgen_tmp, nda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new17(m: *const root::Array<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value17(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new18(m: *const root::Array<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value18(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new19(d: *const root::DiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value19(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new20(d: *const root::DiagArray2<f64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value20(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new21(d: *const root::DiagArray2<f32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value21(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new22(d: *const root::DiagArray2<root::Complex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value22(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new23(d: *const root::DiagArray2<root::FloatComplex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value23(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new24(d: *const root::FloatDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value24(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new25(v: *const root::RowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value25(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new26(v: *const root::FloatRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value26(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new27(v: *const root::ColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value27(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new28(v: *const root::FloatColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value28(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new29(C: *const root::Complex) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value29(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new30(C: *const root::FloatComplex) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value30(&mut __bindgen_tmp, C);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new31(m: *const root::ComplexMatrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value31(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new32(
            m: *const root::FloatComplexMatrix,
            t: *const root::MatrixType,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value32(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new33(cnda: *const root::ComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value33(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new34(cnda: *const root::FloatComplexNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value34(&mut __bindgen_tmp, cnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new35(m: *const root::Array<root::Complex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value35(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new36(m: *const root::Array<root::FloatComplex>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value36(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new37(d: *const root::ComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value37(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new38(d: *const root::FloatComplexDiagMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value38(&mut __bindgen_tmp, d);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new39(v: *const root::ComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value39(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new40(v: *const root::FloatComplexRowVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value40(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new41(v: *const root::ComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value41(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new42(v: *const root::FloatComplexColumnVector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value42(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new43(p: *const root::PermMatrix) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value43(&mut __bindgen_tmp, p);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new44(b: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value44(&mut __bindgen_tmp, b);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new45(bm: *const root::boolMatrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value45(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new46(bnda: *const root::boolNDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value46(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new47(bnda: *const root::Array<bool>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value47(&mut __bindgen_tmp, bnda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new48(c: ::std::os::raw::c_char, type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value48(&mut __bindgen_tmp, c, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new49(
            s: *const ::std::os::raw::c_char,
            type_: ::std::os::raw::c_char,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value49(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new50(s: *const root::std::string, type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value50(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new51(s: *const root::string_vector, type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value51(&mut __bindgen_tmp, s, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new52(chm: *const root::charMatrix, type_: ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value52(&mut __bindgen_tmp, chm, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new53(
            chnda: *const root::charNDArray,
            type_: ::std::os::raw::c_char,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value53(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new54(
            chnda: *const root::Array<::std::os::raw::c_char>,
            type_: ::std::os::raw::c_char,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value54(&mut __bindgen_tmp, chnda, type_);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new55(m: *const root::SparseMatrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value55(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new56(m: *const root::Sparse<f64>, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value56(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new57(
            m: *const root::SparseComplexMatrix,
            t: *const root::MatrixType,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value57(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new58(
            m: *const root::Sparse<root::Complex>,
            t: *const root::MatrixType,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value58(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new59(bm: *const root::SparseBoolMatrix, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value59(&mut __bindgen_tmp, bm, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new60(m: *const root::Sparse<bool>, t: *const root::MatrixType) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value60(&mut __bindgen_tmp, m, t);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new61(i: *const root::octave_int8) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value61(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new62(i: *const root::octave_int16) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value62(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new63(i: *const root::octave_int32) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value63(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new64(i: *const root::octave_int64) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value64(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new65(i: *const root::octave_uint8) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value65(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new66(i: *const root::octave_uint16) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value66(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new67(i: *const root::octave_uint32) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value67(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new68(i: *const root::octave_uint64) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value68(&mut __bindgen_tmp, i);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new69(inda: *const root::int8NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value69(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new70(inda: *const root::Array<root::octave_int8>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value70(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new71(inda: *const root::int16NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value71(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new72(inda: *const root::Array<root::octave_int16>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value72(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new73(inda: *const root::int32NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value73(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new74(inda: *const root::Array<root::octave_int32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value74(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new75(inda: *const root::int64NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value75(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new76(inda: *const root::Array<root::octave_int64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value76(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new77(inda: *const root::uint8NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value77(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new78(inda: *const root::Array<root::octave_uint8>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value78(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new79(inda: *const root::uint16NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value79(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new80(inda: *const root::Array<root::octave_uint16>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value80(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new81(inda: *const root::uint32NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value81(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new82(inda: *const root::Array<root::octave_uint32>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value82(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new83(inda: *const root::uint64NDArray) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value83(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new84(inda: *const root::Array<root::octave_uint64>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value84(&mut __bindgen_tmp, inda);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new85(
            inda: *const root::Array<root::octave_idx_type>,
            zero_based: bool,
            cache_index: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value85(&mut __bindgen_tmp, inda, zero_based, cache_index);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new86(cellstr: *const root::Array<root::std::string>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value86(&mut __bindgen_tmp, cellstr);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new87(idx: *const root::idx_vector, lazy: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value87(&mut __bindgen_tmp, idx, lazy);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new88(base: f64, limit: f64, inc: f64) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value88(&mut __bindgen_tmp, base, limit, inc);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new89(r: *const root::Range, force_range: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value89(&mut __bindgen_tmp, r, force_range);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new90(m: *const root::octave_map) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value90(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new91(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value91(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new92(arg1: *const [u64; 6usize]) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value92(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new93(
            m: *const root::octave_map,
            id: *const root::std::string,
            plist: *const [u64; 3usize],
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value93(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new94(
            m: *const root::octave_scalar_map,
            id: *const root::std::string,
            plist: *const [u64; 3usize],
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value94(&mut __bindgen_tmp, m, id, plist);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new95(m: *const root::octave_value_list, arg1: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value95(&mut __bindgen_tmp, m, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new96(m: *const root::octave_value_list) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value96(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new97(arg1: root::octave_value_magic_colon) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value97(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new98(new_rep: *mut root::octave_base_value, borrow: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_octave_value98(&mut __bindgen_tmp, new_rep, borrow);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct Cell {
        pub _base: root::Array<root::octave_value>,
    }
    pub type Cell_ctype_mapper =
        ::core::option::Option<unsafe extern "C" fn() -> root::octave_value>;
    #[test]
    fn bindgen_test_layout_Cell() {
        assert_eq!(
            ::core::mem::size_of::<Cell>(),
            40usize,
            concat!("Size of: ", stringify!(Cell))
        );
        assert_eq!(
            ::core::mem::align_of::<Cell>(),
            8usize,
            concat!("Alignment of ", stringify!(Cell))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell9iscellstrEv"]
        pub fn Cell_iscellstr(this: *const root::Cell) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell13cellstr_valueB5cxx11Ev"]
        pub fn Cell_cellstr_value(this: *const root::Cell) -> root::Array<root::std::string>;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell19string_vector_valueEv"]
        pub fn Cell_string_vector_value(this: *const root::Cell) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell5indexERK17octave_value_listb"]
        pub fn Cell_index(
            this: *const root::Cell,
            idx: *const root::octave_value_list,
            resize_ok: bool,
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4Cell15delete_elementsERK17octave_value_list"]
        pub fn Cell_delete_elements(this: *mut root::Cell, idx: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4Cell6assignERK17octave_value_listRKS_RK12octave_value"]
        pub fn Cell_assign(
            this: *mut root::Cell,
            idx: *const root::octave_value_list,
            rhs: *const root::Cell,
            fill_val: *const root::octave_value,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell3nnzEv"]
        pub fn Cell_nnz(this: *const root::Cell) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell6columnEl"]
        pub fn Cell_column(this: *const root::Cell, i: root::octave_idx_type) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4Cell6concatERKS_RK5ArrayIlE"]
        pub fn Cell_concat(
            this: *mut root::Cell,
            rb: *const root::Cell,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4Cell6insertERKS_ll"]
        pub fn Cell_insert(
            this: *mut root::Cell,
            a: *const root::Cell,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4Cell6insertERKS_RK5ArrayIlE"]
        pub fn Cell_insert1(
            this: *mut root::Cell,
            a: *const root::Cell,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell4diagEl"]
        pub fn Cell_diag(this: *const root::Cell, k: root::octave_idx_type) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell4diagEll"]
        pub fn Cell_diag1(
            this: *const root::Cell,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4CellC1ERK17octave_value_list"]
        pub fn Cell_Cell(this: *mut root::Cell, ovl: *const root::octave_value_list);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4CellC1ERK13string_vectorb"]
        pub fn Cell_Cell1(this: *mut root::Cell, sv: *const root::string_vector, trim: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4CellC1ERK5ArrayINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE"]
        pub fn Cell_Cell2(this: *mut root::Cell, sa: *const root::Array<root::std::string>);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN4CellC1ERK10dim_vectorRK13string_vectorb"]
        pub fn Cell_Cell3(
            this: *mut root::Cell,
            dv: *const root::dim_vector,
            sv: *const root::string_vector,
            trim: bool,
        );
    }
    impl Cell {
        #[inline]
        pub unsafe fn iscellstr(&self) -> bool {
            Cell_iscellstr(self)
        }
        #[inline]
        pub unsafe fn cellstr_value(&self) -> root::Array<root::std::string> {
            Cell_cellstr_value(self)
        }
        #[inline]
        pub unsafe fn string_vector_value(&self) -> root::string_vector {
            Cell_string_vector_value(self)
        }
        #[inline]
        pub unsafe fn index(
            &self,
            idx: *const root::octave_value_list,
            resize_ok: bool,
        ) -> root::Cell {
            Cell_index(self, idx, resize_ok)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self, idx: *const root::octave_value_list) {
            Cell_delete_elements(self, idx)
        }
        #[inline]
        pub unsafe fn assign(
            &mut self,
            idx: *const root::octave_value_list,
            rhs: *const root::Cell,
            fill_val: *const root::octave_value,
        ) {
            Cell_assign(self, idx, rhs, fill_val)
        }
        #[inline]
        pub unsafe fn nnz(&self) -> root::octave_idx_type {
            Cell_nnz(self)
        }
        #[inline]
        pub unsafe fn column(&self, i: root::octave_idx_type) -> root::Cell {
            Cell_column(self, i)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::Cell,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::Cell {
            Cell_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            a: *const root::Cell,
            r: root::octave_idx_type,
            c: root::octave_idx_type,
        ) -> *mut root::Cell {
            Cell_insert(self, a, r, c)
        }
        #[inline]
        pub unsafe fn insert1(
            &mut self,
            a: *const root::Cell,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> *mut root::Cell {
            Cell_insert1(self, a, ra_idx)
        }
        #[inline]
        pub unsafe fn diag(&self, k: root::octave_idx_type) -> root::Cell {
            Cell_diag(self, k)
        }
        #[inline]
        pub unsafe fn diag1(
            &self,
            m: root::octave_idx_type,
            n: root::octave_idx_type,
        ) -> root::Cell {
            Cell_diag1(self, m, n)
        }
        #[inline]
        pub unsafe fn new(ovl: *const root::octave_value_list) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Cell_Cell(&mut __bindgen_tmp, ovl);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(sv: *const root::string_vector, trim: bool) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Cell_Cell1(&mut __bindgen_tmp, sv, trim);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(sa: *const root::Array<root::std::string>) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Cell_Cell2(&mut __bindgen_tmp, sa);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(
            dv: *const root::dim_vector,
            sv: *const root::string_vector,
            trim: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            Cell_Cell3(&mut __bindgen_tmp, dv, sv, trim);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK4Cell17resize_fill_valueEv"]
        pub fn Cell_resize_fill_value(this: *mut ::std::os::raw::c_void) -> root::octave_value;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_value_list {
        pub data: root::Array<root::octave_value>,
        pub names: root::string_vector,
    }
    #[test]
    fn bindgen_test_layout_octave_value_list() {
        assert_eq!(
            ::core::mem::size_of::<octave_value_list>(),
            80usize,
            concat!("Size of: ", stringify!(octave_value_list))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_value_list>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_value_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_value_list>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_value_list),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_value_list>())).names as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_value_list),
                "::",
                stringify!(names)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_list7prependERK12octave_value"]
        pub fn octave_value_list_prepend(
            this: *mut root::octave_value_list,
            val: *const root::octave_value,
        ) -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_list6appendERK12octave_value"]
        pub fn octave_value_list_append(
            this: *mut root::octave_value_list,
            val: *const root::octave_value,
        ) -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_list6appendERKS_"]
        pub fn octave_value_list_append1(
            this: *mut root::octave_value_list,
            lst: *const root::octave_value_list,
        ) -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_list7reverseEv"]
        pub fn octave_value_list_reverse(
            this: *mut root::octave_value_list,
        ) -> *mut root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list6spliceEllRKS_"]
        pub fn octave_value_list_splice(
            this: *const root::octave_value_list,
            offset: root::octave_idx_type,
            len: root::octave_idx_type,
            lst: *const root::octave_value_list,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list13all_strings_pEv"]
        pub fn octave_value_list_all_strings_p(this: *const root::octave_value_list) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list11all_scalarsEv"]
        pub fn octave_value_list_all_scalars(this: *const root::octave_value_list) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list8any_cellEv"]
        pub fn octave_value_list_any_cell(this: *const root::octave_value_list) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list15has_magic_colonEv"]
        pub fn octave_value_list_has_magic_colon(this: *const root::octave_value_list) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_value_list9make_argvERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_value_list_make_argv(
            this: *const root::octave_value_list,
            arg1: *const root::std::string,
        ) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_list20make_storable_valuesEv"]
        pub fn octave_value_list_make_storable_values(this: *mut root::octave_value_list);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_value_listC1ERKNSt7__cxx114listIS_SaIS_EEE"]
        pub fn octave_value_list_octave_value_list(
            this: *mut root::octave_value_list,
            arg1: *const [u64; 3usize],
        );
    }
    impl octave_value_list {
        #[inline]
        pub unsafe fn prepend(
            &mut self,
            val: *const root::octave_value,
        ) -> *mut root::octave_value_list {
            octave_value_list_prepend(self, val)
        }
        #[inline]
        pub unsafe fn append(
            &mut self,
            val: *const root::octave_value,
        ) -> *mut root::octave_value_list {
            octave_value_list_append(self, val)
        }
        #[inline]
        pub unsafe fn append1(
            &mut self,
            lst: *const root::octave_value_list,
        ) -> *mut root::octave_value_list {
            octave_value_list_append1(self, lst)
        }
        #[inline]
        pub unsafe fn reverse(&mut self) -> *mut root::octave_value_list {
            octave_value_list_reverse(self)
        }
        #[inline]
        pub unsafe fn splice(
            &self,
            offset: root::octave_idx_type,
            len: root::octave_idx_type,
            lst: *const root::octave_value_list,
        ) -> root::octave_value_list {
            octave_value_list_splice(self, offset, len, lst)
        }
        #[inline]
        pub unsafe fn all_strings_p(&self) -> bool {
            octave_value_list_all_strings_p(self)
        }
        #[inline]
        pub unsafe fn all_scalars(&self) -> bool {
            octave_value_list_all_scalars(self)
        }
        #[inline]
        pub unsafe fn any_cell(&self) -> bool {
            octave_value_list_any_cell(self)
        }
        #[inline]
        pub unsafe fn has_magic_colon(&self) -> bool {
            octave_value_list_has_magic_colon(self)
        }
        #[inline]
        pub unsafe fn make_argv(&self, arg1: *const root::std::string) -> root::string_vector {
            octave_value_list_make_argv(self, arg1)
        }
        #[inline]
        pub unsafe fn make_storable_values(&mut self) {
            octave_value_list_make_storable_values(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const [u64; 3usize]) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_value_list_octave_value_list(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_fields {
        pub rep: *mut root::octave_fields_fields_rep,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_fields_fields_rep {
        pub _base: [u64; 6usize],
        pub count: root::octave::refcount<::std::os::raw::c_int>,
    }
    #[test]
    fn bindgen_test_layout_octave_fields_fields_rep() {
        assert_eq!(
            ::core::mem::size_of::<octave_fields_fields_rep>(),
            56usize,
            concat!("Size of: ", stringify!(octave_fields_fields_rep))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_fields_fields_rep>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_fields_fields_rep))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_fields_fields_rep>())).count as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_fields_fields_rep),
                "::",
                stringify!(count)
            )
        );
    }
    pub type octave_fields_const_iterator = u64;
    pub type octave_fields_iterator = root::octave_fields_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_fields() {
        assert_eq!(
            ::core::mem::size_of::<octave_fields>(),
            8usize,
            concat!("Size of: ", stringify!(octave_fields))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_fields>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_fields))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_fields>())).rep as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_fields),
                "::",
                stringify!(rep)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13octave_fields7isfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_fields_isfield(
            this: *const root::octave_fields,
            name: *const root::std::string,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13octave_fields8getfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_fields_getfield(
            this: *const root::octave_fields,
            name: *const root::std::string,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13octave_fields8getfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_fields_getfield1(
            this: *mut root::octave_fields,
            name: *const root::std::string,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13octave_fields7rmfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_fields_rmfield(
            this: *mut root::octave_fields,
            name: *const root::std::string,
        ) -> root::octave_idx_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13octave_fields11orderfieldsER5ArrayIlE"]
        pub fn octave_fields_orderfields(
            this: *mut root::octave_fields,
            perm: *mut root::Array<root::octave_idx_type>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13octave_fields17equal_up_to_orderERKS_Pl"]
        pub fn octave_fields_equal_up_to_order(
            this: *const root::octave_fields,
            other: *const root::octave_fields,
            perm: *mut root::octave_idx_type,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13octave_fields17equal_up_to_orderERKS_R5ArrayIlE"]
        pub fn octave_fields_equal_up_to_order1(
            this: *const root::octave_fields,
            other: *const root::octave_fields,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13octave_fields10fieldnamesEv"]
        pub fn octave_fields_fieldnames(this: *const root::octave_fields) -> root::string_vector;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13octave_fieldsC1ERK13string_vector"]
        pub fn octave_fields_octave_fields(
            this: *mut root::octave_fields,
            arg1: *const root::string_vector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13octave_fieldsC1EPKPKc"]
        pub fn octave_fields_octave_fields1(
            this: *mut root::octave_fields,
            arg1: *const *const ::std::os::raw::c_char,
        );
    }
    impl octave_fields {
        #[inline]
        pub unsafe fn isfield(&self, name: *const root::std::string) -> bool {
            octave_fields_isfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield(&self, name: *const root::std::string) -> root::octave_idx_type {
            octave_fields_getfield(self, name)
        }
        #[inline]
        pub unsafe fn getfield1(
            &mut self,
            name: *const root::std::string,
        ) -> root::octave_idx_type {
            octave_fields_getfield1(self, name)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, name: *const root::std::string) -> root::octave_idx_type {
            octave_fields_rmfield(self, name)
        }
        #[inline]
        pub unsafe fn orderfields(&mut self, perm: *mut root::Array<root::octave_idx_type>) {
            octave_fields_orderfields(self, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order(
            &self,
            other: *const root::octave_fields,
            perm: *mut root::octave_idx_type,
        ) -> bool {
            octave_fields_equal_up_to_order(self, other, perm)
        }
        #[inline]
        pub unsafe fn equal_up_to_order1(
            &self,
            other: *const root::octave_fields,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> bool {
            octave_fields_equal_up_to_order1(self, other, perm)
        }
        #[inline]
        pub unsafe fn fieldnames(&self) -> root::string_vector {
            octave_fields_fieldnames(self)
        }
        #[inline]
        pub unsafe fn new(arg1: *const root::string_vector) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_fields_octave_fields(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_fields_octave_fields1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_scalar_map {
        pub xkeys: root::octave_fields,
        pub xvals: [u64; 3usize],
    }
    pub type octave_scalar_map_const_iterator = root::octave_fields_const_iterator;
    pub type octave_scalar_map_iterator = root::octave_scalar_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_scalar_map() {
        assert_eq!(
            ::core::mem::size_of::<octave_scalar_map>(),
            32usize,
            concat!("Size of: ", stringify!(octave_scalar_map))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_scalar_map>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_scalar_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_scalar_map>())).xkeys as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_scalar_map),
                "::",
                stringify!(xkeys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_scalar_map>())).xvals as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_scalar_map),
                "::",
                stringify!(xvals)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_scalar_map8getfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_scalar_map_getfield(
            this: *const root::octave_scalar_map,
            key: *const root::std::string,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_scalar_map8setfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK12octave_value"]
        pub fn octave_scalar_map_setfield(
            this: *mut root::octave_scalar_map,
            key: *const root::std::string,
            val: *const root::octave_value,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_scalar_map7rmfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_scalar_map_rmfield(
            this: *mut root::octave_scalar_map,
            key: *const root::std::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_scalar_map11orderfieldsEv"]
        pub fn octave_scalar_map_orderfields(
            this: *const root::octave_scalar_map,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_scalar_map11orderfieldsER5ArrayIlE"]
        pub fn octave_scalar_map_orderfields1(
            this: *const root::octave_scalar_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_scalar_map11orderfieldsERKS_R5ArrayIlE"]
        pub fn octave_scalar_map_orderfields2(
            this: *const root::octave_scalar_map,
            other: *const root::octave_scalar_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17octave_scalar_map8contentsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_scalar_map_contents(
            this: *const root::octave_scalar_map,
            k: *const root::std::string,
        ) -> root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_scalar_map8contentsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_scalar_map_contents1(
            this: *mut root::octave_scalar_map,
            k: *const root::std::string,
        ) -> *mut root::octave_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17octave_scalar_mapC1ERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE12octave_valueSt4lessIS6_ESaISt4pairIKS6_S7_EEE"]
        pub fn octave_scalar_map_octave_scalar_map(
            this: *mut root::octave_scalar_map,
            m: *const [u64; 6usize],
        );
    }
    impl octave_scalar_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string) -> root::octave_value {
            octave_scalar_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(
            &mut self,
            key: *const root::std::string,
            val: *const root::octave_value,
        ) {
            octave_scalar_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_scalar_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_scalar_map {
            octave_scalar_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(
            &self,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map {
            octave_scalar_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(
            &self,
            other: *const root::octave_scalar_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map {
            octave_scalar_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string) -> root::octave_value {
            octave_scalar_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string) -> *mut root::octave_value {
            octave_scalar_map_contents1(self, k)
        }
        #[inline]
        pub unsafe fn new(m: *const [u64; 6usize]) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_scalar_map_octave_scalar_map(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_map {
        pub xkeys: root::octave_fields,
        pub xvals: [u64; 3usize],
        pub dimensions: root::dim_vector,
    }
    pub type octave_map_element_type = root::octave_scalar_map;
    pub type octave_map_const_iterator = root::octave_fields_const_iterator;
    pub type octave_map_iterator = root::octave_map_const_iterator;
    #[test]
    fn bindgen_test_layout_octave_map() {
        assert_eq!(
            ::core::mem::size_of::<octave_map>(),
            40usize,
            concat!("Size of: ", stringify!(octave_map))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_map>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_map>())).xkeys as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_map),
                "::",
                stringify!(xkeys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_map>())).xvals as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_map),
                "::",
                stringify!(xvals)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_map>())).dimensions as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_map),
                "::",
                stringify!(dimensions)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map8getfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_map_getfield(
            this: *const root::octave_map,
            key: *const root::std::string,
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map8setfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK4Cell"]
        pub fn octave_map_setfield(
            this: *mut root::octave_map,
            key: *const root::std::string,
            val: *const root::Cell,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map7rmfieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_map_rmfield(this: *mut root::octave_map, key: *const root::std::string);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map11orderfieldsEv"]
        pub fn octave_map_orderfields(this: *const root::octave_map) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map11orderfieldsER5ArrayIlE"]
        pub fn octave_map_orderfields1(
            this: *const root::octave_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map11orderfieldsERKS_R5ArrayIlE"]
        pub fn octave_map_orderfields2(
            this: *const root::octave_map,
            other: *const root::octave_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map8contentsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_map_contents(
            this: *const root::octave_map,
            k: *const root::std::string,
        ) -> root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map8contentsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_map_contents1(
            this: *mut root::octave_map,
            k: *const root::std::string,
        ) -> *mut root::Cell;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map4elemEl"]
        pub fn octave_map_elem(
            this: *const root::octave_map,
            n: root::octave_idx_type,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map4elemEll"]
        pub fn octave_map_elem1(
            this: *const root::octave_map,
            i: root::octave_idx_type,
            j: root::octave_idx_type,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map4elemERK5ArrayIlE"]
        pub fn octave_map_elem2(
            this: *const root::octave_map,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map7squeezeEv"]
        pub fn octave_map_squeeze(this: *const root::octave_map) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map7permuteERK5ArrayIiEb"]
        pub fn octave_map_permute(
            this: *const root::octave_map,
            vec: *const root::Array<::std::os::raw::c_int>,
            inv: bool,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map9transposeEv"]
        pub fn octave_map_transpose(this: *const root::octave_map) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map7reshapeERK10dim_vector"]
        pub fn octave_map_reshape(
            this: *const root::octave_map,
            dv: *const root::dim_vector,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6resizeERK10dim_vectorb"]
        pub fn octave_map_resize(
            this: *mut root::octave_map,
            dv: *const root::dim_vector,
            fill: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map3catEilPK17octave_scalar_map"]
        pub fn octave_map_cat(
            dim: ::std::os::raw::c_int,
            n: root::octave_idx_type,
            map_list: *const root::octave_scalar_map,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map3catEilPKS_"]
        pub fn octave_map_cat1(
            dim: ::std::os::raw::c_int,
            n: root::octave_idx_type,
            map_list: *const root::octave_map,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map5indexERK10idx_vectorb"]
        pub fn octave_map_index(
            this: *const root::octave_map,
            i: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map5indexERK10idx_vectorS2_b"]
        pub fn octave_map_index1(
            this: *const root::octave_map,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map5indexERK5ArrayI10idx_vectorEb"]
        pub fn octave_map_index2(
            this: *const root::octave_map,
            ia: *const root::Array<root::idx_vector>,
            resize_ok: bool,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map5indexERK17octave_value_listb"]
        pub fn octave_map_index3(
            this: *const root::octave_map,
            arg1: *const root::octave_value_list,
            resize_ok: bool,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map6columnEl"]
        pub fn octave_map_column(
            this: *const root::octave_map,
            k: root::octave_idx_type,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map4pageEl"]
        pub fn octave_map_page(
            this: *const root::octave_map,
            k: root::octave_idx_type,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6assignERK10idx_vectorRKS_"]
        pub fn octave_map_assign(
            this: *mut root::octave_map,
            i: *const root::idx_vector,
            rhs: *const root::octave_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6assignERK10idx_vectorS2_RKS_"]
        pub fn octave_map_assign1(
            this: *mut root::octave_map,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            rhs: *const root::octave_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6assignERK5ArrayI10idx_vectorERKS_"]
        pub fn octave_map_assign2(
            this: *mut root::octave_map,
            ia: *const root::Array<root::idx_vector>,
            rhs: *const root::octave_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6assignERK17octave_value_listRKS_"]
        pub fn octave_map_assign3(
            this: *mut root::octave_map,
            arg1: *const root::octave_value_list,
            rhs: *const root::octave_map,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6assignERK17octave_value_listRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK4Cell"]
        pub fn octave_map_assign4(
            this: *mut root::octave_map,
            idx: *const root::octave_value_list,
            k: *const root::std::string,
            rhs: *const root::Cell,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map15delete_elementsERK10idx_vector"]
        pub fn octave_map_delete_elements(this: *mut root::octave_map, i: *const root::idx_vector);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map15delete_elementsEiRK10idx_vector"]
        pub fn octave_map_delete_elements1(
            this: *mut root::octave_map,
            dim: ::std::os::raw::c_int,
            i: *const root::idx_vector,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map15delete_elementsERK5ArrayI10idx_vectorE"]
        pub fn octave_map_delete_elements2(
            this: *mut root::octave_map,
            ia: *const root::Array<root::idx_vector>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map15delete_elementsERK17octave_value_list"]
        pub fn octave_map_delete_elements3(
            this: *mut root::octave_map,
            arg1: *const root::octave_value_list,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map6concatERKS_RK5ArrayIlE"]
        pub fn octave_map_concat(
            this: *mut root::octave_map,
            rb: *const root::octave_map,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::octave_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10octave_map17fast_elem_extractEl"]
        pub fn octave_map_fast_elem_extract(
            this: *const root::octave_map,
            n: root::octave_idx_type,
        ) -> root::octave_scalar_map;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_map16fast_elem_insertElRK17octave_scalar_map"]
        pub fn octave_map_fast_elem_insert(
            this: *mut root::octave_map,
            n: root::octave_idx_type,
            rhs: *const root::octave_scalar_map,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10octave_mapC1ERK17octave_scalar_map"]
        pub fn octave_map_octave_map(
            this: *mut root::octave_map,
            m: *const root::octave_scalar_map,
        );
    }
    impl octave_map {
        #[inline]
        pub unsafe fn getfield(&self, key: *const root::std::string) -> root::Cell {
            octave_map_getfield(self, key)
        }
        #[inline]
        pub unsafe fn setfield(&mut self, key: *const root::std::string, val: *const root::Cell) {
            octave_map_setfield(self, key, val)
        }
        #[inline]
        pub unsafe fn rmfield(&mut self, key: *const root::std::string) {
            octave_map_rmfield(self, key)
        }
        #[inline]
        pub unsafe fn orderfields(&self) -> root::octave_map {
            octave_map_orderfields(self)
        }
        #[inline]
        pub unsafe fn orderfields1(
            &self,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_map {
            octave_map_orderfields1(self, perm)
        }
        #[inline]
        pub unsafe fn orderfields2(
            &self,
            other: *const root::octave_map,
            perm: *mut root::Array<root::octave_idx_type>,
        ) -> root::octave_map {
            octave_map_orderfields2(self, other, perm)
        }
        #[inline]
        pub unsafe fn contents(&self, k: *const root::std::string) -> root::Cell {
            octave_map_contents(self, k)
        }
        #[inline]
        pub unsafe fn contents1(&mut self, k: *const root::std::string) -> *mut root::Cell {
            octave_map_contents1(self, k)
        }
        #[inline]
        pub unsafe fn elem(&self, n: root::octave_idx_type) -> root::octave_scalar_map {
            octave_map_elem(self, n)
        }
        #[inline]
        pub unsafe fn elem1(
            &self,
            i: root::octave_idx_type,
            j: root::octave_idx_type,
        ) -> root::octave_scalar_map {
            octave_map_elem1(self, i, j)
        }
        #[inline]
        pub unsafe fn elem2(
            &self,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::octave_scalar_map {
            octave_map_elem2(self, ra_idx)
        }
        #[inline]
        pub unsafe fn squeeze(&self) -> root::octave_map {
            octave_map_squeeze(self)
        }
        #[inline]
        pub unsafe fn permute(
            &self,
            vec: *const root::Array<::std::os::raw::c_int>,
            inv: bool,
        ) -> root::octave_map {
            octave_map_permute(self, vec, inv)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::octave_map {
            octave_map_transpose(self)
        }
        #[inline]
        pub unsafe fn reshape(&self, dv: *const root::dim_vector) -> root::octave_map {
            octave_map_reshape(self, dv)
        }
        #[inline]
        pub unsafe fn resize(&mut self, dv: *const root::dim_vector, fill: bool) {
            octave_map_resize(self, dv, fill)
        }
        #[inline]
        pub unsafe fn cat(
            dim: ::std::os::raw::c_int,
            n: root::octave_idx_type,
            map_list: *const root::octave_scalar_map,
        ) -> root::octave_map {
            octave_map_cat(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn cat1(
            dim: ::std::os::raw::c_int,
            n: root::octave_idx_type,
            map_list: *const root::octave_map,
        ) -> root::octave_map {
            octave_map_cat1(dim, n, map_list)
        }
        #[inline]
        pub unsafe fn index(
            &self,
            i: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::octave_map {
            octave_map_index(self, i, resize_ok)
        }
        #[inline]
        pub unsafe fn index1(
            &self,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            resize_ok: bool,
        ) -> root::octave_map {
            octave_map_index1(self, i, j, resize_ok)
        }
        #[inline]
        pub unsafe fn index2(
            &self,
            ia: *const root::Array<root::idx_vector>,
            resize_ok: bool,
        ) -> root::octave_map {
            octave_map_index2(self, ia, resize_ok)
        }
        #[inline]
        pub unsafe fn index3(
            &self,
            arg1: *const root::octave_value_list,
            resize_ok: bool,
        ) -> root::octave_map {
            octave_map_index3(self, arg1, resize_ok)
        }
        #[inline]
        pub unsafe fn column(&self, k: root::octave_idx_type) -> root::octave_map {
            octave_map_column(self, k)
        }
        #[inline]
        pub unsafe fn page(&self, k: root::octave_idx_type) -> root::octave_map {
            octave_map_page(self, k)
        }
        #[inline]
        pub unsafe fn assign(&mut self, i: *const root::idx_vector, rhs: *const root::octave_map) {
            octave_map_assign(self, i, rhs)
        }
        #[inline]
        pub unsafe fn assign1(
            &mut self,
            i: *const root::idx_vector,
            j: *const root::idx_vector,
            rhs: *const root::octave_map,
        ) {
            octave_map_assign1(self, i, j, rhs)
        }
        #[inline]
        pub unsafe fn assign2(
            &mut self,
            ia: *const root::Array<root::idx_vector>,
            rhs: *const root::octave_map,
        ) {
            octave_map_assign2(self, ia, rhs)
        }
        #[inline]
        pub unsafe fn assign3(
            &mut self,
            arg1: *const root::octave_value_list,
            rhs: *const root::octave_map,
        ) {
            octave_map_assign3(self, arg1, rhs)
        }
        #[inline]
        pub unsafe fn assign4(
            &mut self,
            idx: *const root::octave_value_list,
            k: *const root::std::string,
            rhs: *const root::Cell,
        ) {
            octave_map_assign4(self, idx, k, rhs)
        }
        #[inline]
        pub unsafe fn delete_elements(&mut self, i: *const root::idx_vector) {
            octave_map_delete_elements(self, i)
        }
        #[inline]
        pub unsafe fn delete_elements1(
            &mut self,
            dim: ::std::os::raw::c_int,
            i: *const root::idx_vector,
        ) {
            octave_map_delete_elements1(self, dim, i)
        }
        #[inline]
        pub unsafe fn delete_elements2(&mut self, ia: *const root::Array<root::idx_vector>) {
            octave_map_delete_elements2(self, ia)
        }
        #[inline]
        pub unsafe fn delete_elements3(&mut self, arg1: *const root::octave_value_list) {
            octave_map_delete_elements3(self, arg1)
        }
        #[inline]
        pub unsafe fn concat(
            &mut self,
            rb: *const root::octave_map,
            ra_idx: *const root::Array<root::octave_idx_type>,
        ) -> root::octave_map {
            octave_map_concat(self, rb, ra_idx)
        }
        #[inline]
        pub unsafe fn fast_elem_extract(
            &self,
            n: root::octave_idx_type,
        ) -> root::octave_scalar_map {
            octave_map_fast_elem_extract(self, n)
        }
        #[inline]
        pub unsafe fn fast_elem_insert(
            &mut self,
            n: root::octave_idx_type,
            rhs: *const root::octave_scalar_map,
        ) -> bool {
            octave_map_fast_elem_insert(self, n, rhs)
        }
        #[inline]
        pub unsafe fn new(m: *const root::octave_scalar_map) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_map_octave_map(&mut __bindgen_tmp, m);
            __bindgen_tmp
        }
    }
    pub mod octave_value_typeinfo {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type unary_class_op_fcn = root::octave::type_info_unary_class_op_fcn;
        pub type unary_op_fcn = root::octave::type_info_unary_op_fcn;
        pub type non_const_unary_op_fcn = root::octave::type_info_non_const_unary_op_fcn;
        pub type binary_class_op_fcn = root::octave::type_info_binary_class_op_fcn;
        pub type binary_op_fcn = root::octave::type_info_binary_op_fcn;
        pub type cat_op_fcn = root::octave::type_info_cat_op_fcn;
        pub type assign_op_fcn = root::octave::type_info_assign_op_fcn;
        pub type assignany_op_fcn = root::octave::type_info_assignany_op_fcn;
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo13register_typeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_RK12octave_value"]
            pub fn register_type(
                t_name: *const root::std::string,
                c_name: *const root::std::string,
                val: *const root::octave_value,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo23register_unary_class_opEN12octave_value8unary_opEPFS0_RKS0_E"]
            pub fn register_unary_class_op(
                op: root::octave_value_unary_op,
                f: root::octave_value_typeinfo::unary_class_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo17register_unary_opEN12octave_value8unary_opEiPFS0_RK17octave_base_valueE"]
            pub fn register_unary_op(
                op: root::octave_value_unary_op,
                t: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::unary_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo27register_non_const_unary_opEN12octave_value8unary_opEiPFvR17octave_base_valueE"]
            pub fn register_non_const_unary_op(
                op: root::octave_value_unary_op,
                t: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::non_const_unary_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value9binary_opEPFS0_RKS0_S3_E"]
            pub fn register_binary_class_op(
                op: root::octave_value_binary_op,
                f: root::octave_value_typeinfo::binary_class_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo18register_binary_opEN12octave_value9binary_opEiiPFS0_RK17octave_base_valueS4_E"]
            pub fn register_binary_op(
                op: root::octave_value_binary_op,
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::binary_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo24register_binary_class_opEN12octave_value18compound_binary_opEPFS0_RKS0_S3_E"]
            pub fn register_binary_class_op1(
                op: root::octave_value_compound_binary_op,
                f: root::octave_value_typeinfo::binary_class_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo18register_binary_opEN12octave_value18compound_binary_opEiiPFS0_RK17octave_base_valueS4_E"]
            pub fn register_binary_op1(
                op: root::octave_value_compound_binary_op,
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::binary_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo15register_cat_opEiiPF12octave_valueR17octave_base_valueRKS1_RK5ArrayIlEE"]
            pub fn register_cat_op(
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::cat_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo18register_assign_opEN12octave_value9assign_opEiiPFS0_R17octave_base_valueRK17octave_value_listRKS2_E"]
            pub fn register_assign_op(
                op: root::octave_value_assign_op,
                t_lhs: ::std::os::raw::c_int,
                t_rhs: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::assign_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo21register_assignany_opEN12octave_value9assign_opEiPFS0_R17octave_base_valueRK17octave_value_listRKS0_E"]
            pub fn register_assignany_op(
                op: root::octave_value_assign_op,
                t_lhs: ::std::os::raw::c_int,
                f: root::octave_value_typeinfo::assignany_op_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo25register_pref_assign_convEiii"]
            pub fn register_pref_assign_conv(
                t_lhs: ::std::os::raw::c_int,
                t_rhs: ::std::os::raw::c_int,
                t_result: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo20register_widening_opEiiPFP17octave_base_valueRKS0_E"]
            pub fn register_widening_op(
                t: ::std::os::raw::c_int,
                t_result: ::std::os::raw::c_int,
                f: root::octave_base_value_type_conv_fcn,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo11lookup_typeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn lookup_type(nm: *const root::std::string) -> root::octave_value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo21lookup_unary_class_opEN12octave_value8unary_opE"]
            pub fn lookup_unary_class_op(
                op: root::octave_value_unary_op,
            ) -> root::octave_value_typeinfo::unary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo15lookup_unary_opEN12octave_value8unary_opEi"]
            pub fn lookup_unary_op(
                op: root::octave_value_unary_op,
                t: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::unary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo25lookup_non_const_unary_opEN12octave_value8unary_opEi"]
            pub fn lookup_non_const_unary_op(
                op: root::octave_value_unary_op,
                t: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::non_const_unary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo22lookup_binary_class_opEN12octave_value9binary_opE"]
            pub fn lookup_binary_class_op(
                op: root::octave_value_binary_op,
            ) -> root::octave_value_typeinfo::binary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo16lookup_binary_opEN12octave_value9binary_opEii"]
            pub fn lookup_binary_op(
                op: root::octave_value_binary_op,
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::binary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo22lookup_binary_class_opEN12octave_value18compound_binary_opE"]
            pub fn lookup_binary_class_op1(
                op: root::octave_value_compound_binary_op,
            ) -> root::octave_value_typeinfo::binary_class_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo16lookup_binary_opEN12octave_value18compound_binary_opEii"]
            pub fn lookup_binary_op1(
                op: root::octave_value_compound_binary_op,
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::binary_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo13lookup_cat_opEii"]
            pub fn lookup_cat_op(
                t1: ::std::os::raw::c_int,
                t2: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::cat_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo16lookup_assign_opEN12octave_value9assign_opEii"]
            pub fn lookup_assign_op(
                op: root::octave_value_assign_op,
                t_lhs: ::std::os::raw::c_int,
                t_rhs: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::assign_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo19lookup_assignany_opEN12octave_value9assign_opEi"]
            pub fn lookup_assignany_op(
                op: root::octave_value_assign_op,
                t_lhs: ::std::os::raw::c_int,
            ) -> root::octave_value_typeinfo::assignany_op_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo23lookup_pref_assign_convEii"]
            pub fn lookup_pref_assign_conv(
                t_lhs: ::std::os::raw::c_int,
                t_rhs: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo18lookup_widening_opEii"]
            pub fn lookup_widening_op(
                t: ::std::os::raw::c_int,
                t_result: ::std::os::raw::c_int,
            ) -> root::octave_base_value_type_conv_fcn;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo20installed_type_namesEv"]
            pub fn installed_type_names() -> root::string_vector;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN21octave_value_typeinfo19installed_type_infoEv"]
            pub fn installed_type_info() -> root::octave_scalar_map;
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_function {
        pub _base: root::octave_base_value,
        pub relative: bool,
        pub locked: bool,
        pub private_function: bool,
        pub xdispatch_class: root::std::string,
        pub xpackage_name: root::std::string,
        pub my_name: root::std::string,
        pub my_dir_name: root::std::string,
        pub doc: root::std::string,
    }
    #[test]
    fn bindgen_test_layout_octave_function() {
        assert_eq!(
            ::core::mem::size_of::<octave_function>(),
            184usize,
            concat!("Size of: ", stringify!(octave_function))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_function>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_function))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_function>())).relative as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(relative)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_function>())).locked as *const _ as usize },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(locked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_function>())).private_function as *const _ as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(private_function)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_function>())).xdispatch_class as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(xdispatch_class)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_function>())).xpackage_name as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(xpackage_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_function>())).my_name as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(my_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_function>())).my_dir_name as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(my_dir_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_function>())).doc as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_function),
                "::",
                stringify!(doc)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15octave_function5cloneEv"]
        pub fn octave_function_clone(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::octave_base_value;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15octave_function11empty_cloneEv"]
        pub fn octave_function_empty_clone(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::octave_base_value;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_builtin {
        pub _base: root::octave_function,
        pub f: root::octave_builtin_fcn,
        pub m: root::octave_builtin_meth,
        pub file: root::std::string,
        pub dispatch_classes: [u64; 6usize],
        pub jtype: *mut root::octave::jit_type,
    }
    pub type octave_builtin_meth = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::octave::interpreter,
            arg2: *const root::octave_value_list,
            arg3: ::std::os::raw::c_int,
        ) -> root::octave_value_list,
    >;
    pub type octave_builtin_fcn = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const root::octave_value_list,
            arg2: ::std::os::raw::c_int,
        ) -> root::octave_value_list,
    >;
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin4t_idE"]
        pub static mut octave_builtin_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin6t_nameB5cxx11E"]
        pub static octave_builtin_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin6c_nameB5cxx11E"]
        pub static octave_builtin_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_builtin() {
        assert_eq!(
            ::core::mem::size_of::<octave_builtin>(),
            288usize,
            concat!("Size of: ", stringify!(octave_builtin))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_builtin>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_builtin))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_builtin>())).f as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_builtin),
                "::",
                stringify!(f)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_builtin>())).m as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_builtin),
                "::",
                stringify!(m)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_builtin>())).file as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_builtin),
                "::",
                stringify!(file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_builtin>())).dispatch_classes as *const _ as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_builtin),
                "::",
                stringify!(dispatch_classes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_builtin>())).jtype as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_builtin),
                "::",
                stringify!(jtype)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14octave_builtin6to_jitEv"]
        pub fn octave_builtin_to_jit(
            this: *const root::octave_builtin,
        ) -> *mut root::octave::jit_type;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin9stash_jitERN6octave8jit_typeE"]
        pub fn octave_builtin_stash_jit(
            this: *mut root::octave_builtin,
            type_: *mut root::octave::jit_type,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14octave_builtin8functionEv"]
        pub fn octave_builtin_function(
            this: *const root::octave_builtin,
        ) -> root::octave_builtin_fcn;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14octave_builtin6methodEv"]
        pub fn octave_builtin_method(
            this: *const root::octave_builtin,
        ) -> root::octave_builtin_meth;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin13register_typeEv"]
        pub fn octave_builtin_register_type();
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin13register_typeERN6octave9type_infoE"]
        pub fn octave_builtin_register_type1(arg1: *mut root::octave::type_info);
    }
    impl octave_builtin {
        #[inline]
        pub unsafe fn to_jit(&self) -> *mut root::octave::jit_type {
            octave_builtin_to_jit(self)
        }
        #[inline]
        pub unsafe fn stash_jit(&mut self, type_: *mut root::octave::jit_type) {
            octave_builtin_stash_jit(self, type_)
        }
        #[inline]
        pub unsafe fn function(&self) -> root::octave_builtin_fcn {
            octave_builtin_function(self)
        }
        #[inline]
        pub unsafe fn method(&self) -> root::octave_builtin_meth {
            octave_builtin_method(self)
        }
        #[inline]
        pub unsafe fn register_type() {
            octave_builtin_register_type()
        }
        #[inline]
        pub unsafe fn register_type1(arg1: *mut root::octave::type_info) {
            octave_builtin_register_type1(arg1)
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin4callERN6octave14tree_evaluatorEiRK17octave_value_list"]
        pub fn octave_builtin_call(
            this: *mut ::std::os::raw::c_void,
            tw: *mut root::octave::tree_evaluator,
            nargout: ::std::os::raw::c_int,
            args: *const root::octave_value_list,
        ) -> root::octave_value_list;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14octave_builtin19push_dispatch_classERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_builtin_push_dispatch_class(
            this: *mut ::std::os::raw::c_void,
            dispatch_type: *const root::std::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14octave_builtin22handles_dispatch_classERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_builtin_handles_dispatch_class(
            this: *mut ::std::os::raw::c_void,
            dispatch_type: *const root::std::string,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct octave_dld_function {
        pub _base: root::octave_builtin,
        pub sh_lib: root::octave::dynamic_library,
        pub t_checked: root::octave::sys::time,
        pub system_fcn_file: bool,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function4t_idE"]
        pub static mut octave_dld_function_t_id: ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function6t_nameB5cxx11E"]
        pub static octave_dld_function_t_name: root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function6c_nameB5cxx11E"]
        pub static octave_dld_function_c_name: root::std::string;
    }
    #[test]
    fn bindgen_test_layout_octave_dld_function() {
        assert_eq!(
            ::core::mem::size_of::<octave_dld_function>(),
            320usize,
            concat!("Size of: ", stringify!(octave_dld_function))
        );
        assert_eq!(
            ::core::mem::align_of::<octave_dld_function>(),
            8usize,
            concat!("Alignment of ", stringify!(octave_dld_function))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<octave_dld_function>())).sh_lib as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_dld_function),
                "::",
                stringify!(sh_lib)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_dld_function>())).t_checked as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_dld_function),
                "::",
                stringify!(t_checked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<octave_dld_function>())).system_fcn_file as *const _
                    as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(octave_dld_function),
                "::",
                stringify!(system_fcn_file)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function6createEPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESG_"]
        pub fn octave_dld_function_create(
            ff: root::octave_builtin_fcn,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> *mut root::octave_dld_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function6createEPF17octave_value_listRN6octave11interpreterERKS0_iERKNS1_15dynamic_libraryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESI_"]
        pub fn octave_dld_function_create1(
            mm: root::octave_builtin_meth,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> *mut root::octave_dld_function;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function13register_typeEv"]
        pub fn octave_dld_function_register_type();
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_function13register_typeERN6octave9type_infoE"]
        pub fn octave_dld_function_register_type1(arg1: *mut root::octave::type_info);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_functionC1EPF17octave_value_listRKS0_iERKN6octave15dynamic_libraryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESG_"]
        pub fn octave_dld_function_octave_dld_function(
            this: *mut root::octave_dld_function,
            ff: root::octave_builtin_fcn,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_functionC1EPF17octave_value_listRN6octave11interpreterERKS0_iERKNS1_15dynamic_libraryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESI_"]
        pub fn octave_dld_function_octave_dld_function1(
            this: *mut root::octave_dld_function,
            mm: root::octave_builtin_meth,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        );
    }
    impl octave_dld_function {
        #[inline]
        pub unsafe fn create(
            ff: root::octave_builtin_fcn,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> *mut root::octave_dld_function {
            octave_dld_function_create(ff, shl, nm, ds)
        }
        #[inline]
        pub unsafe fn create1(
            mm: root::octave_builtin_meth,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> *mut root::octave_dld_function {
            octave_dld_function_create1(mm, shl, nm, ds)
        }
        #[inline]
        pub unsafe fn register_type() {
            octave_dld_function_register_type()
        }
        #[inline]
        pub unsafe fn register_type1(arg1: *mut root::octave::type_info) {
            octave_dld_function_register_type1(arg1)
        }
        #[inline]
        pub unsafe fn new(
            ff: root::octave_builtin_fcn,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_dld_function_octave_dld_function(&mut __bindgen_tmp, ff, shl, nm, ds);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            mm: root::octave_builtin_meth,
            shl: *const root::octave::dynamic_library,
            nm: *const root::std::string,
            ds: *const root::std::string,
        ) -> Self {
            let mut __bindgen_tmp = ::core::mem::uninitialized();
            octave_dld_function_octave_dld_function1(&mut __bindgen_tmp, mm, shl, nm, ds);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19octave_dld_functionD1Ev"]
        pub fn octave_dld_function_octave_dld_function_destructor(
            this: *mut root::octave_dld_function,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19octave_dld_function13fcn_file_nameB5cxx11Ev"]
        pub fn octave_dld_function_fcn_file_name(
            this: *mut ::std::os::raw::c_void,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19octave_dld_function11time_parsedEv"]
        pub fn octave_dld_function_time_parsed(
            this: *mut ::std::os::raw::c_void,
        ) -> root::octave::sys::time;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20octave_www_statementB5cxx11b"]
        pub fn octave_www_statement(html: bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24octave_contrib_statementB5cxx11b"]
        pub fn octave_contrib_statement(html: bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21octave_bugs_statementB5cxx11b"]
        pub fn octave_bugs_statement(html: bool) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33octave_name_version_and_copyrightB5cxx11v"]
        pub fn octave_name_version_and_copyright() -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z50octave_name_version_copyright_copying_and_warrantybRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_name_version_copyright_copying_and_warranty(
            html: bool,
            extra_info: *const root::std::string,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z55octave_name_version_copyright_copying_warranty_and_bugsbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
        pub fn octave_name_version_copyright_copying_warranty_and_bugs(
            html: bool,
            extra_info: *const root::std::string,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22octave_startup_messageB5cxx11b"]
        pub fn octave_startup_message(html: bool) -> root::std::string;
    }
    pub type octave_auto_shlib = root::octave::auto_shlib;
    pub type octave_dld_fcn_installer = ::core::option::Option<
        unsafe extern "C" fn(arg1: *const root::octave::dynamic_library, relative: bool) -> bool,
    >;
    pub type octave_dld_fcn_getter = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const root::octave::dynamic_library,
            relative: bool,
        ) -> *mut root::octave_function,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct oprocstream {
        _unused: [u8; 0],
    }
    pub type octave_diary_buf = root::octave::diary_buf;
    pub type octave_diary_stream = root::octave::diary_stream;
    pub type octave_pager_buf = root::octave::pager_buf;
    pub type octave_pager_stream = root::octave::pager_stream;
    extern "C" {
        #[link_name = "\u{1}_Z14octave_vformatRSoPKcP13__va_list_tag"]
        pub fn octave_vformat(
            os: *mut root::std::ostream,
            fmt: *const ::std::os::raw::c_char,
            args: *mut root::__va_list_tag,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16octave_vasprintfB5cxx11PKcP13__va_list_tag"]
        pub fn octave_vasprintf(
            fmt: *const ::std::os::raw::c_char,
            args: *mut root::__va_list_tag,
        ) -> root::std::string;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12octave_sleepd"]
        pub fn octave_sleep(seconds: f64);
    }
    extern "C" {
        pub fn octave_value_list_create(n: ::std::os::raw::c_int) -> root::octave_value_list;
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        assert_eq!(
            ::core::mem::size_of::<__va_list_tag>(),
            24usize,
            concat!("Size of: ", stringify!(__va_list_tag))
        );
        assert_eq!(
            ::core::mem::align_of::<__va_list_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(__va_list_tag))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_int8_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<i8>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<i8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<i8>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<i8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_int16_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<i16>>(),
            2usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<i16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<i16>>(),
            2usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<i16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_int32_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<i32>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<i32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<i32>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<i32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_int64_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<i64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<i64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<i64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<i64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_uint8_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<u8>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<u8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<u8>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<u8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_uint16_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<u16>>(),
            2usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<u16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<u16>>(),
            2usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_uint32_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<u32>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<u32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<u32>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<u32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_uint64_t_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<u64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<u64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<u64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<u64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_int_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_8() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_9() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Sparse_open0_bool__close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Sparse<bool>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Sparse<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_10() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_11() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_12() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_13() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_14() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_15() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_int_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_int_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_16() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_17() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_18() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_19() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_char_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_char>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_20() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_21() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_22() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_23() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_24() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_25() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_26() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_27() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_28() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_29() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_30() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_31() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_32() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_33() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_34() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_35() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_36() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_37() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_38() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_39() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_40() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_41() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_42() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_43() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_44() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_45() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_46() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_47() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_48() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_49() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_50() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_double_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_double_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<root::Complex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<root::Complex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_51() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_52() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_53() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_54() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_float_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_55() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_56() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_57() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_58() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_59() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_60() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_61() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_62() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_63() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_64() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_float_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_float_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_65() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_66() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_67() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_68() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_FloatComplex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_69() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_70() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_71() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_72() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_73() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_74() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_75() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_76() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_77() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_float_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_float_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_FloatComplex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<root::FloatComplex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_FloatComplex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<root::FloatComplex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_78() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_79() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_80() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_81() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_double_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_Complex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_float_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_FloatComplex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_double_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_Complex_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_float_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MArray_open0_FloatComplex_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MArray<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MArray<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MArray<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_double_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_Complex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<root::Complex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_float_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MDiagArray2_open0_FloatComplex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::MDiagArray2<root::FloatComplex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MDiagArray2<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MDiagArray2<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MDiagArray2<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_82() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_83() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Sparse_open0_bool__close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Sparse<bool>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Sparse<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_84() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_85() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_86() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_87() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MSparse_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MSparse<f64>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MSparse<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MSparse<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MSparse<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_88() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_89() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_90() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_91() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_92() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_93() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_94() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MSparse_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::MSparse<root::Complex>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::MSparse<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::MSparse<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::MSparse<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_95() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_96() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_97() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_98() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_99() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_100() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_101() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_102() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_int8_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_int8>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_int8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_int8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_int8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_int16_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_int16>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_int16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_int16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_int16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_int32_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_int32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_int32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_int32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_int32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_int64_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_int64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_int64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_int64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_int64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_uint8_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_uint8>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_uint8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_uint16_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_uint16>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_uint16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_uint32_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_uint32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_uint32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_intNDArray_open0_octave_uint64_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::intNDArray<root::octave_uint64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::intNDArray<root::octave_uint64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::intNDArray<root::octave_uint64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_f77_int_type_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_f77_int_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_f77_int_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_f77_int_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_f77_int_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_103() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_104() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_octave_idx_type_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_signed_char_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_schar>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_schar>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_schar>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_schar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_short_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_short>>(),
            2usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_short>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_short>>(),
            2usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_short>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_int_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_long_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_long>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_long>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_long>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_long>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_uchar>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_uchar>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_unsigned_short_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_ushort>>(),
            2usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_ushort>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_ushort>>(),
            2usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_ushort>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_unsigned_int_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_uint>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_uint>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_uint>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_uint>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_octave_int_open0_unsigned_long_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave_int<::std::os::raw::c_ulong>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_ulong>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave_int<::std::os::raw::c_ulong>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave_int<::std::os::raw::c_ulong>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_105() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_106() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_octave_idx_type_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_value_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_float_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_double_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f64>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_float_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<f32>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_Complex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<root::Complex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DiagArray2_open0_FloatComplex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::DiagArray2<root::FloatComplex>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::DiagArray2<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::DiagArray2<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::DiagArray2<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_FloatComplex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_char>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Sparse_open0_double_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Sparse<f64>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Sparse<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Sparse<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Sparse<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Sparse_open0_Complex_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Sparse<root::Complex>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Sparse<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Sparse<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Sparse<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Sparse_open0_bool__close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Sparse<bool>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Sparse<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Sparse<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_int8_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_int8>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_int8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_int8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_int8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_int16_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_int16>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_int16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_int16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_int16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_int32_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_int32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_int32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_int32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_int32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_int64_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_int64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_int64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_int64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_int64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_uint8_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_uint8>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_uint8>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_uint8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_uint8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_uint16_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_uint16>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_uint16>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_uint16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_uint16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_uint32_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_uint32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_uint32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_uint32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_uint32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_uint64_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_uint64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_uint64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_uint64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_uint64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_107() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_108() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_8() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_Complex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_float_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_FloatComplex_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_109() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_double_close0_instantiation_9() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f64>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_Complex_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::Complex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::Complex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::Complex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_float_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<f32>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<f32>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_FloatComplex_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::FloatComplex>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::FloatComplex>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::FloatComplex>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_110() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_111() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_value_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_112() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_113() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_value_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_value_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_value_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_int_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_114() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_115() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_116() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_117() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_118() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_119() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_120() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_121() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_122() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_octave_idx_type_close0_instantiation_123() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::octave_idx_type>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::octave_idx_type>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::octave_idx_type>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_string_close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<root::std::string>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<root::std::string>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<root::std::string>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_octave_value_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut root::octave_value>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut root::octave_value>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut root::octave_value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut root::octave_value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_1() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_2() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_3() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_5() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_8() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_9() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_6() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_ptr_void_close0_instantiation_10() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<*mut ::std::os::raw::c_void>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_8() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_bool__close0_instantiation_9() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<bool>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<bool>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_base_list_open0_regexp_match_element_close0_instantiation() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::base_list>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::base_list)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::base_list>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::base_list)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Array_open0_int_close0_instantiation_7() {
        assert_eq!(
            ::core::mem::size_of::<root::Array<::std::os::raw::c_int>>(),
            40usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::Array<::std::os::raw::c_int>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Array<::std::os::raw::c_int>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_refcount_open0_int_close0_instantiation_4() {
        assert_eq!(
            ::core::mem::size_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<root::octave::refcount<::std::os::raw::c_int>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::octave::refcount<::std::os::raw::c_int>)
            )
        );
    }
}
